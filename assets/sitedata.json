


{
  "pages": [
    {
      
      
      
      "content": "\n\n\n  404\n\n  Page not found :(\n  The requested page could not be found.\n\n",
      "url": "/404.html"
    },{
      
      "title": "Вывод уравнения движения механизма",
      
      "content": "Рассмотрим движение плоского механизма, представленного на рисунке 1. Механизм состоит из тела 1, представляющего собой два жестко соединенных в точке В стержня. В точке О тело 1 шарнирно закреплено на неподвижной опоре. Вдоль стержня АВ может двигаться шарик M (тело 2), который представлен материальной точкой с известной массой \\(m\\). К шарику прикреплена пружина, другой конец которой закреплен в точке А тела 1. Механизм движется в вертикальной плоскости: тело 1 вращается вокруг шарнира О по закону:\n\n[\\varphi = \\varphi_0 + \\omega t]\n\n\nРисунок 1 - Схема механической системы и силы, действующие на шарик\n\nВывод уравнения движения шарика вдоль стержня с использованием уравнений относительного движения\n\nУравнение относительного движения шарика (по отношению к неинерциальной системе координат \\(Axy\\)) в векторной форме имеет вид\n\n[m \\vec{a}_r = \\vec{F}_y + m \\vec g + \\vec N_y + \\vec{\\Phi}^e + \\vec{\\Phi}^k]\n\nВ правой части уравнения к активным силам (сила действия пружины и сила притяжения), силе реакции опоры (сила действия стержня АВ на шарик) добавлены переносная сила инерции \\(\\Phi^e\\), учитывающая вращение подвижной системы координат вокруг шарнира О и сила инерции Кориолиса \\(\\Phi^k\\).\n\nАктивные силы и сила реакции\n\nНа шарик действуют сила пружины, которая определяется ее деформацией относительно свободной длины \\(l_0\\) и жесткостью \\(k\\):\n\n[F_y = k (x-l_0)]\n\nсила притяжения \\(G = m g\\) и сила реакции стержня АВ – \\(N_y\\), которая направлена перпендикулярно стержню.\n\nСилы инерции\n\nПереносная сила инерции \\(\\Phi^e\\) при вращении тела 1 с постоянной угловой скоростью \\(\\omega\\) определяется выражением\n\n[\\Phi^e = \\omega^2 \\, OM \\, m]\n\nСила инерции Кориолиса направлена перпендикулярно стержню АВ и определяется выражением\n\n[\\Phi^k = 2 m \\dot x \\omega]\n\nНаправления сил инерции показано на рисунке 2.\n\n\nРисунок 2 - Силы инерции\n\nУравнения движения\n\nПроецируя векторное уравнение относительного движения шарика на ось \\(Ax\\), получим\n\n[m \\ddot x = m \\omega^2 OM \\cos \\gamma  - mg \\sin \\varphi - k (x - l_0)]\n\nУчитывая, что \\(\\cos \\gamma = x / OM\\):\n\n[m \\ddot x = m \\omega^2 x - mg \\sin \\varphi - k (x - l_0)]\n\nПроекция уравнения на ось \\(Ay\\)\n\n[0 = - m \\omega^2 ОА - mg \\cos \\varphi  +  N_y - 2 m \\dot x \\omega]\n\nпозволит найти силу реакции стержня АВ\n\n[N_y = m \\omega^2 ОА + mg \\cos \\varphi + 2 m \\dot x \\omega]\n\nВывод уравнения движения шарика вдоль стержня с использованием уравнений абсолютного движения\n\nКоординатный столбец радиус вектора шарика в неподвижной системе координат\n\nЗапишем положение шарика в неподвижной системе координат \\(Ox_0y_0\\), начало которой находится в шарнире О. Координатный столбец радиус-вектора шарика в неподвижной системе координат выражен через его положение по отношению к подвижной системе координат \\(Axy\\) (координата \\(x\\)) и угловое положение  подвижной системы координат по отношению к неподвижной (угол \\(\\varphi\\)):\n\n[r = { OA \\, \\text{Sin}[\\varphi[t]]\\ + x[t] \\, \\text{Cos}[\\varphi[t]], -OA \\, \\text{Cos}[\\varphi[t]]\\ + x[t] \\, \\text{Sin}[\\varphi[t]] }]\n\nКоординатный столбец абсолютного ускорения шарика\n\nДля определения абсолютного ускорения шарика используем функцию дифференцирования\n\n[a = \\text{D}[r,{t,2}]]\n\nСилы действующие на шарик\n\nШарик движется под действием силы веса \\(mg\\), силы пружины \\(F_y\\) силы реакции стержня АВ \\(N_y\\). Запишем проекции этих сил на оси неподвижной системы координат\n\n[F = {0,-m\\,g} - k\\,(x[t]-l_0){\\text{Cos}[\\varphi[t]],\\,\\text{Sin}[\\varphi[t]]} + Ny\\,{-\\text{Sin}[\\varphi[t]],\\text{Cos}[\\varphi[t]]}]\n\nУравнение движения\n\nСпроецируем векторное уравнение \\(m \\vec a = \\vec F\\) на подвижную ось $Ax$, единичный вектор которой в неподвижной системе координат определяется выражением\n\n[e_x = { \\text{Cos}[\\varphi[t]],\\, \\text{Sin}[\\varphi[t]]}]\n\nДля вычисления скалярного произведения вектора абсолютного ускорения шарика и единичного вектора \\(e_x\\) используется оператор “точка”:\n\n[\\text{eqx} = m\\,a.e_x = F.e_x //\\text{FullSimplify}]\n\nТакже можно спроецировать уравнение движения на ось \\(Ay\\)\n\n[\\text{eqy} = m\\,a.e_y = F.e_y //\\text{FullSimplify}]\n\nВ уравнениях движения необходимо заменить функцию \\(\\varphi(t)\\) и её производные заданными выражениями, исходя из заданного закона изменения угла поворота \\(\\varphi = \\varphi_0 + \\omega t\\)\n\n[\\text{conditions} = { \\varphi’[t] -&gt; \\omega, \\varphi[t] -&gt; \\varphi0 + \\omega\\,t, \\varphi’‘[t] -&gt; 0 };]\n\nПерепишем первое уравнение\n\n[\\text{eqx} = m\\,a.e_x = F.e_x /. \\text{conditions} //\\text{FullSimplify}]\n\n",
      "url": "/pages/wolfram/CourseWork_1/"
    },{
      
      "title": "Лабораторная работа 1",
      "description": "Пояснения к первой лабораторной работе по курсу Информатика\n",
      "content": "Задание\n\nСоставить блок-схему алгоритма и программу на языке Паскаль для вычисления значений функции\n\n[y = \\frac{a^2 + \\ln bx}{e^x + \\cos (cx)}]\n\nпри заданном значении x, которое вводится с клавиатуры. Параметры функции и значение аргумента  приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      1.5\n    \n    \n      b\n      2.1\n    \n    \n      c\n      3.22\n    \n    \n      x\n      1.83\n    \n  \n\n\nТекст программы\n\nprogram Lab1;\n\n  var a, b, c, x, y: real;\n\nbegin\n  a:=1.5;\n  b:=2.1;\n  c:=3.22;\n\n  write('введите x=');\n  readln(x);\n\n  y:=(sqr(a)+ln(b*x))/(exp(x)+cos(c*x));\n\n  writeln('при x=',x:5:2,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nПояснения\n\nПрограмма на языке Паскаль состоит из трёх основных разделов:\n\n\n  заголовок\n  раздел описаний\n  тело программы или блок опрераторов\n\n\nВ рассматриваемой программе заголовок это первая строчка\nprogram Lab1;\n\nкоторая говорит о том, что эта программа называется Lab1.\n\nСледующий раздел это раздел описаний, где перечисляются используемые в программе переменные с указанием их типов (целые, вещественные, …).\nВ примере это\nvar a, b, c, x, y : real;\n\nВ программе используется 5 переменных, которым можно присвоить вещественные значения (тип real).\n\nВ разделе операторов, который начинается с ключевого слова begin и заканчивается словом end. (с точкой) записываются действия, которые выполняет программа.\nВ первых строчках раздела операторов, объявленным ранее переменным, присваиваются значения:\na:=1.5;\nb:=2.1;\nc:=3.22;\n\nОбратите внимание, что операция присвоения значения переменной записывается при помощи сиволов двоеточие и равно (a:=1.5), чтобы отличать это действие от операции сравнения значений переменных a=1.5, результатом которой будет истина или ложь.\n\nВо второй строке вызывается функция write, которая выводит на экран значение переменной или текст, который передается этой функции в качестве аргумента:\nwrite('введите x=');\n\nПосле этого вызывается функция readln(x), которая приводит к приостановке программы, пока пользователь не введет какое-то значение и не нажмет ENTER.\nreadln(x);\n\nВведённое пользователем значение запиcывается в переменную x.\n\nПосле получения от пользователя программы значения x, можно вычислить значение функции и записать её в переменную y:\ny:=(sqr(a)+ln(b*x))/(exp(x)+cos(c*x));\n\nВ этой строке используются математические функции вычисления корня sqrt, натурального логарифма ln, косинуса cos и экспоненты exp. Аргументы этим функциям передаются в круглых скобках. Для тригонометрических функций предполагается, что аргумент задан в радианах.\n\nРезультат выводится на экран при помощи функции writeln, которая отличается от использованной ранее функции write тем, что после вывода на экран всех значениий, функция переводит крусор на новую строчку.\nwriteln('при x=', x:5:2, ' значение y=', y:5:2);\n\nФункции writeln передано четыре аргумента, которые она выведет на экран друг за другом. В начале выведется текст ‘при x=’ (он записан в кавычках, чтобы транслятор языка Паскаль не рассматривал содержимое этой строки как часть кода порграммы. Далее выводится значение (содержимое) переменной x. Слева от переменной x через двоеточия указаны два числа – 5 и 2, при помощи которых производится форматирование числового значения:\n\n\n  для вывода используется пять позиций на экране;\n  значение переменной x округляется до второго знака после запятой.\n\n\nНапример, если пользователь ввел значение x равное 1.15345687, то на экран будет выведено\n\n\n  \n    \n       \n      1\n      .\n      1\n      5\n    \n  \n\n\nЕсли рассматриваемую строку заменить на\nwriteln('при x=', x, ' значение y=', y);\n\nто на экран тоже будет выведен результат, но с большим количеством “лишних” цифр.\nпри x= 1.1200000000000001E+000 значение y= 1.4303744323446415E+000\n\n\nПосле значения x в той же строке выводится текст ‘ значение y=’ и значение переменной y, с тем же форматом вывода и округления, который использовался для вывода переменной x.\n\nПоследняя функция приостанавливает выполнения программы, ожидая от пользователя нажатия кнопки ENTER, чтобы можно было прочитать результаты работы программы:\nreadln;\n\n\nКод этой же программы на языке Python\nimport math\n\na = 1.5\nb = 2.1\nc = 3.22\n\nx = float(input('Введите значение x = '))\n\ny=(a*a+math.log(b*x))/(math.exp(x)+math.cos(c*x))\n\nprint('при x= {} значение y = {}'.format(x,y))\n\n",
      "url": "/pages/informatics/Lab1/"
    },{
      
      "title": "Лабораторная работа 2",
      "description": "Составление алгоритмов и программирование разветвляющихся алгоритмов с двумя альтернативами, ветвление ветвления, оператор выбора\n",
      "content": "Задание 2.1\n\nСоставить блок-схему алгоритмаи программу на языке Паскаль для вычисления значений функции \\(y = f(x)\\) при произвольных значениях \\(x\\). Получить результат работы программы для двух заданных значениий \\(x\\).\n\n[y = \\left{\n  \\begin{array}{ll}\n  b + 3 \\cos ^3 x &amp; x \\le 2\n  \\sqrt {a x^2 + 7x + 10} &amp; x &gt; 2\n  \\end{array} \\right.]\n\nпри заданном значении x, которое вводится с клавиатуры. Параметры функции приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      3.7\n    \n    \n      b\n      6.1\n    \n  \n\n\nprogram Lab21;\n\nvar a, b, x, y : real;\n\nbegin\n  a:=3.7;b:=6.1;\n  write('Введите x = ');\n  readln(x);\n  if x&lt;=2 then y := b + 3*cos(x)*sqr(cos(x))\n    else y := sqrt(a*sqr(x)+7*x+10);\n  writeln('При x = ', x:5:2, ' значение y = ', y:5:2);\n  readln;\nend.\n\n\nВ программе используется простой условный (разветвляющийся) алгоритм, имеющий два варианта выполнения в зависимости от того истинно ли УСЛОВИЕ или ложно. Этот алгоритм в языке паскаль записывается следующим образом:\n\nif УСЛОВИЕ then\n  begin\n    код, выполняемый, если УСЛОВИЕ истинно;\n    ...;\n    ...;\n  end\nelse\n  begin\n    код, выполнямый если УСЛОВИЕ ложно;\n    ...;\n    ...;    \n  end\n\n\nЕсли фрагмент кода, который выполняется при выполнении условия занимет одну строчку, то запись алгоритма ветвления можно упростить, записав соответствующий код сразу после ключего слова then и else:\n\nif УСЛОВИЕ then код, выполняемый, если УСЛОВИЕ истинно\nelse код, выполнямый если УСЛОВИЕ ложно;\n\n\nАльтернативный вариант формитирования программы, который читается лучше:\n\nif УСЛОВИЕ then\n  код, выполняемый при УСЛОВИИ\nelse\n  код, выполнямый если УСЛОВИЕ не выпоняется;\n\n\nОбратите внимание, что код, записанный после ключевого слова then не заканчивается точкой с запятой, поскольку алгоритм ветвления еще не закончен. Точка с запятой ставится только в конце строки с ключевым словом else.\n\nВозможная также следующая конструкция алгоритма ветвления без альтернативного варианта:\n\nif УСЛОВИЕ then\n  код, выполняемый при УСЛОВИИ ;\n\n\nили, для многострочного кода:\n\nif УСЛОВИЕ then\n  begin\n    код, выполняемый при УСЛОВИИ ;\n    ... ;\n    ... ;\n    ... ;\n  end\n\n\nЗадание 2.2\n\nСоставить схему алгоритма и два варианта программы на языке Паскаль для вычисления значений функции \\(y=f(x)\\) при произвольных значениях \\(x\\).\n\n[y =\\left{\n    \\begin{array}{ll}\n    x + 2b, &amp; x &lt; -1 \n    e^{-x} &amp; -1 \\leq x \\leq 2\n    \\cos ax &amp; x&gt;2\n    \\end{array}\n  \\right.]\n\nПараметры функции приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      3.7\n    \n    \n      b\n      6.1\n    \n  \n\n\nprogram Lab22;\n  var a,b,x,y:real;\nbegin\n  a:=3.7;\n  b:=6.1;\n\n  write('введите x=');\n  readln(x);\n\n  if x&lt;-1 then\n    y:=x+2*b\n  else if x&lt;=2 then\n    y:=exp(-x)\n  else\n    y:=cos(a*x);\n\n  writeln('При x=', x:5:2, ' значение y=', y:5:2);\n  readln;\nend.\n\n\nЗадание 2.3\n\nЗадание. Составить схему алгоритма и программу на языке Турбо Паскаль для вычисления значений функции \\(y=f(x)\\) при произвольных значениях \\(x\\).\n\n[y = \\left{\n  \\begin{array}{ll}\n    x + 2b &amp; x = -2 \n    e^{-x} &amp; x = 1 \n    \\cos ax &amp;  x =3\n  \\end{array}\n  \\right.]\n\nprogram Lab21;\nvar\n    a, b, y : real;\n    x : integer;\nbegin\n\n  a:=3.7;\n  b:=6.1;\n\n  write('Введите x=');\n  readln(x);\n\n  case x of\n    -2 : y:=x+2*b;\n     1 : y:=exp(-x);\n     3 : y:=cos(a*x);\n  else\n    begin\n      writeln ('значение x задано неверно' );\n      writeln('нажми Enter');\n      readln;\n      exit;  \n    end;\n  end;\n\n  writeln('при x=',x,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nВ этой программе используется оператор выбора case. Оператор case целеообразно использовать если необходимо выполнять различный код в зависимости от значения какой-либо переменной.\n\nВ примере вид вычисляемой функции меняется в зависимости от значения целочисленной переменной \\(x\\). Программу для вычисления функции можно написать, используя конструкцию if/else, но код получается громоздким:\n\nprogram Lab21;\nvar\n    a, b, y : real;\n    x : integer;\nbegin\n\n  a:=3.7;\n  b:=6.1;\n\n  write('Введите x=');\n  readln(x);\n\n  if x = -2 then\n    y:=x+2*b\n  else if x = 1\n    y:=exp(-x)\n  else if x = 3\n    y:=cos(a*x)\n  else\n    begin\n      writeln ('значение x задано неверно' );\n      writeln('нажми Enter');\n      readln;\n      exit;  \n    end;\n\n  writeln('при x=',x,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nПеременная, значение которой определяет выполняемый фрагмент кода, может иметь тип integer, char, string.\n\nОператор case может использоваться для выполнения кода при попадании проверяемой переменной в заданный интервал, нижняя и верхняя граница которого записываются через две точки:\n\nprogram Lab21;\nvar\n    x : integer;\nbegin\n\n  write('Введите число от 1 до 9 :');\n  readln(x);\n\n  writeln('Вы ввели ');\n\n  case x of      \n      1..5   : write('число меньше 6'); {Если x в диапазоне от 1 до 5}\n      6..9   : write('число больше 5'); {Если x в диапазоне от 6 до 9}\n  else\n    begin\n      writeln('Значение x вне диапазона от 1 до 9' );\n      writeln('Нажмите Enter');      \n      readln;    \n    end\n  end;\n\nend.\n\n\nили если значение переменной есть в списке значений, перечесляемых через запятую:\n\nprogram Lab21;\nvar\n    x : integer;\nbegin\n\n  write('Введите число от 1 до 9 :');\n  readln(x);\n\n  writeln('Вы ввели ');\n\n  case x of\n      2,4,6,8   : write('нечетное число'); {Если x в списке 2,4,6,8}\n      1,3,5,7,9 : write('четное число');\n\n  else\n    begin\n      writeln('Значение x вне диапазона от 1 до 9' );\n      writeln('Нажмите Enter');      \n    end\n  end;\n\nend.\n\n",
      "url": "/pages/informatics/Lab2/"
    },{
      
      "title": "Лабораторная работа 3",
      "description": "Построение таблицы функции\n",
      "content": "Задание 3.1\n\nЗадание 3.2\n\n",
      "url": "/pages/informatics/Lab3/"
    },{
      
      "title": "Лабораторная работа 4",
      "description": "Одномерные и двумерные массивы\n",
      "content": "Задание 4.1\n\nЗадание 4.2\n\n",
      "url": "/pages/informatics/Lab4/"
    },{
      
      "title": "Лабораторная работа 5",
      "description": "Программирование задач, решаемых с помощью цикла итерационного цикла\n",
      "content": "Итерационный цикл - оператор цикла, в котором количество повторений заранее неизвестно. В итерационном цикле на кажом шаге (итерации) производится проверка достижения желаемого результата.\n\nРассмотрим для примера разложение в ряд функции \\(\\sin x\\):\n\n[y = \\sin x = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\ldots = S_0 + S_1 + S_2 + \\ldots S_k + \\ldots = \\sum_{k=0}^{\\infty} (-1)^n \\frac{x^{2n+1}}{(2n+1)!}]\n\nЧем больше членов этого ряда будет вычислено, тем точнее получится результат, например при \\(x = 1.0\\) радиан :\n\n\n  \n    \n      Количество учитываемых слагаемых\n      Значение последнего члена, \\(S_k\\)\n      Значение ряда, y\n    \n  \n  \n    \n      1\n      1.00000\n      1.00000\n    \n    \n      2\n      0.16667\n      0.83333\n    \n    \n      3\n      0.00833\n      0.84167\n    \n    \n      4\n      0.00020\n      0.84147\n    \n  \n\n\nНапишем программу вычисления этого ряда для заданного значения \\(x\\) с заданной точностью, т.е. будем вычислять \\(S_k\\) и добавлять их к общей сумме до тех пор, пока приращение по модулю не станет меньше заданного значения \\(\\epsilon\\).\n\nПри составлении программы вместо использования общей формулы для вычисления k-го члена ряда (пока без учета знака)\n\n[S_k = \\frac{x^{2k+1}}{(2k+1)!}]\n\nбудем вычислять значение \\(S_k\\) на основе предыдущего значения.\n\nЗаметим, что\n\n[S_2 = \\frac{x^3}{3!} = S_1 \\frac{x^2}{2 \\cdot 3}]\n\n[S_3 = \\frac{x^5}{5!} = S_2 \\frac{x^2}{4 \\cdot 5}]\n\n[S_4 = \\frac{x^7}{7!} = S_3 \\frac{x^2}{6 \\cdot 7} =  S_3 \\frac{x^2}{(4 \\cdot 2-2) \\cdot (4 \\cdot 2-1)}]\n\nили в общем виде\n\n[S_k = S_{k-1} \\frac{x^2}{(2 \\cdot k - 2) \\cdot (2 \\cdot k - 1)}]\n\nДля того чтобы учеть знак перед \\(S_k\\) используем оператор определения остатка от деления\n\n  mod\n\n\nдля четных \\(k\\) (k mod 2 = 0) слагаемое \\(S_k\\) вычитается из общей суммы ряда, для нечетных – добавляется к сумме.\n\nprogram Lab4;\n\nvar\n  i          :integer; { номер итерации }\n  S          :real;    { член ряда }\n  x, y, eps  :real;    { аргумент, функция, точность }\n\nbegin\n  write('Введите значение аргумента x=');\n  readln(x);\n\n  write('Введите точность eps=');\n  readln(eps);\n\n  { Первая итерация }\n  i:= 1;  \n  { Первый член (слагаемое) ряда }\n  S:= x;  \n  { Значение функции для первой итерации }\n  y:= S;\n\n  { Пока |S| больше eps ...}\n  while (abs(S)&gt;eps) do\n    begin\n      i:= i + 1;\n\n      { Вычисляем следующее слагаемое ряда}\n      S:= S*x*x/((2*i-2)*(2*i-1));\n\n      { Уточняем значение ряда на величину Si (с учетом знака) }\n      if i mod 2 = 0 then\n        y:= y - S\n      else\n        y:= y + S;        \n\n      { продолжаем, пока уточнение значения ряда по модулю |S| не станет меньше заданной погрешности eps }      \n    end;\n\n  writeln('Значение функции при x=', x:8:5, ' с точностью до eps=', eps:8:5, ': y=', y:8:5);\n\nend.\n\n\nВерсия этой программы на языке Python:\n\nfrom math import sin\n\nx   = float( input('Введите значение аргумента x=') )\neps = float( input('Введите точность eps=') )\n\ni = 1\nS = x\ny = S\n\nwhile abs(S) &gt; eps:\n  i = i + 1\n\n  S = S*x*x/((2*i-2)*(2*i-1))  \n\n  if i % 2 == 0:\n    y = y - S\n  else:\n    y = y + S   \n\nprint( 'При x={:8.5f} и eps={:8.5f} y={:8.5f}, точное значение {:8.5f}'.format(x, eps, y, sin(x)) )\n\n",
      "url": "/pages/informatics/Lab5/"
    },{
      
      "title": "Лабораторная работа 6",
      "description": "Процедуры и функции\n",
      "content": "Подпрограмма самостоятельный именованный фрагмент программы, реализующий определенный алгоритм и допускающий многократное обращение к нему из различных частей основной программы. В турбо-паскале подпрограмма может быть оформлена в виде процедуры или функции.\n\nПроцедуры\n\nОбъявление процедуры начинается с ключевого слова ~procedure~, за которым следуют имя процедуры и список формальных параметров. Список параметров с указанием их типов заключается в круглые скобки. Перед параметрами, с помощью которых в вызывающую программу возвращается результат работы процедуры, ставится слово VAR. После строки с именем процедуры следует тело процедуры, содержащее раздел описаний процедцры и раздел исполняемых операторов процедуры.\n\nprogram Lab6;\n\n{ Объявление процедуры с именем pifagor }\nprocedure pifagor(a, b: real; var c: real);\nbegin\n  c:=sqrt(a*a+b*b);  \nend;\n\n{ Объявление переменных главной программы }\nvar\n  a, b, c : real;\n\n{ Основная программа }\nbegin\n  write('Введите длину катета a = '); readln(a);\n  write('Введите длину катета b = '); readln(b);\n\n  { Вызов процедуры. В третий параметр (с) записывается значение переменной c, вычисляемый внутри процедуры }\n  pifagor(a,b,c);\n\n  writeln('c = ', c:5:2);\n\nend.\n\n\nФункции\n\nФункции - это подпрограмма, результатом работы которой является некоторое значение, подобное переменной. Функция, как и процедура, может иметь список параметров, следующих за именем функции в круглых скобках. Но если имя процедуры используется только для ее вызова, то с именем функции связывается ее значение. Для этого в теле любой функци нужно осуществить присваивание ей (её имени) вычисленного значения.\n\nprogram Lab6;\n\n{ Объявление функции, вычисляющей сумму квадратов катетов прямоугольного треугольника }\nfunction pifagor(a, b: real): real;\nbegin\n  { присваиваем результат работы функции её имени }\n  pifagor:=sqrt(a*a+b*b);  \nend;\n\n{ Объявление переменных главной программы }\nvar\n  a, b, c : real;\n\nbegin\n  write('Введите длину катета a = '); readln(a);\n  write('Введите длину катета b = '); readln(b);\n\n  { Вызов функции }\n  c:= pifagor(a, b);\n\n  { Функция может использоваться в выражениях, как и любая встроенная функция (sin, cos, ...) }\n  c:= 2*pifagor(a, b);   \n\nend.\n\n\nПример задания\n\nСоставить программу на языке Паскаль для вычисления значения функции\n\n[y = \\frac{\\sin ax}{x^2 + a^2}]\n\nв точках \\(x = {0.2, 0.7, 1.0, 1.2, 1.8, 2.0, 2.2}\\) при заданных значениях \\(a = {2, 2.5, 3, 7, 4.1, 4.9}\\). Нахождение значения функции \\(f(x)\\) при заданных значениях а оформить в виде подпрограммы. Результат вывести в виде двумерной таблицы.\n\nprogram lab6;\n\n{ Определяем тип данных -- вектор и двумерный массив }\ntype vector= array [1..20] of real;\n     massiv= array [1..20,1..20] of real;\n\n{ Объявление переменных }\nvar x,a:vector;\n    i,j,k,n,m:integer;\n    y:massiv;\n\n{ Объявление процедуры, которая записывает двумерный массив в параметр y (тип массив) }\n{ Входные параметры процедуры -- размеры массива и массивы x и a }\nprocedure p(n, m : integer; x, a : vector; var y : massiv);\nbegin\n  for i:=1 to n do\n    for j:= 1 to m do\n      y[i,j]:=sin(a[j]*x[i])/(sqr(x[i])+sqr(a[j]));\nend;\n\n{ Тело основной программы }\nbegin\n\n  Write ('Введите количество значений  x и a= ');\n  Readln(n,m);\n\n  { Ввод значений x }\n  for i:=1 to n do\n    begin\n      Write ('Введите x[',i,']=');\n      Readln(x[i]);\n    end;\n  { Ввод значений a }\n  for j:= 1 to m do\n    begin\n      Write ('Введите a[',j,']=');\n      Readln(a[j]);\n    end;\n\n  { Вызов процедуры p и заполнение массива y }\n  p(n, m, x, a, y);\n\n  { После того как массив заполнен, выводим его в виде таблицы}\n\n  { Вывод шапки таблицы }\n  writeln ('         Таблица');\n  writeln('┌───────┬───────┬───────┬───────┬───────┬───────┬───────┐');\n  write('│ x \\ a │');\n\n  { Вывод a в первой строке }\n  for i:=1 to m do           \n    write(a[i]:4:1,'   │');\n  { Перевод строки }\n  writeln;\n\n  { Для каждой строки таблицы от 1 до n }\n  for i:=1 to n do\n    begin\n      writeln('├───────┼───────┼───────┼───────┼───────┼───────┼───────┤');\n\n      { вывод x в  первую колонку i-ой строки }\n      write('|', x[i]:3:1,'    ','│');\n\n      { вывод y в i-ой строке }\n      for j:=1 to m do\n        write(y[i, j]:7:3,'│');\n\n      { Перевод строки }\n      writeln;\n\n    end;\n\n  { Вывод подвала таблицы }  \n  Writeln('└───────┴───────┴───────┴───────┴───────┴───────┴───────┘');\n\n  { Ожидание, пока пользователь не нажмет Enter }\n  readln;\n\nend.\n\n\n",
      "url": "/pages/informatics/Lab6/"
    },{
      
      "title": "Об авторе",
      
      "content": "\n  Юдинцев Вадим Вячеславович. Доцент кафедры теоретической механики и кафедры математических методов в экономике Самарского университета.\n\n\nОбласть интересов\n\n\n  Динамика систем тел, динамика систем тел переменной структуры\n  Задачи активной уборки космического мусора\n  Средства отделения и раскрытия подвижных элементов конструкции космических аппаратов\n  Компьютерная графика\n  Информационные технологии\n\n\nНаучная работа\n\n\n  Статьи\n  Профиль в Scopus\n  Профиль в РИНЦ\n\n\nОбразовательная деятельность\n\n\n  Динамика твёрдого тела и систем твёрдых тел\n  Технологии и языки программирования\n  Компьютерная графика\n  Компьютерный практикум по механике\n  Информатика\n  Управление ИТ-сервисом и контентом\n  Основы Wolfram Mathematica\n  Основы MATLAB\n  Базы данных\n  Прикладные задачи динамики твердого тела и систем тел\n  Методы вычислений\n  Теоретическая механика\n  Динамика систем тел переменной структуры\n\n\n",
      "url": "/about/"
    },{
      
      "title": "Матричная алгебра",
      
      "content": "Матрицы перемножаются по правилам матричной алгебры\n\n&gt;&gt; a = [1 2; 3 4];\n\n\n&gt;&gt; b = a*a\n\nb =\n     7    10\n    15    22\n\n\nЕсли необходимо перемножить матрицы поэлементно, то необходимо использовать оператор .* Конечно, матрицы должны быть одной размерности\n\n&gt;&gt; b = a.*a\n\nb =\n     1     4\n     9    16\n\n\nЭто же относится к операции возведения в степень. Возведение в степень 2 матрицы  a эквивалентно умножению этой матрицы на саму себя\n\n&gt;&gt; b = a^2\n\nb =\n     7    10\n    15    22\n\n\nЕсли нужно возвести в квадрат каждый элемент матрицы, то необходимо использовать оператор .^\n\n&gt;&gt; a.^2\n\nans =\n     1     4\n     9    16\n\n\nДеление матрицы a на матрицу b означает умножение матрицы a на обратную к b матрицу\n\n&gt;&gt; a = [1 2; \n        3 4];\n \n&gt;&gt; b = [4 3; \n        1 8];\n\n&gt;&gt; c = a/b\n\nc =\n    0.2069    0.1724\n    0.6897    0.2414\n\n&gt;&gt; c = a*inv(b)\n\nc =\n    0.2069    0.1724\n    0.6897    0.2414\n\n\nЕсли нужно поделить поэлементно одну матрицу на другую, то необходимо использовать оператор деления с точкой ./\n\n&gt;&gt; c = a./b \n\nc =\n    0.2500    0.6667\n    3.0000    0.5000\n\n",
      "url": "/pages/matlab/algebra/"
    },{
      
      "title": "Pascal",
      "description": "Структура программы, ключевые слова, типы данных\n",
      "content": "Ключевые cлова\n\n\n  \n    \n      and\n      end\n      nil\n      set\n    \n    \n      array\n      file\n      not\n      then\n    \n    \n      begin\n      for\n      of\n      to\n    \n    \n      const\n      goto\n      packed\n      until\n    \n    \n      case\n      function\n      or\n      type\n    \n    \n      div\n      if\n      procedure\n      var\n    \n    \n      do\n      in\n      program\n      while\n    \n    \n      downto\n      label\n      record\n      with\n    \n    \n      else\n      mod\n      repeat\n       \n    \n  \n\n\nСтруктура программы\n\nProgram MyFirstProgram;\n\n  &lt;раздел описаний&gt;\n\nbegin\n\n  &lt;оператор 1&gt;;\n  &lt;оператор 2&gt;;\n  . . . . . . .\n  &lt;оператор N&gt;;\n\nend.\n\n\nПрограмма, которая выводит на экран сообщение “Здравствуй Мир!”\n\nProgram HelloWorld;\nBegin\n   writeln('Здравствуй Мир!');\nEnd.\n\n\nРаздел описаний\n\nРаздел подключаемых модулей\n\nЭтот раздел должен быть первым в разделе описаний. Раздел подключаемых модулей описывает модули, написанные на языке Паскаль в которых объявлены процедуры\n",
      "url": "/pages/informatics/base_syntax/"
    },{
      
      "title": "Манипуляции с матрицами",
      
      "content": "Ввод матрицы\n\nОсновным типом данных в MATLAB является матрица. Элементы матрицы записываются в квадратных скобках. Элементы в строке разделяются запятыми или пробелами:\n\na = [1  2  3]\na = [1, 2, 3]\n\n\nДля ввода матрицы-столбца элементы необходимо разделять точками с запятой\n\na = [1; 2; 3]\n\n\nПрямоугольная или квадратная матрица вводится построчно\n\na = [1 2 3; 4 5 6]\n\n\nКаждую строку матрицы для наглядности можно начинать в коде скрипта или функции с новой строки:\n\na = [1 2 3; \n     4 5 6]\n\n\nСоздание последовательностей\n\nОператор : формирует матрицу-строку от начального значения до конечного значения с заданным шагом:\n\n&gt;&gt; a = 1:0.5:3.9\n\na =\n\n    1.0000    1.5000    2.0000    2.5000    3.0000    3.5000\n\n\nФункция linspace разбивает интервал, заданный своими границами на заданное количество точек\n\n&gt;&gt; a = linspace(1,3.9,4)\n\na =\n    1.0000    1.9667    2.9333    3.9000\n\n\nСпециальные матрицы\n\nМатрица единиц:\n\n&gt;&gt; ones(3,2)\n\nans =\n\n     1     1\n     1     1\n     1     1\n\n\nПри вызове функции с одним аргументом, результатом является квадратная матрица\n\n&gt;&gt; ones(3)\n\nans =\n\n     1     1    1\n     1     1    1\n     1     1    1\n\n\nМатрица нулей\n\n&gt;&gt; zeros(3,2)\n\nans =\n\n     0     0\n     0     0\n     0     0\n\n&gt;&gt; zeros(3)\n\nans =\n\n     0     0    0\n     0     0    0\n     0     0    0\n\n\n\nЕдиничная матрица\n\n&gt;&gt; eye(3)\n\nans =\n\n     1     0    0\n     0     1    0\n     0     0    1\n\n\nОбъединение матриц\n\nСклейка строк (слева направо)\n\n&gt;&gt; a = [1 2 3];\n&gt;&gt; b = [3 5 5];\n&gt;&gt; c = [a b]\n\nc =\n     1     2     3     3     5     5\n~~\n\nТо же самое делает функция **cat**. Склеиваем матрицы по второму измерению (склеиваем столбцы - \"клей наносим справа/слева\") \n\n~~~matlab\n&gt;&gt; cat(2, a, b)\n\nans =\n     1     2     3     3     5     5\n\n\nСклеиваем матрицы по второму измерению (склеиваем столбцы - “клей наносим снизу/сверху”)\n\n&gt;&gt; cat(1, a, b)\n\nans =\n     1     2     3\n     3     5     5\n\n\nИзменение формы матрицы\n\n&gt;&gt; a = [1 2 3;\n        4 5 6;\n        7 8 9;\n        10 1 12]\n\na =\n     1     2     3\n     4     5     6\n     7     8     9\n    10     1    12\n\n\nПревратить матрицу a в матрицу 2 x 6. Указываем только первую размерность, второй размер вычисляется на основе количества элементов в исходной матрице:\n\n&gt;&gt; a = reshape(a, 2, [])\n\na =\n     1     7     2     8     3     9\n     4    10     5     1     6    12\n\n\nМожно указать только второй размер новой матрицы. В этом случае первый размер определится автоматически:\n\n&gt;&gt; a = reshape(a, [], 2)\n\na =\n     1     8\n     4     1\n     7     3\n    10     6\n     2     9\n     5    12\n\n\nМожно явно указать обе размерности\n\n&gt;&gt; a = reshape(a, 3, 4)\n\na =\n     1    10     8     6\n     4     2     1     9\n     7     5     3    12\n\n\nОперация транспонирования матрицы выполняется при помощи оператора ‘ (одинарная кавычка)\n\n&gt;&gt; a'\n\nans =\n     1     4     7\n    10     2     5\n     8     1     3\n     6     9    12\n\n\nили при помощи функции transpose\n\n&gt;&gt; transpose(a)\n\nans =\n     1     4     7\n    10     2     5\n     8     1     3\n     6     9    12\n\n\nКопирование матриц\n\nДана матрица-столбец\n\n&gt;&gt; a = [1; 2];\n\n\nИспользуем функцию repmat: повторяем столбец 5 раз вдоль второго измерения и 1 раз (т.е. ничего не меняем) по первой размерности:\n\n&gt;&gt; repmat(a, 1, 5)\n\nans =\n     1     1     1     1     1\n     2     2     2     2     2\n\n\nМожно сделать копии по двум размерностям\n\n&gt;&gt; b = repmat(a, 2, 5)\n\nb =\n     1     1     1     1     1\n     2     2     2     2     2\n     1     1     1     1     1\n     2     2     2     2     2\n\n\n",
      "url": "/pages/matlab/basic/"
    },{
      
      "title": "Ячейки",
      
      "content": "Для хранения в матричном виде элементов различных типов используются ячейки.\n\nСоздание матрицы ячеек\n\nДля создания матриц ячеек используется функция cell.   Создадим пустую матрицу ячеек 3x3:\n\n&gt;&gt; data = cell(3)\n\ndata =\n  3×3 cell array\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\nПрямоугольная матрица ячеек\n\n&gt;&gt; data = cell(2,3)\n\ndata =\n  2×3 cell array\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\n\nВ отличие от числовых матриц, обращение к элементам матрицы ячеек выполняется при помощи индексов элементов в фигурных скобках, а не в круглых. Запишем в ячейку {1, 1} число\n\n&gt;&gt; data{1,1} = 123\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\nв ячейку {2, 3} строку\n\n&gt;&gt; data{2,3} = 'Текст '\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {'Текст '  }\n\n\nа в ячейку {2, 2} матрицу\n\n&gt;&gt; data{2,2} = [1 2; 3 4]\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {2×2 double}    {'Текст '  }\n\n\nСодержимое матрицы\n\n&gt;&gt; data{2,3}\n\nans =\n    'Текст '\n\n&gt;&gt; data{2,2}\n\nans =\n     1     2\n     3     4    \n\n\nПреобразование\n\nЕсли матрица ячеек содержит только числовые значения, то её можно преобразовать в числовую матрицу при помощи функции cell2mat.\n\nСоздадим матрицу-столбец из двух ячеек. Каждая ячейка содержит числовую матрицу строку:\n\n&gt;&gt; a = {[1,2,3];[4,5,6]}\n\na =\n  2×1 cell array\n    {1×3 double}\n    {1×3 double}\n\n\nПреобразование матрицы ячеек в числовую матрицу\n\n&gt;&gt; cell2mat(a)\n\nans =\n     1     2     3\n     4     5     6\n\n\nЕсли первая ячейка будет содержать матрицу-строку, а вторая – матрицу-столбец, то такое преобразование будет невозможно\n\n&gt;&gt; a = {[1,2,3];[4;5;6]}\n\na =\n  2×1 cell array\n    {1×3 double}\n    {3×1 double}\n\n&gt;&gt; cell2mat(a)\n\nError using cat\nDimensions of arrays being concatenated are not consistent.\n\nError in cell2mat (line 83)\n            m{n} = cat(1,c{:,n});\n\n\nОбратное преобразование числовой матрицы в матрицу ячеек выполняется при помощи функции mat2cell.\nПредположим, что есть квадратная матрица 5x5:\n\n&gt;&gt; a = magic(5)\n\na =\n    17    24     1     8    15\n    23     5     7    14    16\n     4     6    13    20    22\n    10    12    19    21     3\n    11    18    25     2     9\n\n\nРассечём эту матрицу одной горизонтальной линией и двумя вертикальными так, чтобы получилась матрица ячеек 2 на 3, в которой элемент {1,1} содержит первые две строки и два столбца исходной матрицы, элемент {1,2} – две первые строки и столбцы 3 и 4 исходной матрицы:\n\n&gt;&gt; c = mat2cell(a,[2 3],[2 2 1])\n\nc =\n  2×3 cell array\n    {2×2 double}    {2×2 double}    {2×1 double}\n    {3×2 double}    {3×2 double}    {3×1 double}\n\n\nВторым аргументом указывается массив с количествами строк каждой подматрицы, вторым аргументом – количество столбцов у каждой подматрицы. Проверяем результат:\n\n&gt;&gt; c{1,1}\n\nans =\n    17    24\n    23     5\n\n&gt;&gt; c{1,2}\n\nans =\n     1     8\n     7    14\n\n&gt;&gt; c{2,1}\n\nans =\n     4     6\n    10    12\n    11    18\n\n\n",
      "url": "/pages/matlab/cells/"
    },{
      
      "title": "Колонизация",
      "description": "Определение оптимального пути облёта ближайших звёздных систем\n",
      "content": "В текстовом файле заданы координаты ближайших семи к Солнцу звёздных систем:\n\nИмя,                x (пк),    y (пк),    z (пк)\nАльфа Центавра,  -0.472264, -0.361451, -1.151219\nЗвезда Барнарда, -0.017373, -1.816613,  0.149123\nВольф 359,       -0.017373, -1.816613,  0.149123\nЛаланд 21185,    -2.282811,  0.649334,  0.292057\nСириус,          -0.494323,  2.476731, -0.758485\nЭпсилон Эридана,  1.898970,  2.541426, -0.528523\nПроцион,         -1.469312,  3.176170,  0.320024\n\n\nКоординаты выражены в парсеках\n\nДля заданного количества \\(n \\leq 7\\) ближайших звёздных систем определить наиболее оптимальный маршрут их облёта.\n\nОт системы к системе корабль первую половину пути движется с постоянным ускорением, вторую - с замедлением. Ускорение и замедление равно ускорению свободного падения для того, чтобы экипаж корабля в течение всего полёта жил в условиях земной гравитации.\n\nПостроить (вывести на экран) таблицу облёта всех  \\(n\\) звёздных систем в следующем виде:\n\n\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n| № | Отправление    | Прибытие       | Расст., св. лет. | Tкор, лет | Tз, лет | Макс. скорость |\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n| 1 | Солнце         | Альфа Центавра | ...              | ...       | 0.5с    |                |\n| 2 | Альфа Центавра | Вольф 359      | ...              | ...       | ...     |                |\n| 3 | ...            | ...            | ...              | ...       | ...     |                |\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n\nСуммарная длина маршрута ... св. лет.\n\nСуммарная продолжительность маршрута:\n- по часам корабля ... лет\n- по часам Зкмли   ... лет\n\nМаксимальная скорость ...c\n\n\n\nВ каждой строке таблицы должны быть указаны\n\n  точка отправления;\n  точка прибытия;\n  расстояние в световых годах;\n  время перелёта по часам корабля (в годах);\n  время перелёта по часам Земли;\n  максимальная скорость корабля в долях скорости света\n\n\nИтоговый результат (под таблицей):\n\n  пройденный кораблём путь\n  итоговая продолжительность полёта по часам корабля\n  итоговая продолжительность полёта по часам Земли\n\n\nПрограмма должна вывести на экран и сохранить в файл png две проекции маршрута на плоскость xz и xy, на которых дисками обозначены звездные системы.\n\nhttp://www.zitterbug.net/future/future815.html\nhttp://math.ucr.edu/home/baez/physics/Relativity/SR/Rocket/rocket.html\n\nСписок заданий\n",
      "url": "/pages/python/course_works/colonization/"
    },{
      
      "title": "Компьютерный практикум по механике",
      
      "content": "\n  Относительное орбитальное движение\n\n",
      "url": "/pages/comp_mechanics/"
    },{
      
      "title": "Выпуклая оболочка",
      
      "content": "\n  Разработать программу, которая загружает из текстового файла координаты точек на плоскости и строит проходящую через эти точки выпуклую оболочку (многоугольник), содержащую эти точки.\n  Программа должна вывести на экран все точки и построенный многоугольник. Координаты точек, составляющих многоугольник, должны записываться в текстовый файл.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/convex/"
    },{
      
      "title": "Движение наноспутника внутри пускового контейнера",
      
      "content": "Наноспутник типоразмера 3U массой \\(m\\) (от 2 до 6 кг) выталкивается из транспортно-пускового контейнера при помощи пружинного толкателя с известным начальным усилием \\(P_0\\), конечными усилием \\(P_k\\) и ходом \\(h\\).\n\n\n  Напишите MATLAB-функцию, которая определяет для заданной массы наноспутника, начального, конечного усилия пружины и её хода:\n    \n      скорость отделения наноспутника от носителя;\n      продолжительной движения наноспутника внутри контейнера от момента начала движения до окончания работы пружины.\n    \n  \n  Постройте график перемещения наноспутника от времени.\n  Постройте график изменения скорости наноспутника от времени.\n\n\nШаблон функции:\n\nfunction [dv dt] = get_v_t(...)\t\n\t...\nend \n\n\nНаноспутник выталкивается из контейнера при помощи пружины, усилие которой зависит от положения наноспутника внутри контейнера. Ход пружины обычно равен длине наноспутника. Наноспутник типоразмера 3U имеет длину 340.5 мм.\n\n\n\nСила пружины $P$ толкателя изменяется по линейному закону:\n\n[P = P_0 - c x, \\quad 0 \\leq x \\leq h,]\n\nгде \\(P\\) – начальное усилие пружины, \\(c\\) – жёсткость пружины: \n\\(c = \\frac{P_0 - P_k}{h}\\)\n\n\\(P_k\\) – конечное усилие пружины. Работа пружины определяется выражением:\n\n[A = \\frac{P_0 + P_k}{2} h]\n\nЕсли масса носителя, от которого отделяется наноспутник, значительно больше массы наноспутника, то можно принять допущение о том, что вся потенциальная энергия толкателя расходуется на приращение скорости наноспутника. В этом случае изменение кинетической энергии наноспутника равно работе пружинного толкателя:\n\n[T_k - T_0 = A]\n\nгде \\(T_0=0\\) начальная кинетическая энергия наноспутника, \\(A\\) – работа пружинны, \\(T_k\\) – конечная кинетическая энергия наноспутника:\n\n[T_k = \\frac{m V^2}{2}]\n\nСкорость наноспутника определяется выражением:\n\n[V = \\sqrt{\\frac{2 A}{m}}.]\n\nУравнение движения наноспутника под действием силы \\(P\\) имеет вид:\n\n[m \\ddot x = P_0 - c x.]\n\nЭто линейное неоднородное дифференциальное уравнение второго порядка с постоянными коэффициентами. Решение уравнения для нулевых начальных условий \\(x(0)=0\\), \\(\\dot{x}(0) = 0\\) имеет вид:\n\n[x = \\frac{P_0}{c}\\left[1-\\cos \\left(\\sqrt{\\frac{c}{m}}t\\right)\\right].]\n\nВремя движения наноспутника до выхода из пускового контейнера \\(x(t) = h\\) определяется формулой:\n\n[t = \\sqrt{\\frac{m}{c}} \\arccos \\frac{P_k}{P_0}.]\n\n",
      "url": "/pages/matlab/cubesat_motion/"
    },{
      
      "title": "Типы даты и времени в MATLAB",
      
      "content": "Работа с датой и временем\n\nОбъект дата и время\n\nДля создания объекта типа дата используется функция datetime\n\n&gt;&gt; a = datetime(2014,6,28,6,0,0)\n\na = \n  datetime\n   28-Jun-2014 06:00:00\n\n\nФункция позволяет создавать диапазон дат, если указан диапазон изменения одного из аргументов\n\n&gt;&gt; a = datetime(2014,6,28:30,6,0,0)\n\na = \n  1×3 datetime array\n   28-Jun-2014 06:00:00   29-Jun-2014 06:00:00   30-Jun-2014 06:00:00\n\n\n&gt;&gt; a(1)   \n\nans = \n  datetime\n   28-Jun-2014 06:00:00\n\n\nДля создания может быть использован оператор :\n\ndate_array = datetime(2020,4,1,0,0,0):minutes(20):datetime(2020,4,2,0,0,0)\n\ndate_array = \n  1×10 datetime array\nColumns 1 through 5\n   01-Apr-2020 00:00:00   01-Apr-2020 02:40:00   01-Apr-2020 05:20:00   01-Apr-2020 08:00:00   01-Apr-2020 10:40:00\nColumns 6 through 10\n   01-Apr-2020 13:20:00   01-Apr-2020 16:00:00   01-Apr-2020 18:40:00   01-Apr-2020 21:20:00   02-Apr-2020 00:00:00\n\n\nили функция linspace\n\ndate_array = linspace(datetime(2020,4,1,0,0,0),datetime(2020,4,2,0,0,0),10)\n\n\nФормат отображения даты задается свойством datetime.Format\n\n&gt;&gt; a.Format = 'dd.MM.yyyy';\n&gt;&gt; a\n\na = \n  1×3 datetime array\n   28.06.2014   29.06.2014   30.06.2014\n\n\nИнтервал между двумя датами\n\n&gt;&gt; d = a(2) - a(1)\n\nd = \n  duration\n   24:00:00\n\n\nПо умолчанию разница дат отображается в часах. Чтобы изменить формат отображения используется свойство Format\n\n&gt;&gt; d.Format = 'h'\n\nd = \n  duration\n   24 hr\n\n&gt;&gt; d.Format = 'd'\n\nd = \n  duration\n   1 day\n\n\nДля создания интервалов дат могут использоваться функции calmonth, caldays, calweeks, calquarters, calyears\n\nНа 10 дней вперед от 20 февраля 2020 года\n\n&gt;&gt; d1 = datetime(2020,2,20,0,0,0);\n&gt;&gt; d2 = d1 + caldays(10)\n\nd2 = \n  datetime\n   01-Mar-2020 00:00:00\n\n\nНа 1 месяц вперед от 20 февраля 2020 года\n\n&gt;&gt; d2 = d1 + calmonths(1)\n\nd2 = \n  datetime\n   20-Mar-2020 00:00:00\n\n\nНа 1 квартал вперед от 20 февраля 2020 года\n\n&gt;&gt; d2 = d1 + calquarters(1)\n\nd2 = \n  datetime\n   20-May-2020 00:00:00\n\n\n",
      "url": "/pages/matlab/datetime/"
    },{
      
      "title": "Начало работы в DBeaver",
      
      "content": "Скачать DBeaver. Необходимо скачать версию для Вашей системы в левой части страницы — версия Community Edition.\n\nПосле первого запуска DBeaver необходимо создать соединение, нажав на кнопку с изображением «вилки со знаком +» в верхней левой части окна программы.\n\n\n\nНа следующем шаге необходимо выбрать тип соединения, т.е. базу данных, к которой будет устанавливаться соединение, и после этого нажать кнопку «Далее».\n\n\n\nВ открывшемся окне необходимо ввести следующие параметры устанавливаемого соединения:\n\n\n  IP-адрес сервера БД, этот адрес для всех одинаковый (показан на следующем рисунке).\n  Имя базы данных, которое совпадает с номером зачетной книжки, у которой знак тире в номере заменён на знак подчеркивания (пример: 2018_02407).\n  Имя пользователя, которое совпадает с именем базы данных.\n  Пароль, который для каждой базы данных свой, см. сообщение в группе.\n\n\nПосле ввода параметров соединения необходимо нажать кнопку «Готово».\n\n\n\nПосле нажатия кнопки «Готово» слева появится значок подключения с надписью MySQL — имя БД (номер зачетной книжки со знаком подчеркивания).\n\n\n\nПосле того, как соединение установлено необходимо создать новый сценарий (скрипт), в котором записываются выражения на языке SQL.\n\n\n\nВидеоинструкция: подключение БД SQLite в DBeaver\n",
      "url": "/pages/databases/dbeaver/"
    },{
      
      "title": "Дисциплины",
      
      "content": "\n  Динамика твёрдого тела и систем тел\n  Основы Python\n  Компьютерная графика\n  Методы вычислений\n  Основы MATLAB\n  Информатика\n  Управление IT-сервисом и контентом\n  Базы данных\n  Основы Wolfram Mathematica\n  Прикладные задачи динамики твердого тела и систем тел\n  Теоретическая механика\n  Компьютерные и экспериментальные методы в механике\n\n\n",
      "url": "/pages/disciplines/"
    },{
      
      "title": "Расстояние между многоугольниками",
      
      "content": "\n  Даны два многоугольника координатами своих вершин в порядке обхода их по контуру по часовой стрелке.\n  Найти расстояние между многоугольниками. Программа должна показать на экране сами многоугольники, отрезок, обозначающий минимальное расстояние между ними, с указанием длины этого отрезка.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/dist_polygon/"
    },{
      
      "title": "Дубликаты файлов",
      
      "content": "Написать программу, которая сканирует заданный каталог и определяет дубли файлов изображений с расширением jpg, анализируя значения хэш-функции MD5 от содержимого файла. Каталог поиска задается параметром командной строки, например:\n\nfind_duplicates c:\\MyFolder\n\n\nРезультат должен выводится в текстовый файл. В текстовом файле результата должны выводиться имена файлов-дублей с указанием их длины в килобайтах.\n\nc:\\dir1\\file1.jpg : 100 Кб = c:\\dir1\\file2.jpg : 100 Кб = c:\\dir1\\file7.jpg : 100 Кб\nc:\\dir1\\file3.jpg : 150 Кб = c:\\dir1\\file4.jpg : 150 Кб\n\n\nДля вычисления хэш-функции использовать библиотеку hashlib\n\nСписок заданий\n",
      "url": "/pages/python/course_works/duplicate/"
    },{
      
      "title": "Экзаменационные билеты",
      
      "content": "Дан текстовый файл с вопросами по некому курсу лекций. Каждый вопрос в текстовом файле занимает одну строчку. Вопросы сгруппированы по темам. Блоки тем разделяются пустой строкой:\n\nВопрос 1 темы 1\nВопрос 2 темы 1\n...\nВопрос n темы 1\n\nВопрос 1 темы 2\nВопрос 2 темы 2\n...\nВопрос n темы 2\n\n\nНапишите программу, которая для заданного количества вопросов в экзаменационном билете и для заданного количества билетов случайным образом генерирует файл с экзаменационными билетами по заданному шаблону.\nШаблон задается текстовым файлом в котором квадратных скобках заданы поля для замены. Например:\n\nЭкзаменационный билет №[НОМЕР]\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n[ВОПРОСЫ]\n\n\nНапример, 10 билетов с 3 вопросами в каждом.\n\nЭкзаменационный билет №1\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n1. Вопрос 1\n2. Вопрос 2\n3. Вопрос 3\n\n\nЭкзаменационный билет №2\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n1. Вопрос 1\n2. Вопрос 2\n3. Вопрос 3\n\n\nВопросы в билетах не должны повторятся. Вопросы в каждом билете должны быть из разных тем.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/exam/"
    },{
      
      "title": "Динамика отделения створок головного обтекателя",
      
      "content": "Рассматривается схема отделения створок головного обтекателя по “параллельной” схеме без разворота.\n\n\n\nЭтап 1\n\nСтворка головного обтекателя имеет массу 1200 кг. Модель створки представлена тремя тонкими оболочками: полуцилиндром, усеченным конусом, и конусом. Масса створки равномерно распределена по  поверхности. Геометрические параметры створки приведены в таблице.\n\n\n  \n    \n      Параметр\n      Значение\n      Параметр\n      Значение\n    \n  \n  \n    \n      \\(H_1\\)\n      10 м\n      \\(H_2\\)\n      5,5 м\n    \n    \n      \\(H_3\\)\n      0,5 м\n      \\(R_1=R_2\\)\n      3 м\n    \n    \n      \\(R_3\\)\n      0,7 м\n       \n       \n    \n  \n\n\nНайти положение центра масс створки относительно базовой системы координат \\(C_1 x_{b1}y_{b1}z_{b1}\\).\n\nНайти моменты инерции створки относительно осей центральной системы координат \\(B_1 x_{1}y_{1}z_{1}\\).\n\n\n\nЭтап 2\n\nРассматривая створку головного обтекателя, как плоскую фигуру для известного положения центра масс (см. этап 1), известных значений \\(d_2\\) и \\(H\\) найти силы натяжения тросов \\(T_{A1}\\), \\(T_{D1}\\) и размер \\(d_2\\), при которых створка находится в покое в вертикальном положении.\n\n\n\nЭтап 3\n\nСторки отделяются при помощи четрех пневмотических толкателей: два толкателя расположены выше центра масс, два – ниже центра масс. В момент начала движения створок после разделения головного обтекателя на две створки момент сил толкателей относительно центра масс равен нулю.\n\nРассматривая створки как две материальные точки, движущиеся под действием суммарной силы четырех толкателей определить их силовые характеристики (начальное и конечное усилие), обеспечивающие отделение створок с горизонтальной скоростью 5 м/с.\n\nПринять допущение о том, что сила толкателя меняется по линейному закону:\n\n[\\begin{cases}\nF = F_0 - \\frac{F_0 - F_k}{s_k-s_0} s, \\quad s \\leq s_k, \nF = 0, \\quad s &gt; s_k,\n\\end{cases}]\n\nгде \\(F_0\\) – начальное усилие толкателя, \\(F_k\\) – конечное усилие толкателя, \\(s_0 = 1\\) м – начальная длина толкателя, \\(s_k = 2\\) м – конечная длина толкателя (длина, при которой толкатель заканчивает работу).\n\n\n\nЭтап 4\n\nПостроить модель плоского движения створок головного обтекателя при наземной отработке процесса отделения.\n\n",
      "url": "/pages/mechanics-in-space/fairing-side-separation/"
    },{
      
      "title": "Статистические функции и сортировка",
      
      "content": "Рассмотрим в качестве примера матрицу 4x3\n\na = [1.0 2.0 3.0;\n     1.2 5.2 6.1;\n     1.3 8.0 9.6;\n     1.5 3.6 1.6];\n\n\nСтатистические функции\n\nСумма\n\nФункция sum вычисляет сумму элементов в столбцах или строках. Если аргумент функции является строка и столбец, то вычисляется сумма всех элементов, если матрица, то по умолчанию вычисляется сумма элементов в столбцах\n\n&gt;&gt; sum(a)\n\nans =\n    5.0000   18.8000   20.3000\n\n\nВторой аргумент функции sum это номер измерения, в котором требуется вычислить сумму: 1 – сумма элементов в столбцах (это действие по умолчанию), 2 – в строках\n\n&gt;&gt; sum(a,2)\n\nans =\n    6.0000\n   12.5000\n   18.9000\n    6.7000\n\n\nДля того, чтобы найти сумму всех элементов матрицы, можно дважды применить функцию sum\n\n&gt;&gt; sum(sum(a))\n\n\nили вызвать функцию один раз для матрицы преобразованной в один столбец a(:)\n\n&gt;&gt; sum(a(:))\n\n\nМаксимальное значение\n\nАналогично действует функция определения максимального значения max. Функция вычисляет максимальное значение элемента в каждом столбце, если первым аргументом в функцию передана матрица\n\n&gt;&gt; max(a)\n\nans =\n    1.5000    8.0000    9.6000\n\n\nВ отличие от функции sum, для того, чтобы найти максимальные значения в строках матрицы a, номер измерения необходимо передать третьим аргументом\n\n&gt;&gt; max(a,[],2)\n\nans =\n    3.0000\n    6.1000\n    9.6000\n    3.6000\n\n\nВторым аргументом в функцию max можно передать еще одну матрицу той же размерности, что и матрица a. В этом случае будет определятся максимальное значение в двух матрицах:\n\n&gt;&gt; a = [1 2; \n        3 4];\n\n&gt;&gt; b = [2 0;\n        5 1];\n\n&gt;&gt; max(a,b)\n\nans =\n     2     2\n     5     4\n\n\nМинимальное значение\n\nАналогичным образом действует функция min\n\na = [1.0 2.0 3.0;\n     1.2 5.2 6.1;\n     1.3 8.0 9.6;\n     1.5 3.6 1.6];\n\n&gt;&gt; min(a)\n\nans =\n    1.0000    2.0000    1.6000\n\n&gt;&gt; min(a,[],2)\n\nans =\n    1.0000\n    1.2000\n    1.3000\n    1.5000    \n\n\nЧтобы определить не только минимальное или максимальное значение в матрице, то и положение (индекс) минимального или максимального элемента, необходимо вызвать функцию min или max с двумя возвращаемыми значениями\n\n&gt;&gt; [min_values, min_index] = min(a)\n\nmin_values =\n\n    1.0000    2.0000    1.6000\n\n\nmin_index =\n\n     1     1     4\n\n\nВ этом случае min_values  будет содержать найденные минимальные значения в столбцах матрицы, а min_index – номера строк этих элементов.\n\nСреднее значение\n\nСреднее значение элементов в столбцах. Для матрицы \\(a\\) \\(m \\times n\\)\n\n[M_1(a) = \\sum_{i=1}^m a_{i,j} / m]\n\n&gt;&gt; mean(a)\n\nans =\n    1.2500    4.7000    5.0750\n\n\nСреднее значение элементов в строках\n\n[M_2(a) = \\sum_{j=1}^n a_{i,j} / n]\n\n&gt;&gt; mean(a,2)\n\nans =\n    2.0000\n    4.1667\n    6.3000\n    2.2333\n\n\nСтандартное отклонение\n\nДля вычисления несмещенной оценки стандартного отклонения элементов в столбцах используется функция std\n\n[\\sigma_1(a) = \\sqrt{\\sum_{i=1}^m (a_{i,j} - M_1)^2 / (m-1)}]\n\n&gt;&gt; std(a)\n\nans =\n    0.2082    2.5586    3.5547\n\n\nДля вычисления смещенной оценки\n\n[\\sigma_1(a) = \\sqrt{\\sum_{i=1}^m (a_{i,j} - M_1)^2 / m}]\n\nфункция std вызывается со вторым аргументом равным 1 (по умолчанию он равен 0)\n\n&gt;&gt; std(a,1)\n\nans =\n    0.1803    2.2159    3.0785\n\n\nТретий аргумент функции – номер размерности\n\n&gt;&gt; std(a,0,2)\n\nans =\n    1.0000\n    2.6083\n    4.4034\n    1.1846\n\n\nСортировка\n\nДля сортировки элементов матрицы в столбцах или строках используется функция  sort. Сортировка элементов в столбцах\n\n&gt;&gt; a = [1.0 2.0 3.0;\n        1.2 5.2 6.1;\n        1.3 8.0 9.6;\n        1.5 3.6 1.6];\n\n&gt;&gt; sort(a)\n\nans =\n    1.0000    2.0000    1.6000\n    1.2000    3.6000    3.0000\n    1.3000    5.2000    6.1000\n    1.5000    8.0000    9.6000\n\n\nи в строках\n\n&gt;&gt; sort(a,2)\n\nans =\n    1.0000    2.0000    3.0000\n    1.2000    5.2000    6.1000\n    1.3000    8.0000    9.6000\n    1.5000    1.6000    3.6000\n\n\nЧтобы узнать порядковые номера элементов из старого массива в новом необходимо вызвать функцию sort с двумя возвращаемыми значениями\n\n&gt;&gt; [sorted, index] = sort(a)\n\nsorted =\n    1.0000    2.0000    1.6000\n    1.2000    3.6000    3.0000\n    1.3000    5.2000    6.1000\n    1.5000    8.0000    9.6000\n\nindex =\n     1     1     4\n     2     4     1\n     3     2     2\n     4     3     3\n\n\nВ первую переменную sorted запишется отсортированная матрица, а во вторую index номера строк первой матрицы, в которых располагался соответствующий элемент столбца. Например, глядя на матрицу index, можно сказать, что после сортировки элементы в первом столбце остались на своих местах, четвертый элемент второго столбца переместился на вторую позицию, второй элемент – на третью и третий элемент (максимальный) на четвертую.\n\nЕсли необходимо отсортировать элементы столбцов в соответствии с сортировкой, например, третьего столбца необходимо сделать так:\n\n&gt;&gt; [sorted, index] = sort(a);\n&gt;&gt; a(index(:,3),:)\n\nans =\n    1.5000    3.6000    1.6000\n    1.0000    2.0000    3.0000\n    1.2000    5.2000    6.1000\n    1.3000    8.0000    9.6000\n\n\nПервым действием выполняем сортировку матрицы (независимо каждый столбец). Вторым действием выбираем из исходной матрицы строки в соответствии с новым положением элементов в третьем столбце: 4, 1, 2 и 3 строки.\n\n",
      "url": "/pages/matlab/functions/"
    },{
      
      "title": "Игра Жизнь",
      
      "content": "Главная\n\nОсновной файл-скрипт (main.m)\n\n% Начальное состояние колонии\ncells = [ 1, 1; \n          1, 2;\n          1, 3;\n          2, 1;\n          3, 2;          \n          10 10;\n          10 11;\n          10 12];\n\n% Координаты вершин квадрата, изображающего клетку \n% (относительно центра клетки)\nvert  = [-0.5,-0.5, 0.5,-0.5, 0.5,+0.5, -0.5,+0.5];\n\n% границы области\nxlim([-20,20]);\nylim([-20,20]);\n\n% количество поколений\nn_gen = 50;\n\n% Для каждого поколения\nfor i=1:n_gen    \n    % очистить изображение\n    cla;\n    % получить список клеток для следующего поколения\n    cells = next_generation(cells);\n    % сформировать список полигонов для функции patch \n    cells_vertices = repmat(cells,1,4)+repmat(vert,size(cells,1),1);\n    x = (cells_vertices(:,1:2:end))';\n    y = (cells_vertices(:,2:2:end))';    \n    % нарисовать клетки\n    patch(x,y,'r');\n    % включить сетку\n    grid on;\n    % включить рамку\n    box on;\n    % сохранить кадр\n    getframe;\n    % подождать 0.2 с\n    pause(0.2);\nend\n\n\nФайл-функция next_generation.m\n\nФункция next_generation возвращает следующее поколение для colony\n\nfunction next_gen = next_generation(colony)    \n    next_gen = [];\n    % Список клеток -- ареал колонии \n    area = get_colony_area(colony);\n    % Для каждой клетки из ареала\n    for i=1:size(area,1)\n        cell = area(i,:);\n        % Количество соседей у клетки i из ареала\n        n = count_cell_neighbours(cell, colony);\n        % Если 3 или (2 и клетка занята), \n        % то добавляем клетку в новое поколение\n        if n == 3 || (n == 2 &amp;&amp; cell_in_colony(cell, colony))\n            next_gen = [next_gen; cell];\n        end        \n    end\n\n\nФайл-функция get_colony_area.m\n\nФункция get_colony_area, возвращающая ареал колонии colony\n\n%\n% Список клеток, принадлежащих колонии и смежных с клетками колонии\n%\nfunction cells = get_colony_area(colony)\n    % результат -- это все клетки колонии\n    cells = colony;\n    % и клетки смежные с клетками колонии\n    for i=1:size(colony,1)\n        % список ближайших для клетки i\n        nearest = get_neighbours_cells( colony(i,:) );\n        cells = union(cells, nearest, 'rows');\n    end\n\n\nФайл-функция count_cell_neighbours.m\n\nФункция count_cell_neighbours определяет количество соседей у клетки cell в колонии colony\n\n%\n% Количество соседей у клетки с координатами cell = [x, y]\n%\nfunction count = count_cell_neighbours(cell, colony)    \n    % 8 ближайших клеток\n    neighbours = get_neighbours_cells(cell);                \n    count = sum(arrayfun(@(i) cell_in_colony(neighbours(i,:), colony), 1:size(neighbours,1)));\nend    \n\n\nФайл-функция get_neighbours_cells.m\n\nФункция get_neighbours_cells Координаты смежных (ближайших восьми) клеток для клетки  cell.\n\n%\n% Координаты ближайших (смежных) клеток для клетки cell = [x, y]\n%\nfunction neighbours = get_neighbours_cells(cell)\n    \n    neighbours = [-1 -1; 0 -1; 1 -1;\n                  -1  0;       1  0;\n                  -1  1; 0  1; 1  1];\n    \n    neighbours = repmat(cell,8,1) + neighbours;\n\n\nФайл-функция cell_in_colony.m\n\nФункция cell_in_colony определяет принадлежность клетки cell колонии colony. Для определения принадлежности клетки cell колонии colony, список пар координат colony рассматривается как множество пар координат и определяется пересечение этого множество с множеством, состоящем из одной пары координат – клетки cell. Если результатом будет пустое множество, то клетки cell в колонии нет.\n\n%\n% Принадлежит ли клетка cell колонии\n%\nfunction res = cell_in_colony(cell, colony)\n    % Пересечение множества colony с множеством cell\n    сс = intersect(cell,colony,'rows')\n    % Если результат это пустое множество, \n    % то слетки cell в колонии colony нет\n    res = ~isempty(сс);        \nend\n\n\nКороткая форма функции cell_in_colony\n\n%\n% Принадлежит ли клетка cell колонии\n%\nfunction res = cell_in_colony(cell, colony)   \n  res = ~isempty(intersect(cell,colony,'rows'));\nend\n\n",
      "url": "/pages/matlab/game_life/"
    },{
      
      "title": "Игра \"Жизнь\"",
      
      "content": "Разработать программу игры “Жизнь” на замкнутой поверхности (на торе) размером \\(N \\times M\\).\n\n\n  Начальная конфигурация колонии задается в текстовом файле в виде пар координат клеток или в виде матрицы.\n  В этом же файле (в начале файла) указывается размер поля (если колония задана парами координат).\n  Программа должна загружать начальное положение колонии из заданного пользователем текстового файла, задаваемого параметром командной строки\n  Программа должна показывать на экране в графическом виде развитие колонии на протяжении заданного числа поколений (параметр командной строки) или пока пользователь не остановит выполнение программы.\n  На экране должны отображатья номер поколения и количество клеток колонии.\n  Программа должна создавать файл с анимацией развития колонии на протяжении заданного числа поколений.\n  Цвет клеток, цвет поля (фон), цвет сетки должен задаваться в конфигурационном файле. При отсутвии файла эти цвета принимают значения по умолчанию.\n\n\nИспользуемые пакеты и модули: numpy, matplotlib\n\nСм. также: https://nickcharlton.net/posts/drawing-animating-shapes-matplotlib.html\n\nСписок заданий\n",
      "url": "/pages/python/course_works/game_life/"
    },{
      
      "title": "Игра Жизнь на SQL",
      "description": "Пример реализации алгоритма игры “Жизнь” на языке SQL.\n",
      "content": "Определения\n\nДано бесконечное поле, разделенное на ячейки. Ячейка может быть свободной или занятой  клеткой. Клетки на поле образуют колонию. У каждой ячейки есть восемь ближайших смежных (граничащих) ячеек, которые могут быть заняты другими клетками.\n\nКолония изменяется по следующим правилам:\n\n\n  Если у клетки заняты соседями две или три смежных ячейки, то клетка “выживает” и  переходит в следующее поколение, в противном случае она “умирает” от перенаселения или недостатка соседей.\n  Если рядом с пустой ячейкой находятся ровно три клетки, то на месте этой ячейки  появляется новая клетка.\n  В процессе смены поколения “умирающие” клетки считаются принадлежащими колонии до определения всех новых клеток и клеток, переходящих в следующее поколение. Также и рождающиеся считаются принадлежащими следующему поколению и не оказывают влияние на количество соседей клеток текущего поколения.\n\n\n\n\nТаблицы и представления\n\nКолония описывается множеством пар координат клеток. Таблица cells хранит координаты клеток колонии и номер поколения, которому они принадлежат:\n\nCREATE TABLE cells (\n    x BIGINT,\n    y BIGINT,\n    gen BIGINT,\nCONSTRAINT UQ_xy UNIQUE (x, y, gen)\n);\n\n\nПредставление (VIEW), которое возвращает координаты клеток последнего поколения из таблицы cells:\n\nCREATE VIEW LastGen AS \n    SELECT x,y,gen \n    FROM \n        cells \n    WHERE \n        gen = (SELECT max(gen) from cells);\n\n\nВспомогательная неизменяемая таблица относительных координат смежных ячеек:\n\nCREATE TABLE dxdy (\n    x BIGINT,\n    y BIGINT,\n    CONSTRAINT UQ_xy UNIQUE (x, y)\n);\n\n\nВ таблице dxdy восемь записей: у каждой ячейки восемь смежных ей ячеек, которые отличаются на единицу по любой координате:\n\nINSERT INTO dxdy (x,y) VALUES \n ( 1, 1),\n ( 0, 1),\n (-1, 1),\n (-1, 0),\n (-1,-1),\n ( 0,-1),\n ( 1,-1),\n ( 1, 0);\n\n\nПроцедура\n\nПроцедура, вычисляющая следующее поколение и добавляющая координаты клеток нового поколения в таблицу  cells.\n\nНа первом шаге определяется номер текущего поколения, который записывается в локальную переменную current_gen:\nDECLARE current_gen BIGINT DEFAULT 0;\nSELECT max(gen) from cells into current_gen;\n\n\nДалее используется синтаксис INSERT INTO … SELECT для формирования множества координат клеток нового поколения при помощи двух запросов SELECT, результаты которых объединяются оператором UNION.\n\nПервый SELECT выбирает из таблицы cells координаты клеток текущего поколения\n\nC1.gen=current_gen and C2.gen=current_gen\n\n\nи у которых смежные ячейки (C1.x+dxdy.x, C1.y+dxdy.y) заняты\n\nC2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y\n\n\nдвумя или тремя клетками из текущего поколения:\n\nHAVING COUNT(*)=3 OR COUNT(*)=2\n\n\nВторой SELECT выбирает координаты смежных ячеек колонии, у которых ровно три соседа. Смежные ячейки колонии – это множество незанятых смежных ячеек всех её клеток. Незанятые ячейки определяются при помощи левого соединения множества координат смежных ячеек (cells C1) с координатами клеток колонии (cells C2) при условии\n\n(C2.x IS NULL OR C2.y IS NULL) \n\n\nОбъявление процедуры:\n\nDELIMITER $$;\n\nCREATE PROCEDURE NextGen()  \nBEGIN\nDECLARE current_gen BIGINT DEFAULT 0;\nSELECT max(gen) from cells into current_gen;\nINSERT INTO cells (x,y,gen)\n\tSELECT \n\t\tC1.x,C1.y,current_gen+1\tas gn\n\tFROM \n\t\tLastGen C1\n\tJOIN dxdy\n\tJOIN LastGen C2 ON C2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y \n\tGROUP BY \n\t\tx,y,gn\n\tHAVING COUNT(*)=3 OR COUNT(*)=2\nUNION\n\tSELECT \n\t\tC1.x+dxdy.x as nearx,  \n\t\tC1.y+dxdy.y as neary,\n\t\tcurrent_gen+1 as gn\n\tFROM \n\t\tLastGen C1\n\tJOIN dxdy\n\tLEFT JOIN LastGen C2 ON C2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y AND (C2.x IS NULL OR C2.y IS NULL)\n\tGROUP BY \n\t\tnearx,neary,gn\n\tHAVING COUNT(*) = 3;\nEND $$\n\nDELIMITER ;\n\n\nПример\n\nКолония “Глайдер”, которая через 4 поколения смещает вниз и вправо на одну клетку:\n\nINSERT INTO cells (x,y,gen) VALUES \n\t( 1, 1, 1),\n\t( 2, 1, 1),\n\t( 3, 1, 1),\n\t( 3, 2, 1),\n    ( 2, 3, 1),\n\n\nПервое поколение:\n\n\n\nselect * from LastGen;\n\nx|y|gen|\n-|-|---|\n1|1|  1|\n2|1|  1|\n2|3|  1|\n3|1|  1|\n3|2|  1|\n\n\nСостояние колонии через четыре поколения:\n\nCALL NextGen();\nCALL NextGen();\nCALL NextGen();\nCALL NextGen();\n\nselect * from LastGen;\n\n\nselect * from LastGen;\n\nx|y|gen|\n-|-|---|\n2|0|  5|\n3|0|  5|\n3|2|  5|\n4|0|  5|\n4|1|  5|\n\n\n\n",
      "url": "/pages/databases/gamelife_sql/"
    },{
      
      "title": "Пример базы данных сети магазинов бытовой техники",
      
      "content": "База данных продавца бытовой техники содержит информацию о продаваемых товарах, их категориях, производителях, филиалах (магазинах), поставках товаров, изменений цен на товары, покупателях и покупках. База данных состоит из 7 таблиц:\n\n  clients (покупатели)\n  products (товары)\n  purchases (покупки)\n  purchase_item (элемент покупки)\n  deliveries (поставки)\n  price_change (изменения цены товаров)\n  categories (категории товара)\n  manufacturers (производители товара)\n\n\nСкачать базу данных SQLite\n\nТаблицы\n\nКатегории (categories)\n\nТаблица категорий (типов) товаров состоит из двух столбцов: столбца идентификатора категории и столбца наименования категории.\n\n\n  \n    \n      Идентификатор категории (PK)\n      Наименование категории\n    \n  \n  \n    \n      category_id\n      category_name\n    \n  \n\n\nПример содержимого таблицы:\n\ncategory_id|category_name         |\n-----------|----------------------|\n          1|Компьютерная техника  |\n          2|Офис и канцелярия     |\n          3|Мелкая бытовая техника|\n\n\nПроизводители товара (manufacturers)\n\nВ таблице содержится информация об идентификаторе производителя товара и его наименовании.\n\n\n  \n    \n      Идентификатор производителя (PK)\n      Наименование производителя\n    \n  \n  \n    \n      manufacturer_id\n      manufacturer_name\n    \n  \n\n\nПример содержимого таблицы:\n\nmanufacturer_id|manufacturer_name|\n---------------|-----------------|\n              1|Calve            |\n              2|TESCOMA          |\n              3|Haier            |\n              4|Nescafe          |\n              5|Be quiet         |\n\n\nТовары (products)\n\nВ таблице содержатся идентификатор товара, его наименование, ссылка на идентификатор поставщика (внешний ключ), ссылка на идентификатор категории (внешний ключ), к которой относится товар.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Наименование товара\n      Идентификатор поставщика (FK)\n      Идентификатор категории (FK)\n    \n  \n  \n    \n      product_id\n      product_name\n      manufacturer_id\n      category_id\n    \n  \n\n\nПример содержимого таблицы\n\nproduct_id|product_name                         |manufacturer_id|category_id|\n----------|-------------------------------------|---------------|-----------|\n         1|Кухонный комбайн KitchenAid 5KSM156  |             71|          3|\n         2|Видеокарта Asus GeForce GT 1030      |             29|          1|\n         3|Ноутбук HP ENVY 13-ad000             |            486|          1|\n         4|Фен Dewal 03-401                     |            124|          3|\n         5|Кофеварка Gastrorag CM-717           |            225|          3|\n\n\nИзменения цен на товары (price_change)\n\nЦены на товары могут изменяться. Для учета изменения цен на товары используется таблица price_change. В таблице содержатся ссылка на товар (внешний ключ), дата изменения цены товара и новая цена. Таким образом, для того, чтобы узнать цену товара на заданную дату необходимо найти ближайшую дату (в прошлом) изменения его цены.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Дата изменения цены\n      Новая цена\n    \n  \n  \n    \n      product_id\n      date_price_change\n      new_price\n    \n  \n\n\nВ базе SQLite Дата изменения цены хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года. В базе данных MySQL/MariaDB используется тип DATE.\n\nПример содержимого таблицы в базе SQLite:\n\nproduct_id|date_price_change|new_price|\n----------|-----------------|---------|\n         1|1546300800       |    58399|\n         2|1546300800       |   5717.8|\n         3|1546300800       |    54890|\n         4|1546300800       |   2632.3|\n         5|1546300800       |  32854.8|\n\n\nФилиалы (stores)\n\nВ таблице содержаться идентификаторы филиалов и их наименования.\n\n\n  \n    \n      Идентификатор филиала (PK)\n      Наименование филиала\n    \n  \n  \n    \n      store_id\n      store_name\n    \n  \n\n\nПример:\n\nstore_id|store_name|\n--------|----------|\n       1|Филиал №1 |\n       2|Филиал №2 |\n       3|Филиал №3 |\n       4|Филиал №4 |\n\n\nПоставки (deliveries)\n\nВ таблице содержатся идентификаторы поставленных товаров, филиал, куда бы поставлен товар, дата поставки и количество товара поставленного товара.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Идентификатор филиала\n      Дата поставки\n      Количество товара\n    \n  \n  \n    \n      product_id\n      store_id\n      delivery_date\n      product_count\n    \n  \n\n\nВ базе SQLite дата поставки товара хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года.\n\nПример содержимого таблицы в SQLite:\n\nproduct_id|store_id|delivery_date|product_count|\n----------|--------|-------------|-------------|\n         0|       0|   1546300800|            5|\n         0|       0|   1556125138|            9|\n         1|       0|   1546300800|            5|\n         1|       0|   1575852670|            9|\n         2|       3|   1546300800|            5|\n\n\nКлиенты (customers)\n\nТаблица содержит идентификаторы и имена клиентов (покупателей).\n\n\n  \n    \n      Идентификатор клиента (PK)\n      Фамилия\n      Имя\n    \n  \n  \n    \n      customer_id\n      customer_lname\n      customer_lname\n    \n  \n\n\nПример содержимого таблицы:\n\ncustomer_id|customer_fname                 |customer_lname                 |\n-----------|------------------------------|------------------------------|\n          1|Митофан Демидович    | Дорофеев |\n          2|Софрон         | Панов \n          3|Демьян | Мартынов \n          4|Гостомысл      | Белоусов\n\n\nДля упрощения имя отчество и фамилия клиента (покупателя) хранится в одном столбце.\n\nПокупки (purchases)\n\nТаблицу покупок можно представить как таблицу счетов на оплату товаров, покупаемых в рамках одной покупки (покупка характеризуется уникальным сочетанием: дата, покупатель, филиал). Таблица содержит идентификатор покупки, идентификатор покупателя, совершившего покупку, идентификатор филиала, где была совершена покупка, и дату покупки.\n\n\n  \n    \n      Идентификатор покупки\n      Идентификатор покупателя\n      Идентификатор филиала\n      Дата покупки\n    \n  \n  \n    \n      purchase_id\n      customer_id\n      store_id\n      purchase_date\n    \n  \n\n\nВ базе SQLite дата покупки хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года.\n\nПример содержимого таблицы:\n\npurchase_id|customer_id|store_id|purchase_date|\n-----------|-----------|--------|-------------|\n          1|          5|       3|   1562533957|\n          2|          8|       2|   1550822768|\n          3|         10|       1|   1573857286|\n          4|          7|       2|   1561828953|\n          5|          9|       3|   1573889112|\n\n\nЗапись в счете (purchase_item)\n\nТаблица содержит информацию о товарах, купленных в рамках одной покупки (товары в счете на оплату). Для упрощения анализа информации о покупках в таблицу введено поле цена продукта, которое заполняется автоматически на основе цены товара на момент покупки.\n\n\n  \n    \n      Идентификатор покупки\n      Идентификатор товара\n      Количество товара\n      Цена товара\n    \n  \n  \n    \n      purchase_id\n      product_id\n      product_count\n      product_price\n    \n  \n\n\nПример содержимого таблицы:\n\npurchase_id|product_id|product_count|product_price|\n-----------|----------|-------------|-------------|\n          1|        26|            1|        27929|\n          1|         8|            1|      20879.1|\n          2|         9|            1|         4939|\n          2|        36|            1|        33000|\n          3|        41|            1|       6356.9|\n\n\nСхема связи таблиц базы данных\n\n\n\nSQL-сценарии для создания таблиц\n\nSQL-сценарий для БД MySQL/MariaDB.\n\n\nDROP TABLE IF EXISTS purchase_items;\nDROP TABLE IF EXISTS purchases;\nDROP TABLE IF EXISTS price_change;\nDROP TABLE IF EXISTS deliveries;\nDROP TABLE IF EXISTS products;\nDROP TABLE IF EXISTS manufacturers;\nDROP TABLE IF EXISTS categories;\nDROP TABLE IF EXISTS stores;\nDROP TABLE IF EXISTS customers;\n\nCREATE TABLE categories \n(\n    category_id SERIAL PRIMARY KEY, \n    category_name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE manufacturers\n(\n    manufacturer_id SERIAL PRIMARY KEY, \n    manufacturer_name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE products\n(\n    product_id SERIAL PRIMARY KEY,\n    product_name VARCHAR(255)  NOT NULL,\n    manufacturer_id BIGINT UNSIGNED,    \n    category_id BIGINT UNSIGNED,\n    FOREIGN KEY (category_id) REFERENCES categories (category_id),\n    FOREIGN KEY (manufacturer_id) REFERENCES manufacturers (manufacturer_id)\n);\n\nCREATE TABLE price_change\n(\n    product_id BIGINT UNSIGNED NOT NULL,\n    date_price_change DATE NOT NULL,\n    new_price NUMERIC(9,2) NOT NULL,      \n    CONSTRAINT PK_PRICE_CHANGE PRIMARY KEY (product_id, date_price_change),  \n    FOREIGN KEY (product_id) REFERENCES products (product_id)   \n);\n\nCREATE TABLE stores\n(\n    store_id SERIAL PRIMARY KEY,\n    store_name VARCHAR(255) NOT NULL\n);\n\nCREATE TABLE deliveries\n(    \n    product_id BIGINT UNSIGNED NOT NULL,\n    store_id BIGINT UNSIGNED,\n    delivery_date  DATE NOT NULL,\n    product_count  INTEGER UNSIGNED NOT NULL,    \n    FOREIGN KEY (product_id) REFERENCES products (product_id),\n    FOREIGN KEY (store_id) REFERENCES stores (store_id)\n);\n\n\nCREATE TABLE customers\n(\n    customer_id SERIAL PRIMARY KEY,\n    customer_fname VARCHAR(100) NOT NULL,\n    customer_lname VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE purchases\n(\n    purchase_id SERIAL PRIMARY KEY,\n    customer_id BIGINT UNSIGNED NOT NULL,\n    store_id BIGINT UNSIGNED NOT NULL,    \n    purchase_date DATETIME NOT NULL,\n    FOREIGN KEY (customer_id) REFERENCES customers (customer_id),\n    FOREIGN KEY (store_id) REFERENCES stores (store_id)\n);\n\nCREATE TABLE purchase_items\n(\n    purchase_id BIGINT UNSIGNED NOT NULL,\n    product_id BIGINT UNSIGNED NOT NULL,\n    product_count BIGINT UNSIGNED NOT NULL,\n    product_price NUMERIC(9,2) NOT NULL,\n    CONSTRAINT PK_PURCHASE_ITEMS PRIMARY KEY (purchase_id, product_id),  \n    FOREIGN KEY (product_id) REFERENCES products (product_id),\n    FOREIGN KEY (purchase_id) REFERENCES purchases (purchase_id)\n);\n\n\n\nSQL-сценарий для БД SQLite.\n\n\nDROP TABLE IF EXISTS categories;\nDROP TABLE IF EXISTS manufacturers;\nDROP TABLE IF EXISTS products;\nDROP TABLE IF EXISTS price_change;\nDROP TABLE IF EXISTS stores;\nDROP TABLE IF EXISTS deliveries;\nDROP TABLE IF EXISTS customers;\nDROP TABLE IF EXISTS purchases;\nDROP TABLE IF EXISTS purchase_items;\n\nCREATE TABLE IF NOT EXISTS categories \n(\n    category_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, \n    category_name text  NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS manufacturers\n(\n    manufacturer_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    manufacturer_name TEXT NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS products\n(\n    product_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    product_name text  NOT NULL,\n    manufacturer_id INTEGER  NOT NULL,    \n    category_id INTEGER NOT NULL,\n    FOREIGN KEY ([category_id]) REFERENCES \"categories\" ([category_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([manufacturer_id]) REFERENCES \"manufacturers\" ([manufacturer_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE IF NOT EXISTS price_change\n(\n    product_id INTEGER NOT NULL,\n    date_price_change integer NOT NULL,\n    new_price REAL NOT NULL,      \n    CONSTRAINT PK_PRICE_CHANGE PRIMARY KEY (product_id, date_price_change),  \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION   \n);\n\nCREATE TABLE IF NOT EXISTS stores\n(\n    store_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    store_name text  NOT NULL\n);\n\n\nCREATE TABLE IF NOT EXISTS deliveries\n(    \n    product_id  INTEGER NOT NULL,\n    store_id INTEGER NOT NULL,\n    delivery_date  INTEGER NOT NULL,\n    product_count  INTEGER NOT NULL,    \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([store_id]) REFERENCES \"stores\" ([store_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\n\nCREATE TABLE IF NOT EXISTS customers\n(\n    customer_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    customer_name text  NOT NULL\n);\n\n\nCREATE TABLE IF NOT EXISTS purchases\n(\n    purchase_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    customer_id INTEGER NOT NULL,\n    store_id INTEGER  NOT NULL,    \n    purchase_date INTEGER NOT NULL,\n    FOREIGN KEY ([customer_id]) REFERENCES \"customers\" ([customer_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([store_id]) REFERENCES \"stores\" ([store_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE IF NOT EXISTS purchase_items\n(\n    purchase_id INTEGER NOT NULL,\n    product_id INTEGER NOT NULL,\n    product_count INTEGER NOT NULL,\n    product_price REAL NOT NULL,\n    CONSTRAINT PK_PURCHASE_ITEMS PRIMARY KEY (purchase_id, product_id),  \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([purchase_id]) REFERENCES \"purchases\" ([purchase_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\n\n",
      "url": "/pages/databases/goods/"
    },{
      
      "title": "Кратчайший путь",
      
      "content": "\n  \n    Дорожная сеть описывается графом. Вершины графа – населенные пункты, дуги – дороги, сединяющие населенные пункты. Для каждой дуги графа задан её вес (целое положительное число) или путь между двумя вершинами (городами), которые соединяет дуга (дорога). Написать программу поиска кратчайшего пути из вершины \\(i\\) графа к вершине \\(j\\).\n  \n  \n    Исходные данные о сети дорог должны загружаться из текстового файла, в котором должно содержаться не менее 20 населенных пунктов.\n  \n\n\n\n# Пункты\n1 Москва\n2 Самара\n3 Уфа\n...\n\n# Дороги\n1-2 1000\n1-3 458\n...\n\n\n\n\n  Начальная и конечная точки маршрута должны задаваться в диалоговом режиме\n\n\n~~\nВведите пункт отправления: Самара\nВведите пункт назначения: Владивосток \n~~\n\n\n  Результат должен выводится на экран\n\n\nСамара-Уфа-...Владивосток : **** км.\n\n",
      "url": "/pages/python/course_works/graph/"
    },{
      
      "title": "Графики",
      
      "content": "\n  Основы графики    \n      Функция, заданная выражением\n      Табличная функция\n      Несколько графиков на одном рисунке\n      Столбчатые диаграммы\n      Круговые диаграммы\n    \n  \n\n\nОсновы графики\n\nФункция, заданная выражением\n\nДля построения графика функции, заданной выражением в m-файле\n\n% Файл-функция f.m\nfunction res = f(x)\n    res = sin(10*x)+2*x;\n\n\nили при помощи анонимной функции\n\nf = @(x) sin(10*x)+2*x;\n\n\nиспользуется функция fplot\n\nfplot(f,[0 5]);\nxlabel('x, c');\nylabel('f, м');\ngrid on;\ntitle('График зависимости f от x');\n\n\n\n\nТабличная функция\n\nДля построения графиков табличных функций используется функция plot.\n\nx = 0:0.05:5;\ny = sin(10*x)+2*x;\n\n\nТретьим аргументом функции plot можно передать строковую константу, описывающую свойства графика: цвет, тип маркера и тип линии:\n\nplot(x,y,'r--');\nplot(x,y,'k-.','LineWidth',2);\n% размер шрифта и толщина линий  шкал\nset(gca,'FontSize',14,'LineWidth',1.5);\n% подписи осей с указанием размеров шрифтов\nxlabel('x, c','FontSize',14);\nylabel('y, м','FontSize',14);\ngrid on;\n\n\nНекоторые коды цветов, маркеров и типов линий приведены в таблице\n\n\n  \n    \n      Код цвета\n      Цвет\n      Код  маркера\n      Тип маркера\n      Код  линии\n      Тип линии\n    \n  \n  \n    \n      r\n      красный\n      о\n      кружок\n      -\n      сплошная\n    \n    \n      g\n      зеленый\n      .\n      точка\n      –\n      пунктирная\n    \n    \n      b\n      голубой\n      s\n      квадрат\n      -.\n      штрих-пунктирная\n    \n    \n      y\n      желтый\n      *\n      звездочка\n      :\n      пунктирная\n    \n    \n      k\n      черный\n      ^\n      треугольник\n       \n       \n    \n  \n\n\nДля создания рисунка определенного размера можно использовать функцию figure с параметром position, который позволяет задать положение нижней левой точки окна рисунка и его ширину и высоту\n\nx0 = 10; y0 = 10;\nwidth = 500; height = 300;\nfigure('position',[x0, y0, width, height]);\nx = 0:0.5:5;\ny = sin(x);\nplot(x,y);\n\n\nРазмер рисунка можно изменить после его построения, задав свойство position при помощи функции изменения свойств текущего рисунка set(gcf, ….)\n\nx = 0:0.5:5;\ny = sin(x);\nplot(x,y);\n\nx0 = 10; y0 = 10;\nwidth = 500; height = 300;\nset(gcf,'Position',[x0, y0, width, height]);\n\n\ngcf это глобальная переменная-ссылка на выбранный объект figure.\n\nНесколько графиков на одном рисунке\n\nПо умолчанию при нескольких вызовах функции plot на графике будет показана только последняя кривая, поскольку вызов функции plot удаляет предыдущий график. Чтобы изменить это поведение и показать на одном графике несколько кривых, необходимо использовать директиву hold on.\n\nx  = 0:0.1:10;\ny1 = sin(x);\ny2 = cos(x);\n\nplot(x, y1 , 'r-');\n% \"Удерживаем\" предыдущий график\nhold on;\n% строим еще одну кривую (синим пунктиром)\nplot(x, y2, 'b--');\n% Выключаем \"удержание\" \nhold off;\n\n\n\n\n\nНа одном рисунке можно показать несколько графиков мозаикой. Для этого используется функция subplot. Предположим, что необходимо построить 4 графика.\n\nРазбиваем рисунок на 4 ячейки 2x2 и строим график в первой ячейке (1,1)\n\nsubplot(2,2,1);\nx  = linspace(0,2*pi,50); y1 = sin(x);\nplot(x, y1,'r-','LineWidth',2)\n\n\nДвигаемся справа налево, сверху вниз: первые два аргумента – число строк и столбцов, на которое разбит рисунок, третий аргумент – номер ячейки в котором будет строиться следующий график. Порядок нумерации ячеек не такой как у матрицы, а слева-направо и сверху-вниз.\n\nsubplot(2,2,2);\ny2 = cos(x);\nplot(x, y2,'g-','LineWidth',2);\n\n\nАналогично для оставшихся графиков во второй строке рисунка\n\nsubplot(2,2,3);\ny3 = exp(x);\nplot(x, y3,'b-','LineWidth',2);\n\nsubplot(2,2,4);\ny4 = x.^2+2*x;\nplot(x, y3,'y-','LineWidth',2);\n\n\n\n\nСтолбчатые диаграммы\n\nx = 0:0.5:5;\ny = sin(x);\nbar(x,y)\n\n\n\n\nКруговые диаграммы\n\nx = [1, 2, 3, 4];\npie (x);\n\n\n\n\nВторой аргумент – логический массив, указывающий на необходимость изображения соответствующего сектора отдельно от круговой диаграммы.\n\nx = [1, 2, 3, 4];\ny = [0, 0, 1, 0];\npie (x);\n\n\nЕсли сумма элементов массива данных больше или равна единице, то эта сумма принимается за 100%, в противном случае строится диаграмма с пропущенным сектором.\n\nx = [0.1 , 0.2 , 0.5];\npie(x);\n\n\n\n\n",
      "url": "/pages/matlab/graphics/"
    },{
      
      "title": "Импорт и экспорт данных",
      
      "content": "Импорт данных\n\nПусть в текущем рабочем каталоге MATLAB находится текстовый файл mat1.txt со следующим содержанием\n\n1 2 3\n4 5 6\n7 8 9\n10 11 12\n\n\nФункция dlmread\n\nФункция dlmread (чтение из текстовых файлов) предназначена для чтения матриц из текстовых файлов. Первый аргумент функции – имя файла. Результат записывается в матрицу.\n\n&gt;&gt; a = dlmread('mat1.txt')\n\na =\n     1     2     3\n     4     5     6\n     7     8     9\n    10    11    12\n\n\nВторым аргументом можно явно указать разделитель чисел в файле, например ‘,’\n\n&gt;&gt; b = dlmread('mat2.txt',',');\n\n\nЧтобы узнать размер прочитанной матрицы по каждому измерению используется функция size, которая возвращает массив двух значений: количество прочитанных строк и столбцов:\n\n&gt;&gt; size(b)\n\nans =\n     3     2\n\n\nЧтобы узнать общее число прочитанных чисел можно перемножив размеры матрицы, используя функцию prod\n\n&gt;&gt; prod(size(b))\n\nans =\n     6\n\n\nили использовать функцию numel (количество всех элементов)\n\n&gt;&gt; numel(b)\n\nans =\n     6\n\n\nТретий и четвертый аргумент dlmread смещение строки и столбца, начиная с которых нужно начинать считывать данные из файла. Например, чтобы пропустить 1 строку и один столбец, необходимо вызвать функцию со следующими дополнительными параметрами\n\n&gt;&gt; b = dlmread('mat2.txt',',', 1, 1)\n\nb =\n     5     6\n     8     9\n    11    12\n\n\nЧтение данных из Excel файлов\n\nДля чтение данных из XLS файлов используется функция xlsread\n\n&gt;&gt; xlsNum = xlsread('Данные.xlsx');\n&gt;&gt; xlsNum \n\nb =\n     5     6\n     8     9\n    11    12\n\n\n### Функция readtable\n\nФункция позволяет импортировать таблицы из файлов различных форматов. В отличие от результата работы функции xlsread результатом работы функции readtable является объект table, который содержит дополнительную информацию о таблице: об именах столбцов, строк. Без дополнительных указаний функция readtable считает, что в первой строке таблицы записаны имена её столбцов.\n\nВ рабочем каталоге MATLAB находится xls-файл следующего на листе “Лист1” которого находятся следующие данные:\n\n\n\nРезультатом работы функции readtable будет таблица (объект table)\n\n&gt;&gt; data = readtable('Книга1.xlsx')\n\ndata =\n  \n  3×3 table\n\n     Var1     COL1    COL2\n    ______    ____    ____\n\n    'ROW1'    1.5      2  \n    'ROW2'    1.6      3  \n    'ROW3'    1.9      4  \n\n\nПервая строка в первом столбце таблицы не содержит никаких значений (ячейка А1 пустая), поэтому первому столбцу было присвоено имя автоматически Var1. Второй и третий столбцы в таблице имеют имена COL1 и COL2 соответственно. Функция readtable рассматривает эти значения как имена столбцов. Если такое поведение функции readtable нежелательно, то можно передать функции значение ‘ReadVariableNames’ равное false\n\n&gt;&gt; data = readtable('Книга1.xlsx', 'ReadVariableNames', false)\n\ndata =\n  4×3 table\n     Var1      Var2      Var3 \n    ______    ______    ______\n\n    ''        'COL1'    'COL2'\n    'ROW1'    '1.5'     '2'   \n    'ROW2'    '1.6'     '3'   \n    'ROW3'    '1.9'     '4'  \n\n\nВидно, что в этом случае, поскольку столбцы исходной таблицы в таком представлении содержат неоднородные данные (и числа и строки), все значения в столбцах рассматриваются как строковые без попыток их преобразования в числовые значения. Для корректного чтения данных из таблицы ‘Книга1.xlsx’ необходимо использовать поведение функции readtable  по умолчанию, т.е.\n\n&gt;&gt; data = readtable('Книга1.xlsx')\n\ndata =\n  \n  3×3 table\n\n     Var1     COL1    COL2\n    ______    ____    ____\n\n    'ROW1'    1.5      2  \n    'ROW2'    1.6      3  \n    'ROW3'    1.9      4  \n\n\nВ этом случае можно получить содержимое столбца, используя его имя. Например data.COL1 представляет собой матрицу столбец\n\n&gt;&gt; data.COL1\n\nans =\n    1.5000\n    1.6000\n    1.9000\n\n\nСтолбец data.Var1 это матрица ячеек, содержащая строковые значения\n\n&gt;&gt; data.Var1\n\nans =\n  3×1 cell array\n    {'ROW1'}\n    {'ROW2'}\n    {'ROW3'}\n\n\nСписок имен столбцов содержится в атрибуте (свойстве) таблицы data.VariableNames, которое считывается следующим образом\n\n&gt;&gt; data.Properties.VariableNames\n\nans =\n  1×3 cell array\n    {'Var1'}    {'COL1'}    {'COL2'}\n\n\nДля того, чтобы значения в первом столбце рассматривались как имена строк, необходимо использовать опцию ReadRowNames\n\n&gt;&gt; data = readtable('Книга1.xlsx','ReadRowNames',true)\n\ndata =\n  3×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n    ROW2    1.6      3  \n    ROW3    1.9      4  \n\n\nДля чтения извлечения данных из строки по её имени используется следующий синтаксис\n\n&gt;&gt; data('ROW1',:)\n\nans =\n  1×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n\n\nРезультатом является объект типа table. Можно извлечь несколько строк по их именам, например так\n\n&gt;&gt; data({'ROW1', 'ROW2'},:)\n\nans =\n  2×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n    ROW2    1.6      3  \n\n\nЧтобы извлечь данные в виде матрицы необходимо использовать свойство таблицы Variables\n\n&gt;&gt; data('ROW1',:).Variables\n\nans =\n    1.5000    2.0000\n\n\nДля исходной таблицы это свойство вернет все числовые значения в виде матрицы\n\n&gt;&gt; data.Variables\n\nans =\n    1.5000    2.0000\n    1.6000    3.0000\n    1.9000    4.0000\n\n\nЭкспорт данных\n\nСохранение таблицы в файле ‘data.txt’\n\nwritetable(data,'data.txt')\n\n\nСохранение в файле имён строк\n\nwritetable(data,'data.txt','WriteRowNames',true)\n\n\n",
      "url": "/pages/matlab/import/"
    },{
      
      "title": "Управление IT-сервисом и контентом",
      
      "content": "Презентации\n\n\n  Управление ИТ-сервисом и контентом. Введение\n  ИТ-служба, ИТ-инфраструктура и ИТ-сервис\n  Service Desk\n  Управление инцидентами, проблемами и ошибками\n  Управление конфигурациями и изменениями\n  Системы управления контентом\n  Основы информационной безопасности\n\n\nЛабораторные работы\n\n\n  Лабораторная работа №1\n  Лабораторная работа №2\n  Лабораторная работа №3\n  Лабораторная работа №4\n  Лабораторная работа №5\n\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/"
    },{
      
      "title": "Основы Wolfram Mathematica",
      
      "content": "Лабораторные работы\n\n\n  Списки\n  Движение системы материальных точек\n  Символьные вычисления\n  Уравнения Лагранжа\n  Анимация\n  Численные методы\n\n\nПо каждой лабораторной работе оформляется отчёт в соответствии с шаблоном.\n\nПримеры\n\n\n  Построение модели движения системы точек, связанных пружинами\n  Вывод и интегрирование уравнений движения двойного физического маятника (уравнения Лагранжа)\n  Вывод уравнений движения системы с двумя степенями свободы (курсовая работа по теоретической механике)\n  Анимация. Построение анимации.\n  Относительное орбитальное движение. Уравнения относительного орбитального движения двух космических аппаратов при движении одного из них (ведущий) по круговой орбите.\n  Преобразование поворота. Поворот в пространстве. Матрица поворота. Пример в Wolfram Mathematica.\n\n",
      "url": "/pages/wolfram/"
    },{
      
      "title": "Базы данных",
      
      "content": "Лекции\n\n\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 6. Основы SQL. Манипулирование данными.\n  Лекция 7. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 8. Основы NoSQL.\n\n\nЛабораторные работы\n\nЗадания для лабораторных работ\n\n\n  Модель Сущность-Связь\n  Создание таблиц\n  Запись данных в БД\n  SQL-запросы\n  Триггеры\n  Процедуры\n  Основы работы в MongoDB\n\n\nОтчеты по лабораторным работам\n\nОтчет по каждой лабораторной работе оформляется в соответствии с требованиями к учебным документам. Пример отчета по лабораторной работе №1 с примером в формате DOCX, в формате PDF.\n\nПрограммное обеспечение\n\nДля выполнения лабораторных работ рекомендую использовать следующее программное обеспечение и сервисы:\n\n\n  draw.io для создания ER-диаграмм;\n  DBeaver для работы с БД MySQL, SQLite\n\n\nПримеры кода\n\n\n  Подключение из Google Colab к базе данных SQLite, расположенной на Google диске.\n  Подключение к базе данных MySQL.\n  Игра “Жизнь” на SQL.\n  Пример построения сложного запроса к базе данных.\n  Подключение к БД SQLite в Google Colab.\n\n\n",
      "url": "/pages/databases/"
    },{
      
      
      
      "content": "\n  Дисциплины\n  Статьи\n  Патенты\n  Презентации\n  Видео\n\n\n",
      "url": "/pages/"
    },{
      
      
      
      "content": "\n",
      "url": "/"
    },{
      
      "title": "Обращение к элементам матрицы",
      
      "content": "Пусть задана матрица 4x3:\n\na = [1 2 3;\n     4 5 6;\n     7 8 9;\n     10 1 12];\n\n\nЭлемент во второй строке, третьем столбце\n\n&gt;&gt; a(3,2)\n\nans =\n     8\n\n\nВесь второй столбец (оператор :)\n\n&gt;&gt; a(:,2)\n\nans =\n     2\n     5\n     8\n     1\n\n\nВся третья строка\n\n&gt;&gt; a(3,:)\n\nans =\n     7     8     9\n\n\nК элементу прямоугольной матрицы можно обратиться при помощи одного индекса\n\n&gt;&gt; a(6)\n\nans =\n     5\n\n\nВ этом случае используется сквозная нумерация элементов в столбцах.\n\nБлок матрицы\n\n&gt;&gt; a(2:3,1:2)\n\nans =\n     4     5\n     7     8\n\n\nСтроки 2 и 4, столбцы 1 и 4\n\n&gt;&gt; a([2,4],[1,3])\n\nans =\n     4     6\n    10    12\n\n\nВсе элементы матрицы одним столбцом (столбцы склеиваются друг за другом)\n\n&gt;&gt; a(:)\n\nans =\n     1\n     4\n     7\n    10\n     2\n     5\n     8\n     1\n     3\n     6\n     9\n    12\n\n\nЗаменить все элементы в 3 строке нулями\n\n&gt;&gt; a(3,:) = 0\n\na =\n     1     2     3\n     4     5     6\n     0     0     0\n    10     1    12\n\n\nЛогическое индексирование\n\nСоздадим последовательность\n\n&gt;&gt; a = 1:10\n\na =\n     1     2     3     4     5     6     7     8     9    10\n\n\nРезультатом сравнения массива a с некоторым числом является логический массив единиц и нулей той же размерности, что и исходный массив, элементы которого заменяются на 1 (ИСТИНА) или 0 (ЛОЖЬ) в зависимости от результата сравнения этого элемента со сравниваемым значение (в примере ниже это число 3):\n\n&gt;&gt; a &gt; 3\n\nans =\n  1×10 logical array  \n   0   0   0   1   1   1   1   1   1   1\n\n\nМеньше или равно 3\n\n&gt;&gt; a &lt;= 3\n\nans =\n  1×10 logical array\n   1   1   1   0   0   0   0   0   0   0\n\n\nЛогическое индексирование можно использовать для выборки значений из матрицы, например, чтобы извлечь из  матрицы a все значения, которые меньше 3 и больше 8 можно написать так\n\n&gt;&gt; a(a &lt; 3 | a &gt; 8)\n\nans =\n     1     2     9    10\n\n",
      "url": "/pages/matlab/indexing/"
    },{
      
      "title": "Задание 3.",
      "description": "Динамика твёрдого тела и систем тел\n",
      "content": "Система твердых тел состоит из трех или четырех тел. Каждое тело представляет собой  однородный цилиндр известных размеров.\n\n\n  \n    Найти положение центра масс относительно системы координат, расположенной на пересечении продольной оси первого тела с плоскостью нижнего среза первого тела (точка А).\n  \n  \n    Определить главный центральный тензор инерции представленной системы тел. Определить ориентацию осей главной центральной системы координат по отношению к базовой системе координат \\(Axyz\\), представленной на рисунке: найти матрицу преобразования координат из главного центрального базиса в базис \\(Axyz\\).\n  \n\n\n\n\nВарианты\n\n\n  \n    \n      Вариант\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n    \n  \n  \n    \n      \\(m_1\\)\n      5000\n      6000\n      6000\n      7000\n      8000\n      8500\n      9000\n      9000\n      9000\n      9000\n      9000\n    \n    \n      \\(m_2\\)\n      1000\n      1000\n      1000\n      1000\n      1000\n      1000\n      1000\n      300\n      300\n      500\n      500\n    \n    \n      \\(m_3\\)\n      500\n      700\n      900\n      1000\n      2000\n      3000\n      4000\n      1000\n      1000\n      1000\n      1000\n    \n    \n      \\(m_4\\)\n      100\n      200\n      200\n      400\n      -\n      -\n      -\n      100\n      200\n      200\n      400\n    \n    \n      \\(L_1\\)\n      5\n      6\n      7\n      5\n      6\n      7\n      8\n      7\n      5\n      6\n      7\n    \n    \n      \\(L_2\\)\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      0.5\n      0.5\n      0.5\n      0.5\n    \n    \n      \\(L_3\\)\n      1\n      1,5\n      1,5\n      2\n      1\n      1\n      1\n      2\n      1\n      1\n      1\n    \n    \n      \\(L_4\\)\n      1\n      1\n      2\n      2\n      -\n      -\n      -\n      2\n      1\n      1\n      1\n    \n    \n      \\(D_1\\)\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n    \n    \n      \\(D_2\\)\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n    \n    \n      \\(D_3\\)\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n    \n    \n      \\(D_4\\)\n      1\n      1\n      1\n      1\n      -\n      -\n      -\n      0,9\n      0,9\n      0,9\n      0,9\n    \n    \n      \\(d_3\\)\n      0,5\n      0,6\n      0,5\n      0,6\n      0,2\n      0,3\n      0,3\n      0,2\n      0,3\n      0,3\n      0,2\n    \n    \n      \\(d_4\\)\n      0,3\n      0,2\n      0,1\n      0,1\n      -\n      -\n      -\n      0,5\n      0,5\n      0,5\n      0,5\n    \n    \n      Рисунок\n      2\n      2\n      3\n      3\n      1\n      1\n      1\n      2\n      2\n      3\n      3\n    \n  \n\n\nРазмерности величин в таблице в системе СИ.\n",
      "url": "/pages/mbs/inertia/"
    },{
      
      "title": "Лабораторная работа №5",
      
      "content": "Задание\n\n\n  Создать открытый и закрытий ключ, используя ПО GPG и Kleopatra\n  Экспортировать открытый ключ в файл и отправить его в CДО moodle, как отчет по лабораторной работе (прикрепить файл с ключом)\n  Импортировать открытый ключ преподавателя дисциплины и подписать его своим ключом (для себя)\n  Расшифровать полученный от преподавателя файл. Проверить электронную продпись преподавателя.\n  Пин-код, содержащийся в полученном файле, записать в документ MS.Word, зашифровать документ открытым ключом преподавателя и прикрепить зашифрованный файл вторым файлом отчета по лабораторной работе.\n\n\nМетодические рекомендации\n\n\n  Установка GPG4Win\n\n",
      "url": "/pages/it/lab-infosec/"
    },{
      
      "title": "ИТ-инфраструктура предприятия",
      
      "content": "Разработать ИТ-инфраструктуру малого предприятия. Организационная диаграмма предприяти представлена на рисунке 1 (в схему можно уточнять и дополнять при необходимости). При разработке ИТ-инфраструктуры необходимо уточнить специфику рассматриваемого предприятия (виды деятельности).\n\nОцените затраты на инфраструктуру:\n\n  cтоимость приобретённого оборудования (персональные компьютеры, оргтехника, сервер, материалы для локальной сети, сетевое оборудование, оборудование резервного копирования, оборудование для бесперебойного энергообеспечения)\n  cтоимость приобретённого программного обеспечения (начиная с операционной системы, антивирусной защиты, заканчивая бизнес-приложениями)\n  cтоимость расходных материалов для оргтехники (картриджей, бумаги для печати)\n  стоимость обновлений программного обеспечения\n  затраты на оплату электроэнергии, потребляемой оборудованием\n\n\nВ отчете должны быть приведены:\n\n  уточненная организационная диаграмма предприятия\n  схемы расположения офисов (план помещений) и рабочих мест в помещениях\n  схема кабельной сети\n  схема локальной вычислительной сети с расположением элементов ИТ-инфраструктуры.\n  перечень программного обеспечения (в зависимости от бизнес-процессов предприятия)\n  перечень рабочих станций, серверов, переферийных устройств, …\n\n\n\n\nРисунок 1 – Пример организационной диаграммы малого предприятия\n\nИТ-Инфраструктура\n\nДля обеспечения  эффективности работы современной компании ей нужна качественная полноценная ИТ-инфраструктура, включающая целый комплекс служб, подсистем и решений. Это сочетание сервисов должно по своей надежности не только соответствовать сегодняшнему состоянию предприятия, но и иметь запас прочности на будущее развитие.\n\nИТ-инфраструктура представляет собой набор программных, технических и информационных средств, который делает возможным работу приложений для  бизнеса – таких, как электронная почта, CRM и все столь привычные и делающие жизнь удобной вещи, как банковские переводы, онлайн-транзакции.\n\n\n  ИТ-инфраструктура – это организационно-техническое объединение программных, вычислительных и телекоммуникационных средств, связей между ними и эксплуатационного персонала, обеспечивающее предоставление информационных, вычислительных и телекоммуникационных ресурсов, возможностей и услуг работникам (подразделениям) предприятия (организации), необходимых для осуществления профессиональной деятельности и решения соответствующих бизнес-задач [1].\n\n\nИТ-инфрастуктура включает в себя:\n\n  серверы, компьютеры (рабочие станции);\n  периферийные устройства (принтеры, факсы);\n  программное обеспечение;\n  сети для передачи данных;\n  телефонные станции.\n\n\nИТ-инфраструктуру можно рассмотреть как набор четырех групп сервисов [2]:\n\n  технологические сервисы;\n  сервисы для совместной работы;\n  сервисы сообщений;\n  сервисы для обеспечения безопасности.\n\n\nИсточники\n\n\n  cyclowiki.org: ИТ-инфраструктура\n  Конспект лекций по дисциплине «Управление ИТ-сервисами и контентом» Составил: к.т.н., Бакаев М. A.\n  ИТ-инфраструктура предприятия - что нужно бизнесу?\n  Описание ИТ-инфраструктуры организации на примере студии дизайна\n  Построение ИТ инфраструктуры небольшого офиса\n  Описание ИТ-инфраструктуры предприятия\n  ИТ-инфраструктура как сервис: от сервера до приложения\n  Компоненты ИТ-инфраструктуры предприятия\n  ИТ-инфраструктура\n\n",
      "url": "/pages/it/lab-it-structure/"
    },{
      
      "title": "Лабораторная работа №1",
      
      "content": "Задание\n\n\n  Найти на домашней странице пяти Интернет-провайдеров Самары информацию о технических характеристиках предоставляемых услуг для физических или юридических лиц (скорость, доступность, …).\n  Найти на домашней странице (в договоре или других формах) пяти хостинг-провайдеров информацию о технических характеристиках предоставляемых услуг (заявляемое качество предоставляемых услуг, работа службы поддержки).\n\n\nМетодические рекомендации\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab1/"
    },{
      
      "title": "Лабораторная работа №1",
      
      "content": "\n  Сгенерируйте 100 значений случайной величины, равномерно распределенной в интервале от 0 до 100\n  Определите количество чисел больше 30\n  Найдите среднее арифметическое первых 20 чисел\n  Найдите среднее арифметическое последних 20 чисел\n  Найдите сумму произведений первых 50 и последних 50 чисел последовательности\n  Постройте последовательность средних значений смежных чисел последовательности, например: {1,2,3} -&gt; {1.5, 2.5}\n  Найдите позицию максимального числа последовательности\n  Отсортируйте последовательность по возрастанию и найдите номера позиций двух смежных чисел в отсортированной последовательности, расстояние между которыми максимально\n  Удалите из последовательности числа, принадлежащие интервалу от 30 до 50.\n  Задайте положение пяти точек на плоскости при помощи генератора случайных чисел. Координаты точек должны принадлежать интервалу [0, 10].\n  Найдите площади всех треугольников, которые можно построить, используя полученные точки как вершины.\n  Найдите координаты трех точек-вершин из этого списка, по которым можно построить треугольник с максимальной площадью.\n\n\n",
      "url": "/pages/wolfram/lab1/"
    },{
      
      "title": "Лабораторная работа 1",
      "description": "Задание для лабораторной работы 1.\n",
      "content": "Подгруппа 1\n\nНаписать программу решения квадаратного уравнения\n\nimport math\n\nprint(\"Введите коэффициенты для уравнения (ax^2 + bx + c = 0):\")\n\na = float(input(\"a=\"))\nb = float(input(\"b=\"))\nc = float(input(\"c=\"))\n\ndiscr=b**2-4*a*c\n\nif discr&gt;0:  \n  x1 = (-b+math.sqrt(discr))/(2*a)\n  x2 = (-b-math.sqrt(discr))/(2*a)\n  print('x1 = {:5.2f}, x2 = {:5.2f}'.format(x1, x2))\nelse:  \n  print('Корней нет')  \n\n\nПодгруппа 2\n\nДля заданного списка\ndata = [4, 5, 2, 3, 8, 7, 4, 5, 0, 5, 2, 1, 2, 8, 7, 4, 3, 5, 2, 1]\n\nвыведите на экран при помощи функции print:\n\n  item первые пять элементов\n  каждый третий элемент\n  каждый третий элемент с конца\n  последние пять элементов (в исходном порядке)\n  последние пять элементов (в обратном порядке)\n  количество элементов, равных 5\n\n",
      "url": "/pages/python/lab1/"
    },{
      
      "title": "Лабораторная работа 10",
      
      "content": "Задание 1\n\nПостроить график функций  \\(\\cos x\\), \\(\\sin x\\)  на интервале от 0 до  \\(2\\pi\\) на одном рисунке, обозначив  первую точку пересечения двух графиков окружностью с центром в точке пересечения и выносной линией от этой окружности с указанием значения \\(x\\) для точки пересечения и значения функции в этой точке.\n\nЗадание 2\n\nЗадать размер графика 18 x 10 см, размер шрифта 14, семейство шрифтов Times.\n\nЗадание 3\n\nСохранить изображение графика в формате png.\n\n\n",
      "url": "/pages/python/lab10/"
    },{
      
      "title": "Относительное движение материальной точки",
      
      "content": "\n  Построить и проинтегрировать уравнения относительного движения шарика в механической системе, заданной для исследования в курсовой работе по теоретической механике.\n  Построить графики изменения координаты шарика относительно тела 1, относительной скорости шарика, силы реакции канала или направляющей, по которым движется шарик.\n\n\n\n\nВ отчет должны быть включены:\n\n  текст программы;\n  результаты моделирования (графики).\n\n\nНа всех графиках должны быть подписи осей с указанием размерностей величин с размером символов на шкалах не менее 2 мм.\n",
      "url": "/pages/wolfram/lab1_/"
    },{
      
      "title": "Лабораторная работа №2",
      
      "content": "Задание\n\nИспользуя результаты первой лабораторной работы, в системе iTop ITSM &amp; CMDB:\n\n\n  В разделе “Управление конфигурациями” создать записи о расположениях (комнатах) предприятия.\n  В разделе “Управление конфигурациями” создать записи о контактах с привязкой их к расположениям предприятия.\n  В разделе “Управление конфигурациями” создать записи о конфигурационных единицах, включая записи о физических устройствах (компьютеры,  принтеры, ИБП, …) и программном обеспечении. В разделе “Администрирование данных” при необходимости создать записи о брендах, версиях ОС.\n\n\nМетодические рекомендации\n\nАдрес сервера iTop ITSM &amp; CMDB и реквизиты учетных записей приведены в СДО на странице курса “Интегрированные математические пакеты”.\n\niTop ITSM &amp; CMDB — это веб-продукт с открытым исходным кодом, предназначенный для автоматизации ИТ-подразделений предприятий и сервис провайдеров. iTop разработан на основе лучших практик ITIL/ITSM и в то же время является достаточно гибким, чтобы адаптироваться к процессам организации.\n\niTop ITSM &amp; CMDB позволяет организовать:\n\n  Управление инцидентами и запросами на обслуживание\n  Управление проблемами, изменениями и знаниями\n  Управление активами и конфигурациями\n  Управление уровнем сервиса, каталогом услуг и поставщиками\n\n\nЦентром архитектуры iTop является база данных управления конфигурацией (CMDB), которая хранит актуальную информацию об ИТ-инфраструктуре в виде конфигурационных элементов и взаимосвязей между ними:\n\n  Физические устройства\n  Программное обеспечение\n  Бизнес-процессы\n  Расположения\n  Документы\n  Контакты и многие другие\n\n",
      "url": "/pages/it/lab2/"
    },{
      
      "title": "Движение системы материальных точек",
      
      "content": "Задание\n\n\n  Используя заготовку программы, разработать модель движения системы материальных точек с различными массами и различныеми жесткостями пружин.\n  Добавить в механическую систему сухое трение, полагая, что материальные точки движутся по шероховатой горизонтальной плоскости с заданным коэффициентом трения скольжения \\(f_d = 0.1\\) и покоя \\(f_s = 0.3\\).\n\n\nКоэффициент трения в за висимости от скорости точки \\(v\\) вычисляется по следующей формуле:\n\n\n  \n    \n      [f(v) = \\left[ f_d + (f_s-f_d) \\exp\\left(-\\frac{\n      v\n      ^2}{v_s^2}\\right) \\right] \\tanh(k \\cdot v) + k_v v]\n    \n  \n\n\nгде \\(v_s = 0.002\\), \\(k_v = 0.1\\), \\(k = 10^4\\).\n\nТребования к отчёту\n\nВ отчет должны быть включены:\n\n\n  Графики изменения расстояний между материальными точками.\n  Графики изменения координат материальных точек.\n  Графики изменения скоростей точек в направлении оси \\(x\\).\n  Графики изменения потенциальной энергии системы.\n  Графики изменения кинетической энергии системы.\n  Графики изменения полной механической энергии системы.\n\n",
      "url": "/pages/wolfram/lab2/"
    },{
      
      "title": "Лабораторная работа 2",
      "description": "Задание для лабораторной работы 2.\n",
      "content": "Задание 2.1 (для двух подгрупп)\n\nКоординаты ‘живых’ клеток колонии заданы списком пар координат \\(x\\) и \\(y\\):\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nНапишите программу, которая для заданных координат определяет занята клетка или свободна.\n\nПервый вариант программы\n\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nx = 1\ny = 3\n\nisOccuped = False\n\nfor cell in cells :\n    if x == cell[0] and y == cell[1] :\n      isOccuped = True\n      break\n\nprint(isOccuped)\n\n\nВторой вариант программы\n\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nx = 1\ny = 3\n\nisOccuped = [x, y] in cells      \n\nprint(isOccuped)\n\n\nЗадание 2.2 (для двух подгрупп)\n\nКоординаты ‘живых’ клеток колонии заданы списком пар координат \\(x\\) и \\(y\\):\ncells = [ [1,1], [2,1], [3,1], [3,2], [2,3] ]\n\nНапишите программу, которая для заданных координат клетки поля определяет количество её соседей:\nx = 1\ny = 1\n#\n# Текст программы\n#\nprint(neighbors)\n\n",
      "url": "/pages/python/lab2/"
    },{
      
      "title": "Лабораторная работа №3",
      
      "content": "Задание\nОзнакомиться с современными пятью программными средствами, которые могут использоваться для управления веб-контентом. Собрать и проанализировать информацию об особенностях таких программных средств и их возможностях.\n\nКритерии сравнения\n\n  Условия использования (лицензии): бесплатные и open-source, коммерческие (платные), собственные разработки («внутренние»).\n  Возможность переноса (отчуждения): отчуждаемые, «ПО как услуга» (Software as a Service), т.е. предоставляемые на сервере автора.\n  Функциональность: блог, личный сайт, сайт-визитка, интернет-магазин, сайт сообщества, универсальные (расширяемые).\n  По используемым технологиям: языки программирования, базы данных.\n  По возможности расширения функциональности: наличие ядра и модулей расширения, легкость внедрения собственного кода, легкость настройки внешнего вида для посетителя.\n\n\nПримеры\n\nJoomla, Drupal, WordPress, …\n\nОбзор ECM систем и СЭД\n\nЗадание\n\nОзнакомиться с современными пятью программными средствами, которые могут использоваться для управления контентом на предприятии и управления документооборотом. [https://www.itweek.ru/ecm/article/detail.php?ID=125346]\n\nКритерии сравнения\n\n\n  Архитектура (единая система, модули, отдельные продукты и т.п.)\n  Основное назначение\n  Тип лицензии\n  Требования к платформам и прочему обеспечению\n  Распространенность, доля рынка\n  Поддержка основных возможностей по управлению контентом:\n    \n      управление документами, файлами, записями, архивами (хранением данных) и поиском;\n      поддержка документооборота согласно бизнес-процессам и документо-ориентированного взаимодействия пользователей (включая средства для командной работы);\n      управление знаниями;\n      управлению веб-контентом (корпоративным веб-порталом);\n      управление базой клиентов;\n      управление каталогом товаров и услуг, запасами;\n      управление заказами, поставками и возвратами;\n      управление финансами и счетами, финансовый анализ.\n    \n  \n\n\nПримеры ECM систем и СДО\n\nAlfresco ECM, Directum, Documentum, ECM-система Дело, 1С: Документооборот, Тезис, Elma ECM, DocuWare, Docsvision ECM, Hyland, IBM, Laserfiche, LanDocs, M-Files, Microsoft SharePoint, OpenText, Seismic, THESIS ECM, XEROX Docushare, Nuxeo Content Platform, SynerDocs, DocsHouse\n\nОпределения\n\nECM\n\nСтратегии, организационные методы и инструментальные средства, используемые для сбора, ввода, администрирования, хранения, архивирования и доставки контента, относящегося к ключевым процессам организации.\n\nECM-система\n\nECM — это программное обеспечение для управления корпоративным контентом.\n\nСистемы электронного документооборота (СЭД)\nСЭД — это организационно-техническая система, обеспечивающая процесс создания, распространения электронных документов в компьютерных сетях и управления доступом к ним, а также обеспечивающая контроль над потоками документов в организации.  Процесс управления опирается на человеко-читаемые (в основном текстовые) документы, содержащие в слабоформализованной форме инструкции для сотрудников, необходимые к исполнению.\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab3/"
    },{
      
      "title": "Аналитические преобразования",
      
      "content": "Положение материальных точек двойного маятника, показанного на рисунке 1, определяются выражениями:\n\n[\\boldsymbol{r}_1 = \\boldsymbol{A}_1 \\begin{bmatrix} 0 \\ -l_1/2 \\end{bmatrix},]\n\n[\\boldsymbol{r}_2 = \\boldsymbol{A}_1 ( \\begin{bmatrix} 0 \\ -l_1 \\end{bmatrix} + \\boldsymbol{A}_2 \\begin{bmatrix} 0 \\ -l_2/2 \\end{bmatrix})]\n\n\nРисунок 1 – Механические системы\n\nгде:\n\n[\\boldsymbol{A}_i =  \\begin{bmatrix} \\cos \\varphi_i &amp; -\\sin \\varphi_i \\ \\sin \\varphi_i &amp; \\cos \\varphi_i   \\end{bmatrix}, \\quad i=1,2.]\n\n\n  \n    Найдите и упростите выражение для кинетической энергии маятника.\n  \n  \n    Приведите выражение для кинетической энергии к виду:\n  \n\n\n[T = a_{11} \\dot{\\varphi}1^2 + 2 a{12} \\dot{\\varphi}1 \\dot{\\varphi}_2 + a{22} \\dot{\\varphi}_2]\n\n\n  \n    Постройте список обобщенных коэффициентов массы \\(a_{11}, a_{12}, a_{22}\\).\n  \n  \n    Постройте выражение для потенциальной энергии системы, которое равно нулю при \\(\\varphi_1 = 0\\), \\(\\varphi_2 = 0\\).\n  \n  \n    Упростите выражение для потенциальной энергии.\n  \n  \n    Разложите выражение для потенциальной энергии в ряд в окрестности \\(\\varphi_1 = 0\\), \\(\\varphi_2 = 0\\) до членов второго порядка и приведите её к виду:\n  \n\n\n[\\Pi = c_{11} \\varphi_1^2 + 2 c_{12} \\varphi_1 \\varphi_2 + c_{22} \\varphi_2]\n\n\n  Постройте список обобщенных коэффициентов жёсткости \\(a_{11}, a_{12}, a_{22}\\).\n\n",
      "url": "/pages/wolfram/lab3/"
    },{
      
      "title": "Лабораторная работа 3",
      "description": "Задание для лабораторной работы 3.\n",
      "content": "Источник Е.А. Симановский Сборник заданий к лабораторным работам\n\nИндивидуальные задания (по номеру в ведомости)\n\nЗадание 3.1\n\nКоличество элементов массива и сами элемены вводятся в диалоговом режиме пользователем.\n\n\n  Дан массив натуральных чисел. Найти сумму элементов, кратных данному К.\n  Дан массив целых чисел, в котором есть нулевые элементы. Создать массив из номеров этих элементов.\n  Дан массив из N целых чисел. Выяснить, какое число встречается в массиве раньше – положительное или отрицательное.\n  Дан массив из N натуральных чисел. Создать массив из чётных чисел этого массива. Если таких чисел нет, то вывести сообщение об этом факте.\n  Дан массив из N чисел. Указать наименьшую длину числовой оси, содержащую все эти числа.\n  Дан массив из N действительных чисел. Заменить все его члены, большие данного Z, этим числом. Подсчитать количество замен.\n  Дан массив действительных чисел, размерность которого N. Подсчитать, сколько в нем отрицательных, положительных и нулевых элементов.\n  Дан массив действительных чисел, размерность которого N. Поменять местами наибольший и наименьший элементы массива.\n  Дан массив А из N целых чисел. Вывести на печать только те числа, для которых выполняется условие Аi ≤ i, где i – номер элемента массива.\n  Дан массив из N натуральных чисел. Указать те числа, остаток от деления которых на М равен L (0 ≤ L ≤ M-1).\n  В заданном одномерном массиве поменять местами соседние элементы, стоящие на чётных местах, с элементами, стоящими на нечётных.\n  При поступлении в вуз абитуриенты, получившие «двойку» на первом экзамене, ко второму не допускаются. В массиве A[n] записаны оценки экзаменующихся, полученные на первом экзамене. Подсчитать, сколько человек не допущено ко второму экзамену.\n  Дана массив чисел, среди которых имеется один нуль. Вывести на печать все числа включительно до нуля.\n  В одномерном массиве размещены: в первых элементах значения аргумента, а в следующих – соответствующие им значения функции. Напечатать элементы этого массива в виде двух параллельных столбцов: аргументы и значения функции.\n  Дан целочисленный массив с количеством элементов N. Напечатать те его элементы, индексы которых являются степенями двойки (1, 2, 4, 8, 16, …).\n  Дан массив из N действительных чисел. Напечатать те его элементы, которые принадлежат отрезку [c, d].\n  Дан массив целых положительных чисел. Найти произведение только тех чисел, которые больше заданного числа М. Если таких нет, то выдать сообщение об этом.\n  Массив из N элементов состоит из нулей и единиц. Поставить в начало этого массива нули, а затем единицы.\n  Дан массив из N действительных чисел, в котором есть только положительные и отрицательные элементы. Вычислить произведение отрицательных элементов P1 и произведение положительных элементов P2. Сравнить модуль P2 с модулем P1 и указать, какое из произведений по модулю больше.\n  Задан массив с количеством элементов N. Сформируйте два массива: в первый включите элементы исходного массива с чётными номерами, а во второй – с нечётными.\n  Составить программу нахождения наибольшего среди тех элементов одномерного массива А, что лежат в интервале [С, D].\n  Составить программу отыскания наименьшего среди тех элементов одномерного массива А, что лежат вне интервала [С, D].\n  Составить программу подсчёта среди элементов одномерного массива В количества чисел, больших С.\n  Составить программу отыскания наименьшего среди элементов одномерного массива А и его индекса.\n  Задан массив Y с количеством элементов N. Сформируйте массив, в котором элементы с чётными индексами будут равны соответствующим элементам исходного массива, а элементы с нечётными индексами будут равны нулю.\n  Составить программу подсчёта в одномерном массиве А суммы элементов с чётными индексами и суммы элементов, значения которых больше нуля.\n  Составить программу подсчёта в одномерном массиве С количества отрицательных и произведения положительных элементов массива.\n  Составить программу подсчёта в одномерном массиве В произведения элементов с нечётными индексами и суммы отрицательных элементов.\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с чётными индексами в массиве А и суммы элементов, значения которых больше нуля, в массиве В.\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с нечётными индексами в массиве B и произведения отрицательных элементов в массиве А.\n\n\nЗадание 3.2\n\n\n  Задан двумерный массив С из 4-х строк и 4-х столбцов (квадратная матрица). Составить программу подсчёта суммы всех отрицательных элементов и суммы элементов по главной диагонали.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу подсчёта суммы произведений элементов строк.\n  Задан двумерный массив А из 5-и строк и 2-х столбцов. Составить программу, которая формирует одномерный массив В, каждый элемент которого есть произведение элементов массива А в строке.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, элементы главной диагонали  которого равны соответствующим элементам исходного массива, а остальные элементы равны нулю.\n  Задан двумерный массив А из 2-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов исходного в столбце.\n  Задан двумерный массив Y из 5-и строк и 5-и столбцов. Составить программу подсчёта суммы всех положительных элементов и суммы элементов по главной диагонали.\n  Задан двумерный массив А из 4-х строк и 4-х столбцов. Составить программу, которая подсчитывает произведение элементов массива, лежащих вне главной диагонали.\n  Задан двумерный массив С из 6-и строк и 6-и столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу, которая вычисляет значение суммы произведений элементов строк\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов в столбце. Вычислить произведение элементов полученного массива.\n  Задан двумерный массив А из 5-и строк и 4-х столбцов. Составить программу, которая вычисляет значение произведения сумм строк.\n  Задан двумерный массив Y из 4-х строк и 4-х столбцов. Составить программу, которая вычисляет S – сумму элементов побочной диагонали и значение суммы всех элементов массива\n  Задан двумерный массив С из 6-и строк и 3-х столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие не на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С Вычислить произведение всех элементов нового массива.\n  Задан двумерный массив А из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть произведение элементов массива А в каждой строке. Затем вычислить сумму элементов полученного одномерного массива.\n  Задан двумерный массив C из 3-х строк и 5-и столбцов. Составить программу, которая вычисляет произведение всех элементов массива. Затем организовать новый массив С, в котором значения элементов, лежащих на главной диагонали, равны 1, а остальные элементы равны квадрату соответствующих элементов исходного массива С.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая вычисляет сумму всех элементов массива.\nЗатем организовать новый массив В, в котором заменить отрицательные элементы исходного массива на 1, а значения остальных элементов оставить без изменения. Подсчитать количество замен.\n  Задан двумерный массив А из 8-и строк и 3-х столбцов. Составить программу, которая подсчитывает общее число неотрицательных элементов в массиве. Затем организовать формирование нового массива В, в котором значения элементов исходного массива заменить на противоположные по знаку.\n  Задан двумерный массив В из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив С, элементы которого равны количеству положительных элементов в строке исходного массива В.\n  Задан двумерный массив D из 5-и строк и 5-и столбцов. Составить программу, которая организует одномерный массив, элементы которого равны элементам массива D , лежащим на побочной диагонали, а затем вычисляет сумму элементов полученного одномерного массива.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая подсчитывает количество положительных, отрицательных и нулевых элементов в массиве В и организует одномерный массив из полученных значений.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество положительных элементов исходного массива в столбце. Вычислить произведение элементов полученного массива.\n  Задан двумерный массив С из 2-х строк и 4-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество отрицательных элементов исходного массива в строке. Вычислить сумму элементов полученного массива.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество отрицательных элементов исходного массива в столбце. Вычислить сумму элементов полученного массива.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, одна строка которого содержит количество ненулевых элементов исходного массива в столбце, а вторая – количество нулевых. Организовать проверку правильности формирования массива путём вычисления суммы элементов полученного массива.\n  Задан двумерный массив D из 5-и строк и 5- столбцов. Составить программу, которая организует новый массив B путём деления всех элементов заданной матрицы на элемент, наибольший по абсолютной величине.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наибольший элемент среди элементов в строке исходного массива.\n  Задан двумерный массив X из 3-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наименьший по абсолютной величине элемент среди элементов в столбце исходного массива.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наибольший элемент среди элементов в столбце исходного массива.\n  Задан двумерный массив X из 3-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наименьший по абсолютной величине элемент среди элементов в строке исходного массива.\n  Задан двумерный массив A из 6-и строк и 6-и столбцов и одномерный массив Y из 6 строк. Составить программу, которая подсчитывает количество элементов, больших 1, а затем вычисляет произведение всех элементов массива.\n\n",
      "url": "/pages/python/lab3/"
    },{
      
      "title": "Лабораторная работа №4",
      
      "content": "Задание\n\nОформить сайт о культуре и традициях заданной страны в соответствии с заданным вариантом с помощью CMS (например WordPress). Оформление, текст и изображения подобрать самостоятельно. Сайт должен содержать продуманную структуру навигации сайта, содержательный контент, продуманный дизайн, организованную работу с пользователями.\n\nМетодические рекомендации\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab4/"
    },{
      
      "title": "Движение системы с двумя степенями свободы",
      
      "content": "\n  \n    Построить и проинтегрировать уравнения движения системы с двумя степенями свободы, заданной для исследования в курсовой работе по теоретической механике.\n  \n  \n    Построить графики изменения:\n    \n      координаты шарика относительно тела 1 (\\(x\\));\n      угла поворота тела 1 (\\(\\varphi\\));\n      относительной скорости шарика (\\(\\dot x\\));\n      угловой скорости тела 1 (\\(\\dot \\varphi\\));\n      кинетической энергии системы;\n      потенциальной энергии системы.\n    \n  \n\n\n\n\nВ отчет должны быть включены:\n\n  текст программы;\n  результаты моделирования (графики).\n\n\nНа всех графиках должны быть подписи осей с указанием размерностей величин с размером символов на шкалах не менее 2 мм.\n\nПример\n\nВывод уравнений движения системы с двумя степенями свободы\n",
      "url": "/pages/wolfram/lab4/"
    },{
      
      "title": "Лабораторная работа 4",
      "description": "Задание для лабораторной работы 4.\n",
      "content": "Дана клетка с координатами x, y. Построить список пар координат, смежных клеток. Координаты смежных клеток отличаются от координат x, y не больше чем на 1.\n\n\nx, y = 2, 3\n\n# Смещения \ndxdy = [ ( 1, 1), ( 0, 1), (-1, 1), \n         (-1, 0), (-1,-1), ( 0,-1),\n         ( 1,-1), ( 1, 0) ]\n\n# Пустой список, в который будут добалятся координаты смежных клеток\nnearest = list()\n\n# Для каждого элемента из списка смещений\nfor (dx,dy) in dxdy:\n    nearest_cell = (x+dx, y+dy)\n    nearest.append(nearest_cell)\n    \nprint(nearest)\n\n\nЗадание 4.1\n\nДля заданной колонии клеток, например\n\ncolony = [ (1, 1), (1, 2), (1, 3) ]\n\n\nи определенного при помощи предыдущей программы списка смежных клеток, получить список пар координат (кортежей) занятых клеток из числа смежных, т.е. определить список соседей клетки с координатами x и y\n\nx, y = 2, 3\n\nneighbours = list()\n\n#\n# Здесь ваш код\n#\n        \nprint(neighbours)\n\n\nКак определить количество соседей?\n\nЗадание 4.2\n\nДля заданной колонии клеток, например\n\n\ncolony = [ (1, 1), (1, 2), (1, 3) ]\n\n\nопределите список координат клеток (без повторений), составляющих ареал колонии. В ареал колонии входят все живые клетки колонии и клетки смежные живым клеткам колонии.\n\n\n# В ареал входят все клетки колонии \narea = list(colony)\n\n# и клетки смежные клеткам колонии \n\nfor cell in colony:\n    for (dx,dy) in dxdy:\n        x = cell[0]\n        y = cell[1]\n        nearest_cell = (x+dx, y+dy)\n        if nearest_cell not in area:\n            # Ваш код\n            # Ваш код\n            \nprint('Колония ', colony)\nprint('Ареал колонии ', area)\n\n\n\n",
      "url": "/pages/python/lab4/"
    },{
      
      "title": "Анимация в Wolfram Mathematica",
      
      "content": "\n  \n    Построить анимацию движения механической системы с двумя степенями свободы, заданной для исследования в курсовой работе по теоретической механике.\n  \n  \n    Сохранить результат в файл формата avi/mp4/gif.\n  \n\n",
      "url": "/pages/wolfram/lab5/"
    },{
      
      "title": "Лабораторная работа 5",
      "description": "Задание для лабораторной работы 5.\n",
      "content": "Колония клеток заданна множеством (set) пар координат (множество кортежей), например:\n\ncolony = { (1,1), (2,1), (3,1), (3,2), (2,3) }  \n\n\n\n5.1 Напишите функцию count_neighbors(cell), которая возвращает количество соседей у клетки с координатами cell = (x, y).\n\n5.2 Напишите функцию get_colony_area(colony), которая возвращает множество (set) клеток, граничащих с колонией, включая клетки, занятые колонией.\n\n5.3 Напишите функцию next_generation(colony), которая возвращает множество (set) клеток следующего поколения, количество умерших и родившихся клеток.\n",
      "url": "/pages/python/lab5/"
    },{
      
      "title": "Лабораторная работа 6",
      
      "content": "Загрузить произвольный файл с текстом на русском языке и заменить все русские буквы по правилам транслитерации, сохраняя регистр букв (верхний или нижний). Правила преобразования должны загружатсья из другого текстового файла (например ‘dictionary.txt’), каждая строка которого содержит русскую букву и её представление латиницей:\n\n\nб:b\nв:v\nг:g\n...\nж:zh\n\n\n\nПреобразованный вариант необходимо сохранить в текстовый файл и вывести на экран.\n\nПример функции, загружающей словарь\n\n\ndef load_dictionary(dictionary_file):\n    with open(dictionary_file, 'rt') as f:\n        res = dict(line.strip().split(':') for line in f)\n    return res    \n\n\n\n",
      "url": "/pages/python/lab6/"
    },{
      
      "title": "Лабораторная работа 7",
      
      "content": "Загрузить файл с текстом на русском языке и вывести на экран первые пять наиболее часто встречающихся  в тексте букв, исключая знаки препинания и пробелы, например\n\n\nа - 150\nе - 123\nо - 100\nи - 90\nу - 80\n\n\n",
      "url": "/pages/python/lab7/"
    },{
      
      "title": "Лабораторная работа 8",
      
      "content": "Объявлен класс Point – точка на плоскости\n\nclass Point:\n    def __init__(self, x, y):\n        ''' Конструктор \n        x - координата x точки\n        y - координата y точки\n        '''\n        self.x = x\n        self.y = y\n\n\nи класс Shape – фигура\n\nclass Shape:\n    def __init__(self, x, y):\n        ''' Конструктор \n        x - координата x центра окружности\n        y - координата y центра окружности\n        '''\n        self.x = x\n        self.y = y\n\n\nСоздайте класс Rectangle на основе класса Shape. Представитель класса Rectangle создаётся при помощи конструкутора с четырьмя параметрами, задающими положение центра прямоугольника его ширину и высоту.\n\nclass Rectangle(Shape):\n    def __init__(self, x, y, a, b):\n        super().__init__(x,y)\n        self.a = a\n        self.b = b\n\n\n\nДобавьте к классу Rectangle метод area, который вычисляет и возвращает площадь прямоугольника.\n\nclass Rectangle(Shape):\n    \n    def __init__(self, x, y, a, b):\n        super().__init__(x,y)\n        self.a = a\n        self.b = b\n    \n    def area(self):\n        return self.a*self.b\n\nR = Reactangel(0,0,3,2)\nprint(R.area())\n\n&gt; 6\n\n\nДобавьте к классу Rectangle метод perimeter, который вычисляет и возвращает периметр прямоугольника.\n\nR = Reactangel(0,0,3,2)\nprint(R.perimeter())\n\n&gt; 10\n\n\nСоздайте класс Circle на основе класса Shape. Параметры конструктора для создания экземляра класса Circle – положение центра окружности и её радиус.\n\nC = Circle(0,0,4)\n\n\nДобавьте к классу Circle метод area, который вычисляет и возвращает площадь, ограниченную окружностью.\n\nC = Circle(0,0,4)\nprint(C.area)\n\n\nДобавьте к классу Circle метод perimeter, который вычисляет и возвращает длину окружности.\n\nC = Circle(0,0,4)\nprint(C.perimeter)\n\n\nСоздайте класс Ellipse на основе класса Shape. Параметры конструктора для создания экземляра класса Ellipse – положение центра, большая и малая полуось.\n\nE = Ellipse(0,0,4,2)\n\n\nДобавьте к классу Ellipse метод area, который вычисляет и возвращает площадь, ограниченную эллипсом.\n\nE = Ellipse(0,0,4,2)\nprint(E.area())\n\n\nСоздайте класс отрезок – Line. Параметры конструктора для создания экземляра класса Line – две точки – объекты типа Point.\n\nL = Line( Point(0,0), Point(1,1) )\n\n\nДобавьте к классу Line метод length, который вычисляет и возвращает длину отрезка.\n\nL = Line( Point(0,0), Point(1,1) )\nprint(L.length())\n\n\nНапишите функцию intersect с двумя аргументами типа Line. Функция должна возвращать пустой кортеж, если отрезки не пересекаются, или кортеж с одним элементом типа Point – точкой пересечения отрезков.\n\nL1 = Line( Point(0, 0), Point(5,1) )\nL2 = Line( Point(0,-3), Point(5,6) )\n\nprint( intesect(L1, L2) )\n\n\nВ классе Rectangle определите get и set методы для всех свойств:\n\n  get_x, set_x\n  get_y, set_y\n  get_a, set_dx,\n  get_b, set_b.\n\n\nR = Rectangle(0,0,1,3)\nR.set_a(4)\nprint( R.get_a() )\n\n\nОпределите метод get_area, возвращающий площадь прямоугольника.\n\nR = Rectangle(0,0,1,3)\nprint( R.get_area() )\n\n\nОпределите метод get_vertices, который возвращает список пар координат вершин прямоугольника\n\n    ((x1, y1), (x2, y2), (x3,y3), (x4, y4))\n\n\nПерепишите класс Rectangle, защитив свойства (x, y, a, b) прямоугольника от прямого изменения.\n\nR = Rectangle(0,0,1,3)\nR.a = 3\n\n\nПерепишите класс Rectangle, используя синтаксис property для чтения и изменения свойств.\n\nR = Rectangle(0,0,1,3)\nR.a = 2\nprint(R.area)\n\n\nПерепишите класс Rectangle, используя синтаксис @property для чтения и изменения свойств, включая площадь прямоугольника.\n\nR = Rectangle(0,0,1,3)\nR.a = 2\nprint(R.area)\n\n",
      "url": "/pages/python/lab8/"
    },{
      
      "title": "Лабораторная работа 9",
      
      "content": "Задание 1\n\nНапишие функцию, выполняющую вычисление следа квадратной матрицы. След матрицы – это сумма её диагональных элементов.\n\n\nimport numpy as np\n\ndef trace(A):\n    ...\n    ...\n    ...\n    return tr\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = trace(M1)\n\nprint(result)\n\n\n\nЗадание 2\n\nНапишие функцию, выполняющую поворот квадратной матрицы против часовой стрелки на 90 градусов.\n\n\nimport numpy as np\n\ndef rotate90ccw(A):\n    ...\n    ...\n    ...\n    return res\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = rotate90ccw(M1)\n\nprint(result)\n\n\n\nЗадание 3\n\nНапишите функцию, вычисляющую произведение матрицы на вектор\n\n\nimport numpy as np\n\ndef MatrixVec(M, v):\n    ...\n    ...\n    ...\n    return res\n\n\nM = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0]])\na = np.array([1,2,3,4.0])\n\nresult = MatrixVec(M, a)\n\nprint(result)\n\n\n\nПроверьте результат при помощи функции dot библиотеки numpy.\n\nЗадание 4\n\nНапишите функцию, вычисляющую произведение двух матриц\n\n\nimport numpy as np\n\ndef MatrixMatrix(A, B):\n    ...\n    ...\n    ...\n    return res\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0]])\nM2 = np.array([[1,2],[1,2],[1,2],[1,2]])\n\nresult = MatrixMatrix(M1, M2)\n\nprint(result)\n\n\n\nПроверьте результат при помощи функции dot библиотеки numpy.\n\nЗадание 5\n\nПерепешите код функции в предыдущем задании, используя синтаксис A[:,0], A[:,1], для исключения одного цикла из кода функции, представив каждый столбец матрицы результата как линейную комбинацию столбцов матрицы A, например\n\n[\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix} \\begin{bmatrix} 5 &amp; 6 \\ 7 &amp; 8 \\end{bmatrix} = \\left( 5 \\begin{bmatrix} 1 \\ 3 \\end{bmatrix} + 7 \\begin{bmatrix} 2 \\ 4 \\end{bmatrix} \\quad 6 \\begin{bmatrix} 1 \\ 3 \\end{bmatrix} + 8 \\begin{bmatrix} 2 \\ 4 \\end{bmatrix} \\right)]\n\nЗадание 6\n\nНапишие функцию, выполняющую транспонирование квадратной матрицы без создания новой матрицы\n\n\nimport numpy as np\n\ndef transpose(A):\n    ...\n    ...\n    ...\n    return A\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = transpose(M1)\n\nprint(result)\n\n\n\n",
      "url": "/pages/python/lab9/"
    },{
      
      "title": "Лабораторная работа №1",
      "description": "Задания для лабораторной работы №1 первого семестра курса “Технологии и языки программирования”\n",
      "content": "Дан список:\np = [0.5, 0.3, 1.5, 0.1, 3.2, 0.9]\n\n\n\n  Вычислить значение функции \\(y=f(x)\\) для значения аргумента \\(x\\), заданного пользователем.\n  Изобразить блок-схему программы.\n\n\nВарианты заданий\n\nНапсиать программу, которая вычисляет\n\n\n  \n\\[y = 1 + \\sum_{i=0}^{4} (-1)^i x^{2*n+1}/(2)\\]\n  \n  сумму квадратов косинусов элементов списка\n  сумму квадратов косинусов удвоенных значений элементов списка\n  сумму синусов элементов списка\n\n\nПример\n\nНайти значение функции\n\n[y = 1 + \\sum_{i=1}^{4} \\frac{x^{i}}{2^i}]\n\nimport math\n\nx = input('Введите значение аргумент функции: x = ')\n\ny = 1\nfor i in range(1,5):  \n    y = y + x**i/(2**i)\n\nprint('Значение функции y = ',y)\n\n\nМетодические указания\n\nДля использования в программе математических функций необходимо подключить модуль math. Пример использования функции из модуля math:\nimport math\n\nx = 0.5\n\ny1 = math.sin(x)\n\n\nДругие функции модуля math\n\n\n  math.exp(X)\n  math.log(X)\n\n\nТригонометрические (угол – аргумент или результат функции задаётся в радианах):\n\n\n  math.cos(X)\n  math.sin(X)\n  math.tan(X)\n  math.acos(X)\n  math.asin(X)\n  math.atan(X)\n\n\nКонстанты\n\n\n  math.pi\n  math.e\n\n",
      "url": "/pages/python/lab_01/"
    },{
      
      "title": "Интегрирование уравнений движения механизма с двумя степенями свободы",
      
      "content": "Задание\n\n\n  Разработайте программу для численного интегрирования уравнений движения системы с двумя степенями свободы для механизма из задания для Вашей курсовой работы по теоретической механики (2 курс).\n  Постройте графики изменения обобщенных координат и скоростей (четыре графика на четырёх отдельных рисунках).\n  Постройте одном рисунке графики изменения потенциальной, кинетической и полной энергии системы. Убедитесь, что полная энергия системы остается постоянной.\n\n\nПример\n\nСхема механизма\n\n\n\nВывод уравнений\n\nВывод уравнений в Wolfram Mathematica\n\nПервое уравнение:\n\n[\\ddot \\varphi \\left(m_2 \\left(d^2-\\left(l_0+x\\right) \\left(2 d-l_0-x\\right)+4 h^2\\right)+J_1\\right)+2 m_2 \\dot \\varphi \\dot x \\left(-d+l_0+x\\right)+2 h\n   m_2 \\ddot x = - g m_2 \\left(\\cos \\varphi \\left(-d+l_0+x\\right)+2 h \\sin \\varphi \\right)-g m_1 y_{c1} \\sin \\varphi]\n\nВторое уравнение:\n\n[m_2 {\\dot \\varphi}^2 \\left(d-l_0-x\\right)+2 h m_2 \\ddot \\varphi +m_2 \\ddot x = -c x-g m_2 \\sin \\varphi]\n\nгде \\(l_0\\) – свободная длина пружины, \\(c\\) – жёсткость пружины, \\(m_1\\) – масса пластины,  \\(J_1\\) – момент инерции пластины относительно оси О, \\(m_2\\) масса груза на пружине, \\(d = AK/2\\), \\(y_{c1} = OC_1\\).\n\nПолученные уравнения движения можно записать в матричном виде:\n\n[\\begin{bmatrix}\nm_{11} &amp; m_{12} \nm_{21} &amp; m_{22} \n\\end{bmatrix} \n\\begin{bmatrix}\n\\ddot \\varphi \n\\ddot x \n\\end{bmatrix} =\n\\begin{bmatrix}\nb_1 \nb_2 \n\\end{bmatrix}]\n\nЭлементы матрицы масс:\n\n[\\begin{align}\n&amp; m_{11} = \\left(m_2 \\left(d^2-\\left(l_0+x\\right) \\left(2 d-l_0-x\\right)+4 h^2\\right)+J_1\\right) \n&amp; m_{12} = 2 h m_2 \n&amp; m_{21} = 2 h m_2 \n&amp; m_{22} = m_2 \n\\end{align}]\n\nСлагаемые, не зависящие от ускорений (правые части):\n\n[\\begin{align}\n&amp; b_1 = - g m_2 \\left(\\cos \\varphi \\left(-d+l_0+x\\right)+2 h \\sin \\varphi \\right)-g m_1 y_{c1} \\sin \\varphi - 2 m_2 \\dot \\varphi \\dot x \\left(-d+l_0+x\\right) \n&amp; b_2 = - c x-g m_2 \\sin \\varphi - m_2 \\left(\\dot \\varphi \\right)^2 \\left(d-l_0-x\\right)\n\\end{align}]\n\nMATLAB\n\nФайл-функция правых частей dqdt.m\n\nfunction dq  = dqdt(t, q, p)\n    % Обобщенные координаты и скорости\n    phi  = q(1);    x    = q(2);\n    dphi = q(3);    dx   = q(4);\n\n    % Элементы первой строки матрицы масс\n    m11 = p.m2*(p.d^2-(p.L0+x)*(2*p.d-p.L0-x)+4*p.h^2)+p.J1;\n    m12 = 2*p.h*p.m2;\n\n    % Первая строка правой части\n    b1  = -p.g*p.m2*(cos(phi)*(-p.d+p.L0+x)+2*p.h*sin(phi))-...\n          p.g*p.m1*p.yc1*sin(phi) - 2*p.m2*dphi*dx*(-p.d+p.L0+x);\n\n    % Элементы второй строки матрицы масс\n    m21 = 2*p.h*p.m2;\n    m22 = p.m2;\n    \n    % Вторая строка правой части\n    b2  = -p.c*x - p.g*p.m2*sin(phi) - p.m2*(p.d-p.L0-x)*dphi^2;\n\n    % Разрешаем систему относительно старших производных, решая \n    % систему линейных уравнений \n\n    % Матрица коэффициентов (симметричная)\n    A   = [m11 m12; m21 m22];\n\n    % Матрица правых частей\n    B   = [b1;b2];\n\n    % Решение системы линейных уравнений\n    d2q = A\\B;\n    \n    %  Обобщенные скорости и ускорения\n    dq  = [dphi;dx;d2q];\nend\n\n\nФайл-скрипт для запуска процесса интегрирования main.m\n\nclc;\n\np.m1  = 2;\np.m2  = 0.3;\np.L0  = 0.8;\np.c   = 5;\np.g   = 9.807;\np.R   = 1;\np.h   = p.R/2;\np.d   = sqrt(p.R^2 - p.h^2);\np.J1  = 1.258;\np.yc1 = 0.587;\n\nphi0  = 0.3;\ndphi0 = 1;\nx0    = 0;\ndx0   = 1;\n\n[t, q] = ode113(@(t,q) dqdt(t,q,p), [0; 5], [phi0;x0;dphi0;dx0]);\n\nfigure;\nplot(t,q(:,1),'LineWidth',2);\ngrid on;\nxlabel('t, c'); ylabel('\\phi, радиан');\n\nfigure;\nplot(t,q(:,2),'LineWidth',2);\ngrid on;\nxlabel('t, c'); ylabel('x, м');\n\n\n\n",
      "url": "/pages/matlab/lab_2dof/"
    },{
      
      "title": "Лабораторная работа №2. Создание таблиц",
      
      "content": "Задание\n\nИспользуя результаты лабораторной работы №1 (построение ER-диаграммы предметной области) разработайте базу данных для СУБД MySQL/MariaDB.\n\nМетодические рекомендации\n\n\n  Шаблон отчета по лабораторной работе с примером выполнения\n  Реквизиты для подключения к серверу баз данных приведены в СДО Moodle.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n\n",
      "url": "/pages/databases/lab_ddl/"
    },{
      
      "title": "Лабораторная работа №1. Построение ER-диаграмы",
      
      "content": "Задание\n\nПостройте диаграмму сущность-связь, предлагаемой предметной области, используя нотацию Чена и нотацию Мартина. В отчёте необходимо описать предлагаемые сущности предметной области и их атрибуты с указанием ключевых атрибутов. Приведенное в задание описание предметной области является приблизительным. Допускается уточнять список предлагаемых сущностей и атрибутов.\n\nМетодические рекомендации\n\n\n  Вариант задания выбирается по номеру в ведомости.\n  Шаблон отчета по лабораторной работе с примером построения ER-диаграммы в формате DOCX. В формате PDF\n  Для подготовки диаграмм можно использовать любой графичекий редактор. Рекомендуется использовать on-line приложение (сервис) draw.io, в котором есть библиотеки фигур для создания ER-диаграмм.\n\n\nДополнительная информация\n\n\n  Материалы лекции 2\n  ER-модель\n  Учимся проектированию Entity Relationship — диаграмм\n  Элементы модели “сущность-связь”\n\n\nВарианты заданий\n\n1. Библиотека\n\nИнформационная система библиотеки, состоящей из двух филиалов, предназначена для учета книг, передаваемых читателям. Филиал библиотеки имеет адрес и наименование (минимальный набор атрибутов). При записи в библиотеку читатель предоставляет следующую информацию: ФИО, год рождения и адрес. Экземпляры одной и той же книги могут хранится в любом филиале или в обоих филиалах. Минимальный набор атрибутов книги:\n\n  наименование\n  издательство (наименование, адрес)\n  количество страниц\n  тип обложки (мягкая, твердая, суперобложка)\n  жанр / тип\n\n\nИнформационная система должна позволят определять список прочитанных читателем книг, книги, находящиеся у читателей, количество экземпляров книг в библиотеке.\n\n2. Аптека\n\n\n  Лекарство\n    \n      Наименование\n      Производитель\n      Поставщик\n      Тип\n      Цена (может изменяться)\n      Возможна ли продажа без рецепта\n    \n  \n  Покупатель\n    \n      ФИО\n      Телефон\n    \n  \n  Поставщик\n    \n      Наименование\n      Счет\n      ИНН\n      Адрес\n    \n  \n\n\nИнформационная система предназначена для учета движения товаров от поставщиков в несколько филиалов аптечной сети, продажи товаров покупателям.\n\n3. Больница\n\nИнформационная система больницы (стационара) содержит информацию о врачах больницы и о пациентах. Запись о каждом враче содержит: ФИО, адрес, дату рождения, паспортные данные, специальность, стаж.\n\nИнформация о пациенте \n    - ФИО\n    - Дата рождения\n    - Полис\n    - Дата поступления\n    - Дата выписки \n    - Диагноз\n    - Лечащий врач \n    - Отделение\n    - Палата\n\n4. Предприятие\n\nМалое предприятие разрабатывает информационную систему, частью которой является информационная система учета персонала. В информационной системе хранится следующая информация о сотруднике:\n\n  ФИО\n  Дата рождения\n  Образование\n  Образовательное учреждение, год окончания, специальность\n  Стаж работы\n\n\nА также информация о его назначениях, включая информацию о должности, окладе, номере и дате приказа, по которому он переводится на другую должность, номер отдела. В информационной системе учитывается отпуски сотрудников и больничные листы,  с указанием периодов временной нетрудоспособности сотрудников.\n\n5. Курьерская доставка\n\nОрганизация осуществляет курьерскую доставку товаров. Филиалы организации – пункты приема и выдачи отправлений –  расположены в нескольких городах. Для отправки товара может самостоятельно прийти в филиал организации и отправить товар оплатив стоимость доставки ил вызвать курьера, который заберет посылку после оплаты услуг курьера и услуги доставки. Стоимость услуг курьера фиксирована. Стоимость доставки различна для каждой пары городов. Товар может быть доставлен до пункта выдачи или по адресу получается. Получатель и отправитель могут иметь несколько адресов приема товара для доставки и его получения.\n\n6. Повышение квалификации\n\nДля сотрудников университета организованы курсы по повышению квалификации. Курс ведёт также сотрудник университета. Курс характеризуется датой начала, датой окончания, наименованием. Каждый сотрудник университета может посещать несколько курсов. По окончании курса выдается свидетельство.\n\n7. Научная конференция\n\nВ университете организуется научная конференция, по результатам проведения которой публикуется сборник статей. Конференция имеет наименование и дату начала и дату окончания. Каждый участник конференции отправляет в адрес конференции статью, которая характеризуется наименованием, списком авторов и количеством листов, а также презентацию наименование которой  и список авторов совпадает с наименованием статьи. Конференция разделена на секции. Заседания секций происходит в разных аудиториях с 9:00 до 17:00 с перерывом с 12:00 до 13:00. На представление доклада выделяется 30 минут.\n\n8. Прокат велосипедов\n\nКомпания по прокату велосипедов имеет филиалы в нескольких городах. Каждый филиал имеет парк и нескольких сотен велосипедов разных трех марок. Для аренды велосипеда клиенты используют мобильное приложение, в котором указывается имя клиента и привязанная к приложению банковская карта или электронный кошелек. Для каждого типа велосипеда существует собственная стоимость одного часа аренды, котора также зависит от города, где находится филиал. В информационной системе учитывается продолжительность аренды, стоимость услуги (после возвращения велосипеда).\n\n9. Футбольный турнир (РФПЛ)\n\nИнформационная система поддержки проведения футбольного турнира. Учёт команд, игроков, тренеров, матчей и их результатов (голы, авторы голов), стадионов, количества зрителей каждой игры.\n\n10. Пиццерия\n\nСеть пиццерий доставляет пиццы клиентам, которые заказывают их по телефону или через интернет. Имеется ограниченный набор типов пицц. Каждый тип пиццы имеет свой набор продуктов для изготовления и количество. Заказ доставляется курьером по адресу, указанному клиентом.\n\n11. Кулинарная книга\n\n\n  Рецепты\n    \n      наименование\n      описание\n      источник\n      тип\n      время приготовления\n    \n  \n  Компоненты рецепта\n    \n      компонент\n      количество\n    \n  \n  Перечень компонентов\n    \n      наименование\n      цена\n      единица измерения\n      калорийность\n    \n  \n\n\n12. Поликлиника\n\nИнформационная система сети поликлиник содержит информацию о врачах и о пациентах. Запись о каждом враче содержит: ФИО, адрес, дату рождения, паспортные данные, специальность, стаж. Информация о пациенте (посетителе): ФИО, дата рождения, номер полиса. Информационная система должна вести учет посещений (дата, врач, посетитель, диагноз).\n\n13. Сессия\n\nСтуденты, экзаменаторы (преподаватели), зачетные книжки, экзамены, зачеты.\n\n14. Расписание занятий\n\n\n  Расписание\n    \n      неделя\n      день\n      пара\n      группа\n      преподаватель\n      вид занятий\n      аудитория\n    \n  \n  Преподаватель\n    \n      кафедра\n      должность\n      ученая степень\n    \n  \n  Пара\n    \n      номер\n      время начала\n      время окончания\n    \n  \n  Аудитория\n    \n      корпус\n      номер\n    \n  \n  Группа\n    \n      номер\n      количество студентов\n    \n  \n\n\n15. Социальная сеть\n\nИзобразите диаграмму сущность связь для социальной сети ВКонтакте.\n\n16. Интернет-магазин мебели\n\nИнтернет-магазин мебели позволяет покупателю выбрать на сайте товар оплатить его, заказать при необходимости доставку товара, оплатить его на сайте (способ оплаты) или после доставки, заказать сборку товара.\n\n17. Онлайн кинотеатр\n\nВ онлайн-кинотеатре можно смотреть фильмы по подписке или покупать отдельные фильмы для просмотра в любое время или брать фильмы на прокат, для просмотра в течение одного месяца после оплаты. Подписка может быть индивидуальной или семейной на несколько пользователей (до пяти), связанных с “администратором” семьи. Каждый пользователь имеет жанровые предпочтения. Информационная система должна вести учет пользователей, их подписок, покупок, просмотренных фильмов, жанровых предпочтений.\n\n18. Бронирование авиабилетов\n\nНа сайте авиакомпании пассажир может заказать билеты для себя и еще нескольких человек для перелета из пункта А в пункт Б (может быть несколько перелетов) на определенную дату. При покупке билета для каждого пассажира указывается вес багажа и тип меню для обеда на борту самолета.\n\n19. Музыкальные альбомы\n\nКоллекция состоит из музыкальных альбомов, которые могут быть записаны на Audio CD, или на жестком диске. Каждый альбом создан одним автором (исполнителем). У каждого исполнителя может быть несколько альбомов. Каждый альбом содержит несколько треков (композиций), которые имеют определенную длину и порядок в альбоме. Каждый трек  может быть только в одном альбоме.\n\n20. Бронирование авиабилетов\n\nБаза данных рейсов хранит информацию о парке авиакомпании, рейсах и бронировании мест. У авиакомпании есть один или несколько самолетов. Самолет имеет номер модели, уникальный регистрационный номер и возможность принять одного или нескольких пассажиров. У рейса самолета есть уникальный номер рейса, аэропорт вылета, аэропорт назначения, дата и время вылета, а также дата и время прибытия. Каждый полет выполняется одним самолетом. Пассажир назвал имена, фамилию и уникальный адрес электронной почты. Пассажир может забронировать место на рейс.\n\n21. Курсы и студенты\n\nВ базе данных университета хранится информация о студентах, курсах, семестре, в котором студент проходил определенный курс (а также о его оценках, если он его закончил), а также о том, в какую программу обучения записан каждый студент.\n\nУниверситет предлагает одну или несколько программ. Программа состоит из одного или нескольких курсов. Студент должен зарегистрироваться в программе. Студент проходит курсы, которые являются частью ее программы. У программы есть название, идентификатор программы, общее количество баллов, необходимых для получения диплома, и год ее начала. У курса есть название, идентификатор курса, значение кредитной точки и год, когда он начался. Студенты имеют одно или несколько имен, фамилию, идентификатор студента, дату рождения и год, когда они впервые поступили. Когда студент проходит курс, записывается год и семестр, в котором он пытался его пройти. Когда он заканчивает курс, записывается оценка (например, A или B) и оценка (например, 60 процентов). Каждый курс в программе состоит из года (например, год 1) и семестра (например, 1 семестр).\n\n22. Компания и сотрудники\n\nВ компании есть несколько отделов. Каждый отдел имеет уникальную идентификацию, название, местонахождение офиса и конкретного сотрудника, который управляет отделом. Отдел контролирует ряд проектов, каждый из которых имеет уникальное имя, уникальный номер и бюджет. У каждого сотрудника есть имя, идентификационный номер, адрес, зарплата и дата рождения. Сотрудник назначен в один отдел, но может участвовать в нескольких проектах. необходимо вести учёт  дату начала работы сотрудника в каждом проекте, непосредственного руководителя каждого сотрудника. Необходимо хранить информацию об иждивенцах каждого сотрудника. У каждого иждивенца есть имя, дата рождения и отношения с работником.\n\n23. Галереи\n\nГалереи хранят информацию о художниках, их именах (которые уникальны), местах рождения, возрасте и стиле искусства. У каждого произведения искусства есть автор, год изготовления, название, вид произведения (например, живопись, литография, скульптура, фотография) и цена. Произведения искусства также подразделяются на группы различных видов, например, портреты, натюрморты, произведения Пикассо или произведения 19-го века; произведение может принадлежать более чем одной группе. Каждая группа идентифицируется именем, которое описывает группу. Наконец, галереи хранят информацию о клиентах. Для каждого покупателя галереи сохраняют уникальное имя, адрес, общую сумму денег, потраченных в галерее, а также художников и групп искусства, которые нравятся покупателю.\n\nby Jennifer Polack, Professor of Computer Science at University of Mary Washington\n\n24. Сеть отелей\n\nСеть отелей под названием B&amp;B состоит из множества филиалов отелей по всей стране. В каждом отеле есть различные номера. Каждый номер имеет свою цену в зависимости от типа. B&amp;B хранит информацию о своих гостях, чтобы можно было  отправлять им письма и электронные письма о специальных предложениях. Должна храниться информация о бронировании. Эта информация включает в себя дату, с которой гость забронировал номер и дату отъезда. Необходимо знать количество дней.\n\n25. Прокат автомобилей\n\nКомпания предлагает ряд моделей автомобилей на прокат. Клиент может забронировать любую модель или конкретную модель автомобиля. Бронь относится к к модели, но не к конкретному автомобилю этой модели. Когда автомобиль этой модели станет доступным, он будет проведен для клиента. Когда клиент берет автомобиль, то эта информация связывается с конкретным автомобилем, а не на моделью поскольку у компании может быть несколько автомобилей одной модели. Необходимо вести учет даны начала использования автомобиля и продолжительности.\n\n26. КХЛ\n\nВ континентальной хоккейной лиге много команд. У каждой команды есть название, город, тренер, капитан и набор игроков, каждый игрок принадлежит только одной команде. У каждого игрока есть имя, позиция (например, левое крыло или вратарь), уровень квалификации и набор записей травм. Капитан команды также игрок. Игра проводится между двумя командами (хозяева и гости) и имеет дату (например, 11 мая 1999 г.) и счет (например, от 4:2).\n\n27. Книжный онлайн-магазин\n\nВ онлайн-магазине продаются книги (включая электронные). Основные атрибуты книги: Автор, Наименование, Издатель, Количество страниц, Тип обложки, Масса (для оценки массы заказа). Покупатель выбирает книги, формирует и оплачивает заказ. Книги доставляются по указанному адресу. В одном заказе могут быть как “бумажные” книги, так и электронные. Электронные книги отправляются по электронной почте. Информационная система должна учитывать время формирования заказа, время его оплаты и время доставки.\n\n28. Мастерская\n\nМастерская производит ремонт бытовой техники разных типов (придумайте не менее трех). Клиент привозит неисправную технику и оформляет факт передачи техники с указанием ее необходимых свойств. После приема техники мастер (определенный сотрудник мастерской) в течение трех дней оценивает сложность ремонта и формирует список заменяемых частей и список действий (например: разборка и сборка, работа по замене экрана), которые определяют стоимость ремонта. Клиента уведомляют о стоимости ремонта и получают согласие на дальнейшие действия после первичного анализа (диагностики). Ремонт может быть выполнен “по гарантии”, в этом случае стоимость ремонта клиентом не оплачивается.\n\n29. Мастерская\n\nИнформационная система ЖЭКа обслуживает группу домов на нескольких улицах. Заявка поступает от квартиры. Заявку принимает диспетчер, он задает номер и дату поступления заявки, определяет тип заявки и срок ее выполнения. Заявку выполняет бригада специалистов. Каждый специалист может работать только в одной бригаде, у каждой бригады есть бригадир.\n\n30. Парки\n\nИнформационная система “Парки города” хранит информацию о парках. Каждый парк имеет собственное имя. В парке высажены определённые насаждения. База данных должна хранить информацию о количестве насаждений каждого типа. В парке могут находиться фонтаны и павильоны.\n\nАтрибуты парка:\n\n  наименование,\n  площадь,\n  плотность посадки,\n  место нахождения (адрес).\n\n\nНасаждениях парка\n\n  тип культуры,\n  наименование,\n  средняя продолжительность жизни.\n\n\nФонтан\n\n  шифр,\n  дата постройки,\n  расход воды (максимальный и нормальный),\n  площадь.\n\n\nПавильон\n\n  наименование,\n  тип (кафе, продуктовый, развлекательный, прокат вещей),\n  занимаемая площадь.\n\n\n",
      "url": "/pages/databases/lab_er/"
    },{
      
      "title": "Относительное орбитальное движение",
      
      "content": "Разработать программу для построения траектории движения наноспутника, отделившегося от орбитальной станции. Траекторию движения наноспутника необходимо построить в орбитальной подвижной системе координат, связанной со станцией. Станция движется по круговой орбите высотой \\(h=350\\) км. Ось \\(x _o\\) орбитальной подвижной системы координат направлена от Земли вдоль радиус вектора станции. Ось \\(y_o\\) лежит в плоскости орбиты и направлена в сторону орбитальной скорости станции. Ось \\(z_o\\) дополняет систему координат до правой.\n\n\n  Построить траекторию движения наноспутника №1 относительно станции на интервале её двух орбитальных периодов при отделении наноспутника со  скоростью 1 м/с и при угле отделения \\(\\alpha=+85\\) градусов.\n  Построить траекторию движения наноспутника №2 относительно станции на интервале её двух орбитальных периодов при отделении наноспутника со  скоростью 1 м/с и при угле отделения \\(\\alpha=-85\\) градусов.\n  Построить график изменения расстояния между наноспутниками, полагая, что они отделяются одновременно.\n  Возможно ли столкновение спутников при заданном направлении их отделения? Если да, то предложите изменение в условиях отделения спутников (скорость, направление), при которых опасное сближение между спутниками и между каждым спутником и станцией на расстояние меньше чем 2 км в течение первых 4 орбитальных периодов станции не происходит.\n\n\n\n\nМетодические указания\n\nДвижение наноспутника относительно станции в орбитальной подвижной системе координат, связанной со станцией, предполагая, что расстояние между станцией и наноспутником значительно меньше, чем расстояние от станции до центра Земли, описывается следующими уравнениями:\n\n[\\boldsymbol x = \n\t\\begin{bmatrix}\n\t\t4-3c &amp; 0 &amp; 0 &amp; s/n &amp; 2/n-2c/n &amp; 0 \n\t\t-6nt+6s &amp; 1 &amp; 0 &amp; -2/n + 2c/n &amp; 4s/n - 3t &amp; 0 \n\t\t0 &amp; 0 &amp; c &amp; 0 &amp; 0 &amp; s/n \n\t\t3ns &amp; 0 &amp; 0 &amp; c &amp; 2s &amp; 0 \n\t\t-6n +6nc &amp; 0 &amp; 0 &amp; -2s &amp; -3+4c &amp; 0 \n\t\t0 &amp; 0 &amp; -ns &amp; 0 &amp; 0 &amp; c \n\t\\end{bmatrix} \\boldsymbol x(0)]\n\nгде \\(s = \\sin nt, \\, c = \\cos nt\\), \\(n\\) – угловая скорость орбитального движения станции:\n\n[n = \\sqrt{\\frac{\\mu}{r^3}}]\n\n\\(r\\) – радиус круговой орбиты станции, \\(\\mu = 398600.448\\) км\\(^3\\)/c\\(^2\\) – гравитационный параметр Земли, \\(\\boldsymbol x\\) – вектор состояния наноспутника:\n\n[\\boldsymbol x = \\begin{bmatrix} x \\ y \\ z \\ \\dot x \\ \\dot y \\ \\dot z \\end{bmatrix}, \\quad]\n\n\\(\\boldsymbol x(0)\\) – вектор начального состояния наноспутника:\n\n[\\boldsymbol x(0) = \\begin{bmatrix} x(0) \\ y(0) \\ z(0) \\ \\dot x(0) \\ \\dot y(0) \\ \\dot z(0) \\end{bmatrix}]\n\nВерсия функции для аргумента t - скаляра:\n\n\nfunction x = get_orbital_state(x0, n, t)    \n%x = get_orbital_state(x0, n, t) \n% x0 - 6x1 [x0;y0;z0;vx0;vy0;vz0] - начальное положение и скорость м, м/с\n% n  - 1x1 угловая скорость орбитального движения станции рад/с\n% t  - 1x1 время \n    c   = cos(n*t);\n    s   = sin(n*t);\n   \n    A  = [4-3*c 0 0 s/n 2/n-2*c/n 0;\n          -6*n*t+6*s 1 0 -2/n+2*c/n  4*s/n-3*t 0;\n          0 0 c 0 0 s/n;\n          3*n*s 0 0 c 2*s 0; \n          -6*n+6*n*c 0 0 -2*s -3+4*c 0;\n          0 0 -n*s 0 0 c];\n    \n    x  = A*x0;\n    \nend\n\n\n\n",
      "url": "/pages/matlab/lab_hill_frame/"
    },{
      
      "title": "Лабораторная работа 5. Основы работы в MongoDB",
      
      "content": "Цель работы\n\nЗнакомство с нереляционной документоориентированной СУБД MongoDB. Работа с БД из среды Python.\n\nЗадание\n\n\n  Создать подключение к СУБД Mongodb,\n  Создать коллекцию документов.\n  Написать пример документа в формате json из предметной области лабораторных работ 2 и 3.\n  Добавить в коллекцию четыре различных документа.\n  Вывести список документов в коллекции со всеми атрибутами, выполнив запрос к базе данных.\n  Вывести основные атрибуты части документов коллекции, удовлетворяющих некоторому условию (использовать условия «меньше», «больше»)\n\n\nПримеры документов\n\n\n  Библиотека. Читательский билет с записями о книгах, находящихся у читателя.\n  Аптека. Товарный чек с информацией о купленных лекарствах.\n  Больница. Информация о лечении: пациент, врач, дата начала, дата окончания, виды лечения (список).\n  Предприятие. Информация о сотруднике и истории его назначений.\n  Курьерская доставка. Информация о посылке: отправитель (Ф.И.О., адрес отправления, паспортные данные), получатель (Ф.И.О, адрес получения, паспортные данные), масса и габариты посылки, информация о курьере и датах отправления и получения.\n  Повышение квалификации. Список курсов университета: Даты проведения, информация о преподавателе, наименование, количество часов, записанные на курсы сотрудники (до 3).\n  Научная конференция. Программа конференции: дата и наименование конференции, несколько секций со списком статей в каждой секции.\n  Прокат велосипедов. Информация об использовании велосипеда: дата начала, дата окончания, марка (тип), информация о клиенте, стоимость.\n  Футбольный турнир (РФПЛ). Игры: команда 1, основной состав (достаточно указать 3 игроков), команда 2, основой состав (достаточно указать 3 игроков), счет, информация о голах.\n  Пиццерия. Информация о пиццерии со списком продаваемых пицц.\n  Кулинарная книга. Рецепт.\n  Поликлиника. Информация о посещениях: дата, врач, посетитель, диагноз.\n  Сессия. Результаты экзаменов с указанием информации о преподавателе и списке студентов с оценками (до 5 студентов).\n  Расписание занятий. Расписание занятий на 1 день (для нескольких групп)\n  Социальная сеть. Изобразите диаграмму сущность связь для социальной сети Сообщения с главной страницы: дата, текст, комментарии (автор, текст).\n  Интернет-магазин мебели. Товарный чек с информацией о товарах, покупателе и магазине.\n  Онлайн кинотеатр. Информация о пользователе: Имя, предпочтения, список просмотренных фильмов (жанр, наименование, дата просмотра, длительность).\n  Бронирование авиабилетов. Информация о заказанных билетах: пункт А в пункт Б,  дата, вес багажа, тип меню.\n  Музыкальные альбомы. Музыкальные альбомы.\n  Бронирование авиабилетов. Брони.\n  Курсы и студенты. Проекты: дата начала и окончания, информация о сотрудниках в проекте (до трех): имя, идентификационный номер, адрес, зарплата и дата рождения.\n  Галереи. Несколько групп со списком произведений в каждой группе.\n  Сеть отелей. Информация об истории бронирования номеров: дата начала, окончания, список постояльцев, стоимость.\n  Прокат автомобилей. Список автомобилей с историей их использования.\n  КХЛ. Информация об играх: команда 1, основной состав (достаточно указать 3 игроков), команда 2, основой состав (достаточно указать 3 игроков), счет, информация о голах.\n  Книжный онлайн-магазин. Товарный чек.\n  Мастерская. Коллекция документов с информациях о заказах: дана начала и окончания, имя мастера, имя клиента, техника, ее вид, список работ.\n  ЖЭК. Список заявок: дана начала и окончания работ, адрес клиента, бригада специалистов со списком специалистов.\n  Парки. Информация о трех парках, с указанием наименования, площади, место адреса и списка павильонов (до трех): наименование, тип (кафе, продуктовый, развлекательный, прокат вещей), занимаемая площадь.\n\n\nМетодические рекомендации\n\nИмя пользователя и пароль совпадают с именем и паролем для подключения к СУБД MySQL в лабораторной работе 3. Имя базы данных совпадает с именем пользователя.\n\nДокумент в формате json\n\n{\nid: 1155151,\ndate: \"2020-05-20\",\nbuyer: \"Луаврик Л. Луаврик\",\nitems: [\n\t\t{\n\t\tcode: 41155415,\n\t\tname: \"256 ГБ SSD-накопитель Transcend 230S\",\n\t\tprice: 4750.00\n\t\t},\n\t\t{\n\t\tcode: 115521856,\n\t\tname: \"Зеркальная камера Nikon D3500 Kit 18-140mm VR AF-S\",\n\t\tprice: 48000.00\n\t\t}\t\n\t\t],\ntotal: 52750.00,\npayment_type: \"наличные\"\n}\n\n",
      "url": "/pages/databases/lab_nosql/"
    },{
      
      "title": "Движение спускаемого аппарата в атмосфере",
      "description": "Простейшая плоская модель движения СА в атмосфере (Nguyen X. Vinh, Adolf Busemann, Robert D. Culp Hypersonic and planetary entry flight mechanics) The Unevrsity of Michigan Press\n",
      "content": "Уравнения движения\n\nСпускаемый аппарат (СА) рассматривается как материальная точка, движущаяся под действием гравитационного поля Земли и аэродинамической силы. Уравнения движения имеют вид:\n\n[\\frac{dV}{dt} = - \\frac{C_d S_m q}{m} - g \\sin \\theta,]\n\n[V \\frac{d \\theta}{dt} = \\frac{C_l S_m q}{m} - \\left(g-\\frac{V^2}{r}\\right) \\cos \\theta,]\n\n[\\frac{dr}{dt} = V \\sin \\theta]\n\nгде \\(V\\) - скорость СА; \\(\\vartheta\\) – угол наклона траектории (угол между вектором скорости и линией местного горизонта); \\(r\\) – расстояние от центра Земли до центра масс СА; \\(g\\) – ускорение свободного падения на высоте \\(h\\); \\(m\\) – масса СА; \\(S_m\\) – характерная площадь (площадь Миделя); \\(C_d\\) – аэродинамический коэффициент лобового сопротивления; \\(C_l\\) – аэродинамический коэффициент подъёмной силы; \\(q\\) – скоростной напор, зависящий от плотности воздуха и скорости движения СА:\n\n[q = \\frac{\\rho V^2}{2}]\n\nКод на языке Python\n\nПодключение необходимых библиотек\n\nfrom collections import namedtuple\nimport scipy\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\nМодель изменения плотности воздуха в диапазоне от 0 до 100 км с погрешностью 1,5% (В. А. ЯРОШЕВСКИЙ “АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ” Ученые записки ЦАГИ, т. XL, №3, 2009.)\n\na  = np.array([-6.3759,-7.3012,-1.1817])\nb  = np.array([-0.4754,-0.0096,-0.0068,-0.0120,0.0042]);\nc  = np.array([ 0.1803, 0.0872,-0.0153, 0.0145,0     ]);\n\ndef rho(h):\n  # Функция вычисления плотности воздуха \n  # высота h задаётся в километрах\n  # результат -- плотность кг/м3\n  x = h/50.0-1\n  sa = a[0] + a[1]*x + a[2]*x*x\n  sbc= sum( (b[i]*np.cos((i+1)*np.pi*x) + c[i]*np.sin((i+1)*np.pi*x) for i in range(5)) ) \n  return np.exp(sa + sbc)\n\n\nКонстанты\n\n# Гравитационный параметр Земли\nmu = 398600.4415e9\n# Радиус Земли\nRe = 6371000.0\n\n\nФункция вычисления ускорения свободного падения м/с\\(^2\\) на высоте h (в метрах)\n\ndef g_acc(h):\n  # \n  return mu/(Re+h)**2\n\n\nФункция правых частей\n\nФункция правых частей дифференциальных уравнений: вычисление правых частей дифференциальных уравнений для\nмомента времени t и вектора состояния y = [r(t), v(t), theta(t)]:\n\ndef dydt(t, y, p):  \n\n  # Радиус-вектор точки в момент времени t\n  r     = y[0]\n  # Скорость  в момент времени t \n  v     = y[1]\n  # Угол наклона траекториии  в момент времени t  \n  theta = y[2]\n    \n  # Высота (км)\n  h     = (r - Re)*0.001\n  # Скоростной напор Н/м^2\n  q     = rho(h)*v*v/2  \n  # Ускорение свободного падения\n  g     = g_acc(r - Re)\n    \n  # dv/dt =   \n  dv    = - q*p.CD*p.Sm/p.mass - g*np.sin(theta) \n  # dtheta/dt =   \n  dtheta= (q*p.CL*p.Sm/p.mass - (g - v*v/r)*np.cos(theta))/v\n  # dr/dt =    \n  dr    = v*np.sin(theta) \n  # ds/dt\n  ds    = (Re/r)*v*np.cos(theta)\n  \n  return (dr,dv,dtheta,ds)\n\n\nФункция для остановки процесса интегрирования при достижении нулевой высоты\n\ndef event_h_eq_0(t, y):\n  # Функция-\"детектор\", передаваемая в интегратор (параметр events), \n  # для определения времени достижения нулевой высоты и \n  # остановки процесса интегрирования  \n  \n  return y[0]-Re  \n\n# функция определяется условие h = 0 при движении \"вниз\"\nevent_h_eq_0.direction = -1\n# функция-детектор активна\nevent_h_eq_0.terminal  = True  \n# функция возвращает высоту  \n\n\nПараметры системы\n\nparams = namedtuple(\"params\", \"CD CL mass\")\n# Масса тела\nparams.mass = 60000.0 \n# Аэродинамические коэфиициенты, \n# которые в общем случае зависят от числа Маха, \n# угла атаки\nparams.CD   = 1.4    # Коэффицент лобового сопротивления \nparams.CL   = 0.0    # Коэффицент подъёмной силы\n# Площадь миделя\nparams.Sm   = np.pi*3**2/4     \n\n\nНачальные условия\n\n# Начальные условия\nh0     = 120e3 # Начальная высота [м]\nv0     = 2800 # Начальная скорость [м/c]\ntheta0 = np.deg2rad(30.0)  # начальный угол наклона траектории [радиан]\n\n\nЗапуск процесса интегрирования\n\nsol = solve_ivp(lambda t,y: dydt(t,y,params), [0, 1000.0], [Re+h0, v0, theta0, 0], method='LSODA', events = [event_h_eq_0], rtol = 1e-9)\n\n\nРезультаты\n\nГрафик изменения высоты от времени\n\nplt.plot(sol.t,(sol.y[0]-Re)*0.001);\nplt.xlabel('t, c');plt.ylabel('h, км');\n\n\nЗависимость скоростного напора от высоты\n\nplt.plot((sol.y[0]-Re)*0.001,0.001*rho((sol.y[0]-Re)*0.001)*sol.y[1]*sol.y[1]/2.0);\nplt.xlabel('h, км');plt.ylabel('q, кН/м$^2$');\n\n\nПример кода на языке Python (в Google Colab)\n",
      "url": "/pages/matlab/lab_reentry/"
    },{
      
      "title": "Контрольная работа №1",
      "description": "Задание для 1 контрольной лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "В первых двух заданиях код должен работать для любых размеров исходных массивов или матриц (двумерных массивов). Например, в задании 2 код с решением должен работать для двумерного массива (матрицы) Y с любым количеством строк и столбцов.\n\nВ задании 3 необходимо составить скрипт для вычисления значения функции, разложенной в ряд (сумму ряда). В формулах \\(\\varepsilon\\) – заданная степень точности; \\(n\\) – порядковый номер очередного члена ряда. Функцию оформить в виде файл-функции, которой передается значение \\(x\\) (или \\(\\phi\\)), требуемая точность \\(\\varepsilon\\) и необходимое число параметров, если функция от них зависит.\n\nВариант 1\n\n\n  Дан массив из N натуральных чисел. Вывести те числа, остаток от деления которых на М равен L (0 ≤ L ≤ M-1).\n  Задан двумерный массив С из 4-х строк и 4-х столбцов (квадратная матрица). Составить программу подсчёта суммы всех отрицательных элементов и суммы элементов по главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(1/n \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[Y = 1 - \\frac{1}{2} + \\frac{1}{3} - \\frac{1}{4} + … + {( - 1)^{n + 1}}\\frac{1}{n} + …]\n\nВариант 2\n\n\n  При поступлении в вуз абитуриенты, получившие «двойку» на первом экзамене, ко второму не допускаются. В массиве A[n] записаны оценки экзаменующихся, полученные на первом экзамене. Подсчитать, сколько человек не допущено ко второму экзамену.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу подсчёта суммы произведений элементов строк.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| a^n \\cos n \\phi \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.005\\):\n\n\n[F(a,\\phi ) = 1 + (a \\cdot \\cos \\phi  + {a^2} \\cdot \\cos 2\\phi  + {a^3} \\cdot \\cos 3\\phi  + …\n… + {a^n} \\cdot \\cos n\\phi  + …)]\n\nВариант 3\n\n\n  Дана массив чисел, среди которых имеется один нуль. Вывести на печать все числа включительно до нуля.\n  Задан двумерный массив А из 5-и строк и 2-х столбцов. Составить программу, которая формирует одномерный массив В, каждый элемент которого есть произведение элементов массива А в строке.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(1/(2n-1)^2 \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[Y = \\frac{1}{1^2} + \\frac{1}{3^2} + \\frac{1}{5^2} + … + \\frac{1}{(2n - 1)^2} + …]\n\nВариант 4\n\n\n  В одномерном массиве размещены: в первых элементах значения аргумента, а в следующих – соответствующие им значения функции. Напечатать элементы этого массива в виде двух параллельных столбцов: аргументы и значения функции.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, элементы главной диагонали  которого равны соответствующим элементам исходного массива, а остальные элементы равны нулю.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\|\\frac{x^{2n - 1}}{(2n - 1)!} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + … + (-1)^{n-1} \\frac{x^{2n - 1}}{(2n - 1)!} + …]\n\nВариант 5\n\n\n  Дан целочисленный массив с количеством элементов N. Напечатать те его элементы, индексы которых являются степенями двойки (1, 2, 4, 8, 16, …).\n  Задан двумерный массив А из 2-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов исходного в столбце.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\|\\sin (2n-1)x/(2n-1) \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F ( x ) = \\frac{4a}{\\pi} ( \\sin x + \\frac{\\sin 3x}{3} + … + \\frac{\\sin (2n - 1)x}{2n - 1} + … )]\n\nВариант 6\n\n\n  Дан массив из N действительных чисел. Напечатать те его элементы, которые принадлежат отрезку [c, d].\n  Задан двумерный массив Y из 5-и строк и 5-и столбцов. Составить программу подсчёта суммы всех положительных элементов и суммы элементов по главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| x^{n-1}\\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = 1 - x + {x^2} - {x^3} + {x^4} - …. \\pm {x^{n - 1}} + …]\n\nВариант 7\n\n\n  Дан массив целых положительных чисел. Найти произведение только тех чисел, которые больше заданного числа М. Если таких нет, то выдать сообщение об этом.\n  Задан двумерный массив А из 4-х строк и 4-х столбцов. Составить программу, которая подсчитывает произведение элементов массива, лежащих вне главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| x(x-1)^n \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[Y\\left( x \\right) = x + \\left[ x\\left( x - 1 \\right) + x \\left( x - 1 \\right)^2 + … + x \\left( x - 1 \\right)^n + … \\right]]\n\nВариант 8\n\n\n  Массив из N элементов состоит из нулей и единиц. Поставить в начало этого массива нули, а затем единицы.\n  Задан двумерный массив С из 6-и строк и 6-и столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{\\sin (n + 1)x}{(2n - 1)} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F(x) = \\frac{\\sin 2x}{1} - \\frac{\\sin 3x}{3} + … + (-1)^{n - 1} \\cdot \\frac{\\sin (n + 1)x}{(2n - 1)} …]\n\nВариант 9\n\n\n  Дан массив из N действительных чисел, в котором есть только положительные и отрицательные элементы. Вычислить произведение отрицательных элементов P1 и произведение положительных элементов P2. Сравнить модуль P2 с модулем P1 и указать, какое из произведений по модулю больше.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу, которая вычисляет значение суммы произведений элементов строк\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{x^n}{n!} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + … + \\frac{x^n}{n!} \\right)]\n\nВариант 10\n\n\n  Задан массив с количеством элементов N. Сформируйте два массива: в первый включите элементы исходного массива с чётными номерами, а во второй – с нечётными.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов в столбце. Вычислить произведение элементов полученного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{\\sin nx}{n} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F(x) = 2 \\left[ \\sin x - \\frac{\\sin 2x}{2} + … + (-1)^{n - 1}\\frac{\\sin nx}{n}… \\right]]\n\nВариант 11\n\n\n  Составить программу нахождения наибольшего среди тех элементов одномерного массива А, что лежат в интервале [С, D].\n  Задан двумерный массив А из 5-и строк и 4-х столбцов. Составить программу, которая вычисляет значение произведения сумм строк.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{(2x)^n}{n!} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[S\\left( x \\right) = \\frac{2x}{1!} + \\frac{2^2}{x^2}{2!} + \\frac{2^3 x^3}{3!} + … + \\frac{(2x)^n}{n!} + …]\n\nВариант 12\n\n\n  Составить программу отыскания наименьшего среди тех элементов одномерного массива А, что лежат вне интервала [С, D].\n  Задан двумерный массив Y из 4-х строк и 4-х столбцов. Составить программу, которая вычисляет S – сумму элементов побочной диагонали и значение суммы всех элементов массива\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{x^n}{n} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x}{1} + \\frac{x^2}{2} + … + \\frac{x^n}{n} + … \\right)]\n\nВариант 13\n\n\n  Составить программу подсчёта среди элементов одномерного массива В количества чисел, больших С.\n  Задан двумерный массив С из 6-и строк и 3-х столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие не на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С Вычислить произведение всех элементов нового массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{a \\cos nx}{a^2 - n^2} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F(x) = \\frac{1}{2a} - \\left[ \\frac{a \\cos x}{a^2 - 1} - \\frac{a \\cos 2x}{a^2 - 2^2} + …(-1)^{n-1} \\cdot \\frac{a \\cos nx}{a^2 - n^2} + … \\right]]\n\nВариант 14\n\n\n  Составить программу отыскания наименьшего среди элементов одномерного массива А и его индекса.\n  Задан двумерный массив А из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть произведение элементов массива А в каждой строке. Затем вычислить сумму элементов полученного одномерного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{n}{2^n} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[Y = \\frac{1}{2} + \\frac{2}{2^2} + \\frac{3}{2^3} + … + \\frac{n}{2^n} + …]\n\nВариант 15\n\n\n  Задан массив Y с количеством элементов N. Сформируйте массив, в котором элементы с чётными индексами будут равны соответствующим элементам исходного массива, а элементы с нечётными индексами будут равны нулю.\n  Задан двумерный массив C из 3-х строк и 5-и столбцов. Составить программу, которая вычисляет произведение всех элементов массива. Затем организовать новый массив С, в котором значения элементов, лежащих на главной диагонали, равны 1, а остальные элементы равны квадрату соответствующих элементов исходного массива С.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{\\cos nx}{n^2} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = \\frac{\\pi }{2} - \\frac{4}{\\pi }\\left( \\cos x + \\frac{\\cos 2x}{2^2} + \\frac{\\cos 3x}{3^2} + … + \\frac{\\cos nx}{n^2} + … \\right)]\n\nВариант 16\n\n\n  Составить программу подсчёта в одномерном массиве А суммы элементов с чётными индексами и суммы элементов, значения которых больше нуля.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая вычисляет сумму всех элементов массива. Затем организовать новый массив В, в котором заменить отрицательные элементы исходного массива на 1, а значения остальных элементов оставить без изменения. Подсчитать количество замен.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{x^{2n - 1}}{2n - 1} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\frac{x^7}{7} + … + \\left({-1}\\right)^{n-1} \\cdot \\frac{x^{2n - 1}}{2n - 1} + …]\n\nВариант 17\n\n\n  Составить программу подсчёта в одномерном массиве С количества отрицательных и произведения положительных элементов массива.\n  Задан двумерный массив А из 8-и строк и 3-х столбцов. Составить программу, которая подсчитывает общее число неотрицательных элементов в массиве. Затем организовать формирование нового массива В, в котором значения элементов исходного массива заменить на противоположные по знаку.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{\\sin (n + 1)x}{2n + 1} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F(x) =  - \\frac{1}{2}\\left[ \\frac{\\sin 2x}{3} + \\frac{\\sin 3x}{5} + … + \\frac{\\sin (n + 1)x}{2n + 1} + … \\right]]\n\nВариант 18\n\n\n  Составить программу подсчёта в одномерном массиве В произведения элементов с нечётными индексами и суммы отрицательных элементов.\n  Задан двумерный массив В из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив С, элементы которого равны количеству положительных элементов в строке исходного массива В.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{1}{2^{n - 1}} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[Y = 1 - \\frac{1}{2} + \\frac{1}{4} - \\frac{1}{8} + … + {( - 1)^{n - 1}} \\cdot \\frac{1}{2^{n - 1}} + …$]\n\nВариант 19\n\n\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с чётными индексами в массиве А и суммы элементов, значения которых больше нуля, в массиве В.\n  Задан двумерный массив D из 5-и строк и 5-и столбцов. Составить программу, которая организует одномерный массив, элементы которого равны элементам массива D , лежащим на побочной диагонали, а затем вычисляет сумму элементов полученного одномерного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{\\sin nx}{2^n} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[$F(x) = \\frac{\\sin x}{2} + \\frac{\\sin 2x}{2^2} + … + \\frac{\\sin nx}{2^n} + …$]\n\nВариант 20\n\n\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с нечётными индексами в массиве B и произведения отрицательных элементов в массиве А.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая подсчитывает количество положительных, отрицательных и нулевых элементов в массиве В и организует одномерный массив из полученных значений.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия \\(\\| \\frac{x^{2n}}{\\left(2n\\right)!} \\| \\leq \\varepsilon\\), \\(\\varepsilon = 0.001\\):\n\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x^2}{2!} + \\frac{x^4}{4!} + \\frac{x^6}{6!} + … + \\frac{x^{2n}}{\\left(2n\\right)!} + … \\right)]\n\nИз сборника: Е.А. Симановский “Сборник заданий к лабораторным работам”.\n",
      "url": "/pages/matlab/lab_test1/"
    },{
      
      "title": "Сборник задания для лабораторных работ",
      "description": "Сборник заданий для лабораторных работ ко второй части курса “Интегрированные математические пакеты”.\n",
      "content": "\n  Относительное орбитальное движение\n  Матрицы\n  Интегрирование дифференциальных уравнений\n  Интегрирование дифференциальных уравнений системы с двумя степенями свободы. Приведение уравнений к форме Коши\n  Движение спускаемого аппарата в атмосфере.\n  Орбитальное движение\n  Движение наноспутника внутри транспортно-пускового контейнера\n\n",
      "url": "/pages/matlab/labs/"
    },{
      
      "title": "Лабораторные работы",
      "description": "Задания для лабораторных работ по курсу Технологии и языки программирования.\n",
      "content": "Семестр 1\n\n\n  Задание 1\n  Задание 2 (игра Жизнь)\n  Задание 3 (списки)\n  Задание 4 (игра Жизнь)\n  Задание 5 (игра Жизнь)\n\n\nСеместр 2\n\n\n  Задание 1\n  Задание 2\n  Задание 3\n  Задание 4\n  Задание 5\n\n",
      "url": "/pages/python/labs/"
    },{
      
      "title": "Лабораторные работы",
      "description": "Лабораторные работы к курсу Динамика твёрдого тела и систем тел\n",
      "content": "Семестр 1\n\n\n  Ортогональные матрицы\n  Кватернионы\n  Тензор инерции\n  Движение системы точек. Численное интегрирование\n  Движение твердого тела\n\n\nСеместр 2\n\n\n  \n  \n  \n\n",
      "url": "/pages/mbs/labs/"
    },{
      
      "title": "Построение годографа единичного вектора продольной оси тела при движении в случае Лагранжа",
      "description": "Динамика твёрдого тела и систем тел\n",
      "content": "Рассматривается движение твёрдого тела в случае Лагранжа. Необходимо построить годограф продольной оси тела (\\(Oz_2\\)).\n\n\n\nclear all;\n% Параметры тела\nm   = 4;    % Масса тела\nJxy = 0.5;  % Поперечный момент инерции\nJz  = 1;    % Продольный момент инерции\ns   = 0.5;  % Расстояние от точки опоры до центра масс\ng   = 9.807;% Ускорение свободного падения\n\n% Начальные условия\ntheta0 = 0.7;   dtheta0 = 0.0;\npsi0   = 0;     dpsi0   = 0.0;\nphi0   = 0;     dphi0   = 10;\n\n% Угловые скорости\nwx      =   dtheta0;\nwy      =   dpsi0*sin(theta0);\nwz      =   dphi0+dpsi0*cos(theta0);\n\n% Интегралы энергии и кинетического момента\nE       = 0.5*(Jxy*(wx^2+wy^2)+Jz*wz^2+2*m*g*s*cos(theta0));\n% Проекция веткора кинетического момента на направление вертикали\nL       = Jxy*dpsi0*sin(theta0)^2+Jz*wz*cos(theta0);\n\n\nКоэффициенты полинома относительно u (13)\n\ncoeff_dotu2  = [2*m*g*s/Jxy, -(2*E-Jz*wz^2)/Jxy-Jz^2*wz^2/Jxy^2,...\n    -2*m*g*s/Jxy+2*Jz*wz*L/Jxy^2, (2*E-Jz*wz^2)/Jxy-L^2/Jxy^2];  \n\n\nКорни полинома, отсортированные по возрастанию\n\nu = sort(roots(coeff_dotu2));\n\n\n\\(k^2\\) в выражении (16)\n\nk2 = (u(2)-u(1))/(u(3)-u(1));\n\n\nКоэффициент масштаба времени \\(\\tau\\) (18)\n\ntau_k = sqrt((u(3)-u(1))*m*g*s/Jxy);\n\n\nРешения для углов и их производных. Угол нутации \\(\\theta\\):\n\ntheta = @(t) acos(u(1)+(u(2)-u(1))*ellipj(tau_k*t,k2).^2);\n\n\nУгловая скорость прецессии \\(\\dot \\psi\\) и угол прецессии \\(\\psi\\):\n\ndpsi  = @(t) (L-Jz*wz*cos(theta(t)))./(Jxy*(1-cos(theta(t)).^2));\npsi   = @(t) integral(dpsi,0,t);\n\n\nУгловая скорость собственного вращения \\(\\dot \\varphi\\)\n\ndphi  = @(t) wz-dpsi(t)*cos(theta(t));\n\n\nГрафик изменения угла нутации\n\nfplot(@(t) theta(t),[0, 1]);\nxlabel('t, c'); \nylabel('\\theta, градус');\n\n\n\n\nФормируем массив значений моментов времени для построения графика.\n\ntime_array = (0:0.01:3)';\n\n\nПри помощи функции arrayfun вызываем функцию psi(t) для каждого элемента массива time_array. Такой способ формирования массива значений угла \\(\\psi\\) обусловлен тем, что функция integral, используемая для определения функции psi(t), не принимает только скалярные значение пределов интегрирования.\n\npsi_array = arrayfun(psi,time_array);\n\n\nЗначения углов \\(\\theta\\) может\n\ntheta_array = theta(time_array);\n\n\nКоординаты точек годографа единичного вектора, направленного по продольной оси тела:\n\ngodograph = [sin(theta_array).*sin(psi_array), ...\n            -sin(theta_array).*cos(psi_array), ...\n            cos(theta_array)];\n\n\nСтроим график:\n\nplot3(godograph(:,1), godograph(:,2), godograph(:,3),'r-','LineWidth',2);\n\nhold on;\n[xs,ys,zs] = sphere(64);\nsf = surf(xs,ys,zs); \nsf.EdgeColor = 'none';\nsf.FaceColor =[0.8 0.8 0.8];\nsf.FaceAlpha = 0.8;\nhold off;\n\nxlim([-1 1]); ylim([-1 1]); zlim([-1 1]);\nbox on; \ndaspect([1 1 1]);\n\n\n\n",
      "url": "/pages/mbs/lagrange_case/"
    },{
      
      "title": "Алгоритм Ли",
      
      "content": "\n  Написать программу, иллюстрирующую работу алгоритма поиска кратчайшего пути на планарном графе.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nАлгоритм Ли\n\nСписок заданий\n",
      "url": "/pages/python/course_works/lee/"
    },{
      
      "title": "Ссылки",
      
      "content": "Космонавтика\n\nLunar Constants and Models Document\n\nКосмический мусор\n\nПараметры орбит высокоорбитальных объектов (ПАО “МАК “Вымпел”)\n",
      "url": "/pages/links/"
    },{
      
      "title": "Задания",
      "description": "Задания для курсовой работы\n",
      "content": "Задания\n\n\n  Игра жизнь\n  Многоугольник и точка\n  Колонизация\n  Лунолёт\n  Ломаная линия\n  Город\n  Анализ текста\n  Алгоритм Ли\n  Треугольники\n  Двухимпульсный перелет\n  TLE элементы\n  Выпуклая оболочка\n  Лабиринт\n  Шифр Виженера\n  Задача Прима-Краскала\n  Пересечение многоугольников\n  Экзаменационные билеты\n  Дубли файлов\n  Кратчайший путь\n\n\nТребования к оформлению курсовой работы\n\n\n  Пояснительная записка должна быть оформлена в соответсвии с СТП\n  Текст программы с комментариями помещается в приложение.\n  В пояснительной записке должен быть изложен алгоритм решения задачи, приведены блок-схемы.\n  Разрабатываемая программа должна состоять не менее чем из двух модулей: из главного (исполняемого) модуля, который использует функции и данные второго модуля, необходимые для решения задачи.\n\n\n",
      "url": "/pages/python/course_works/list/"
    },{
      
      "title": "Лунолёт",
      "description": "Диалоговая игра Лунолёт\n",
      "content": "Космический корабль в начальный момент времени находится на высоте \\(h\\) от поверхности Луны.\n\nПрограмма выводит высоту полета, скорость (со знаком плюс или минус) и массу оставшегося топлива:\n\n--------------------\nВремя     :  20 c\nВысота    :  1063 м\nСкорость  : -10.3 м/с\nТопливо   :  100 кг\nМасса КА  :  1000 кг\n--------------------\nВведите массу топлива и время работы двигателя:\n\n\nКорабль управляется при помощи задания расхода топлива за заданное время, т.е. необходимо ввести через запятую или пробел два числа: количество топлива и время его расходования, например, 50 кг за 5 секунд:\n\n50 5\n\n\nПо умолчанию тяга двигателя корабля направлена вверх. Если необходимо направить силу тяги вниз, то необходимо перед массой топлива написать символ “-“\n\n-50 5\n\n\nПерегрузка корабля при работе двигателя не должна превышать предельного значения - 5 единиц. Если перегрузка превысит это значение, то считается, что корабль остается неуправляемым в течение 10 секунд.\n\nНеобходимо посадить корабль на поверхность Луны со скоростью не более 3 м/с, имея ограниченный запас топлива на борту.\n\nПосле окончания игры (посадки) программа должна выводить график изменения скорости и высоты c указанием интервалов манёвров и расхода топлива на каждый маневр.\n\nМодель движения\n\nПусть в момент времени \\(t_i\\) посадочный модуль имеет скорость \\(v_i\\) и находится на высоте \\(h_i\\) от поверхности Луны. Тогда после расходования \\(\\Delta m\\) кг топлива за \\(\\Detla t\\) секунд, т.е. через \\(t_{i+1} = t_{i} + \\Delta t\\) высота посадочного модуля над поверхностью Луны будет определяться:\n\n[h_{i+1} = h_i - \\frac{g \\Delta t^2}{2} + \\cdot u \\ln \\left(1 - \\Delta m/m_i \\right) \\Delta t + u \\Delta t + \\cdot v_i \\Delta t + \\frac{m_i}{\\Delta m} u \\ln (1-\\Delta m/m_i) \\Delta t]\n\nгде \\(g\\) – ускорение свободного падения на Луне, \\(u \\approx 3000\\) м/с - скорость истечения продуктов сгорания двигателя.\n\nСкорость:\n\n[v_{i+1} = v_i - g \\Delta t - 2 \\cdot \\text{atanh}\\left(\\frac{\\Delta m}{\\Delta m - 2 m_i}\\right) \\cdot u]\n\nМасса:\n\n[m_{i+1} = m_i - \\Delta m]\n\nУскорение посадочного модуля в процессе работы двигателя\n\n[a_i = \\frac{\\Delta m \\cdot u}{\\Delta t \\cdot m_i \\cdot g}]\n\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/lunolet/"
    },{
      
      "title": "Управление IT-сервисом и контентом",
      
      "content": "Презентации\n\n\n  Управление ИТ-сервисом и контентом. Введение\n  ИТ-служба, ИТ-инфраструктура и ИТ-сервис\n  Service Desk\n  Управление инцидентами, проблемами и ошибками\n  Управление конфигурациями и изменениями\n  Системы управления контентом\n  Основы информационной безопасности\n\n\nЛабораторные работы\n\n\n  Лабораторная работа №1\n  Лабораторная работа №2\n  Лабораторная работа №3\n  Лабораторная работа №4\n  Лабораторная работа №5\n\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/main/"
    },{
      
      "title": "Прикладные задачи динамики твердого тела и систем тел",
      
      "content": "Презентации\n\n\n  Отделение створок головного обтекателя. Математическая модель процесса отделения створок головного обтекателя от ракеты-носителя.\n  Отделение космического аппарата. Математическая модель процесса отделения космического аппарата от носителя.\n  Гравитационный момент. Гравитационный момент, действующий на тело на орбите.\n\n\n",
      "url": "/pages/mechanics-in-space/main/"
    },{
      
      "title": "Компьютерная графика",
      "description": "Курс для бакалавров второго года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Презентации\n",
      "url": "/pages/graphics/main/"
    },{
      
      "title": "Основы MATLAB",
      
      "content": "Быстрое знакомство\n\n\n  Матрицы\n  Индексы и элементы\n  Матричная алгебра\n  Файл-скрипты и файл-функции\n  Ячейки\n  Структуры\n  Статистики и сортировка\n  Структурное программирование\n  Основы графики\n  Численные методы\n  Дата и время\n  Импорт и экспорт данных\n  Временные ряды\n  Таблицы\n  Хронологические таблицы (timetable)\n\n\nПрезентации\n\n\n  Типы данных\n  Функции\n  Файл-функции и скрипты\n  Программирование\n  Графика\n  Игра “Жизнь”\n  Относительное орбитальное движение\n  Численные методы\n  Интегрирование ОДУ\n\n\nПримеры\n\n\n  Игра “Жизнь” (пример кода)\n  Продольные колебания стержня.\n  Построение модели физического маятника в SIMULINK.\n\n\nЛабораторные работы\n\n\n  Сборник заданий для лабораторных работ (курс “Интегрированные математические пакеты”).\n  Сборник заданий для лабораторных работ в формате PDF\n\n\nПромежуточный контроль\n\n\n  Задания для контрольной работы\n\n\nШаблоны\n\n\n  Шаблон отчета по лабораторной работе (LaTeX)\n\n",
      "url": "/pages/matlab/main/"
    },{
      
      "title": "Основы Wolfram Mathematica",
      
      "content": "Лабораторные работы\n\n\n  Списки\n  Движение системы материальных точек\n  Символьные вычисления\n  Уравнения Лагранжа\n  Анимация\n  Численные методы\n\n\nПо каждой лабораторной работе оформляется отчёт в соответствии с шаблоном.\n\nПримеры\n\n\n  Вывод и интегрирование уравнений движения двойного физического маятника (уравнения Лагранжа)\n  Вывод уравнений движения системы с двумя степенями свободы (курсовая работа по теоретической механике)\n  Анимация. Построение анимации.\n  Относительное орбитальное движение. Уравнения относительного орбитального движения двух космических аппаратов при движении одного из них (ведущий) по круговой орбите.\n  Преобразование поворота. Поворот в пространстве. Матрица поворота. Пример в Wolfram Mathematica.\n\n\n",
      "url": "/pages/wolfram/main/"
    },{
      
      "title": "Основы Python",
      "description": "Курс для бакалавров первого года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Лекции\n\nПрезентации к лекциям\n\nЛабораторные работы\n\nШаблон отчёта по лабораторной работе в формате docx\n\nЗадания для лабораторных работ\n\nКурсовая работа\n\nЗадания для курсовых работ\n",
      "url": "/pages/python/main/"
    },{
      
      "title": "Информатика",
      "description": "Курс Информатика для студентов Института экономики и управления Самарского университета.\n",
      "content": "Материалы курса\n\nУчебные пособия и методические указания\n\nЕ.А. Симановский Введение в информатику\n\nЕ.А. Симановский Методические указания к лабораторным работам\n\nЛабораторные работы\n\nЕ.А. Симановский Сборник заданий к лабораторным работам\n\nШаблон отчёта по лабораторной работе\n\nКомментарии к лабораторной работе №1\n\nКомментарии к лабораторной работе №2\n\nКомментарии к лабораторной работе №3\n\nКомментарии к лабораторной работе №4\n\nКомментарии к лабораторной работе №5\n\nКомментарии к лабораторной работе №6\n\nСсылки\n\nПрограммы\n\nСвободная среда разработки Lazarus для Free Pascal\n\nУчебные материалы\n\nКафедра Суперкомпьютеры и общая информатика Самарского университета\n\nКоманды среды разработки Turbo Pascal\n\nTurbo Pascal 7.0 Электронный учебник для студентов и школьников\n\nПаскаль для начинающих. Основы грамматики в таблицах и примерах\n\nБлок-схема\n\nСайт Валерия Семёнова\n\nСтандарты и шаблоны\n\nОбщие требования к учебным текстовым документам\n",
      "url": "/pages/informatics/main/"
    },{
      
      "title": "Методы вычислений",
      
      "content": "Презентации\n\n",
      "url": "/pages/numerical_methods/main/"
    },{
      
      "title": "Динамика твёрдого тела и систем тел",
      
      "content": "Презентации\n\nКинематика твёрдого тела\n\n\n  Ортогональные матрицы\n  Углы Эйлера\n  Кватернионы\n  Кинематические уравнения\n\n\nДинамика твёрдого тела\n\n\n  Основы динамики твёрдого тела\n  Случай Эйлера\n  Случай Лагранжа\n\n\nДинамика систем твёрдых тел\n\n\n  Уравнения связей\n  Метод Верещагина\n  Структура механической системы\n  Метод Виттенбурга (сферические шарниры)\n  Метод Виттенбурга (цилиндрические шарниры)\n  Метод Кейна\n\n\nПрикладные задачи динамики твёрдого тела и систем тел\n\n\n  Отделение створок головного обтекателя\n  Отделение космического аппарата\n\n\nЗадания для лабораторных работ\n\nСеместр 1\n\n\n  Ортогональные матрицы\n  Кватернионы\n  Тензор инерции\n  Движение системы точек. Численное интегрирование\n  Движение твердого тела\n\n\nСеместр 2\n\n\n  \n  \n  \n\n\nПримеры\n\n\n  Построение годографа продольной оси тела при движении в случае Лагранжа.\n\n",
      "url": "/pages/mbs/main/"
    },{
      
      "title": "Теоретическая механика",
      
      "content": "Презентации\n\nКинематика точки\n\n",
      "url": "/pages/mechanics/main/"
    },{
      
      "title": "Базы данных",
      
      "content": "Лекции\n\n\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 6. Основы SQL. Манипулирование данными.\n  Лекция 7. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 8. Основы NoSQL.\n\n\nЛабораторные работы\n\nЗадания для лабораторных работ\n\n\n  Модель Сущность-Связь\n  Создание таблиц\n  Запись данных в БД\n  SQL-запросы\n  Триггеры\n  Процедуры\n  Основы работы в MongoDB\n\n\nОтчеты по лабораторным работам\n\nОтчет по каждой лабораторной работе оформляется в соответствии с требованиями к учебным документам. Пример отчета по лабораторной работе №1 с примером в формате DOCX, в формате PDF.\n\nПрограммное обеспечение\n\nДля выполнения лабораторных работ рекомендую использовать следующее программное обеспечение и сервисы:\n\n\n  draw.io для создания ER-диаграмм;\n  DBeaver для работы с БД MySQL, SQLite\n\n\nПримеры кода\n\n\n  Подключение из Google Colab к базе данных SQLite, расположенной на Google диске.\n  Подключение к базе данных MySQL.\n  Игра “Жизнь” на SQL.\n  Пример построения сложного запроса к базе данных.\n  Подключение к БД SQLite в Google Colab.\n\n\n",
      "url": "/pages/databases/main/"
    },{
      
      "title": "Компьютерные и экспериментальные методы в механике",
      
      "content": "\n",
      "url": "/pages/stat/main/"
    },{
      
      "title": "Задание 1.",
      "description": "Динамика твёрдого тела и систем тел\n",
      "content": "\n\nОриентация системы координат \\(C x_c y_c z_x\\), связанной с космическим аппаратом по отношению к орбитальной системе координат определяется углом рыскания, углом тангажа и углом крена в указанной последовательности. Первый разворот на угол рыскания \\(\\psi\\) выполняется вокруг оси \\(C x_c\\), второй разворот на угол на угол тангажа \\(\\vartheta\\) вокруг оси \\(C z_c\\), третий поворот на угол собственного вращения \\(\\varphi\\) вокруг оси \\(C y_c\\). При нулевых значениях углов система координат, связанная с космическим аппаратом, совпадает с орбитальной системой координат.\n\n\n  \n    Запишите матрицу преобразования координат \\(A\\) из базиса, связанного с космическим аппаратом в базис орбитальной системы координат.\n  \n  \n    В среде MATLAB напишите функцию, которая вычисляет матрицу преобразования координат \\(A\\).\n  \n  \n    Космический аппарат освещается Солнцем, которое находится в положительном направлении оси \\(x_o\\) орбитальной системы координат. Найдите косинус угла между нормалью к панели солнечной батареи (нормаль к панели совпадает с направлением оси \\(Cx_c\\)) и направлением на Солнце. Ориентация космического аппарата определяется углами \\(\\psi = 90^o\\), \\(\\vartheta = 5^o\\), \\(\\varphi = 10^o\\).\n  \n\n\nВ отчете должны быть приведены:\n\n  рисунок систем координат (орбитальной и связанной) с указанием углов между осями\n  алгоритм построения матрицы преобразования координат\n  текст MATLAB-функции (задание 2)\n  рисунок к заданию 3, алгоритм определения косинуса угла между нормалью к панели солнечной батареи и направлением на Солнце\n\n",
      "url": "/pages/mbs/matrix/"
    },{
      
      "title": "Численные методы",
      
      "content": "Интерполяция\n\nВ практике часто возникает необходимость аппроксимации некоторой табличной функции, заданной массивом аргументов \\(x_1, x_2, n_3 \\ldots, x_n\\) и массивом значений функции в этих точках \\(y(x_1), y(x_2), y(x_3), \\ldots, y(x_n)\\). Под аппроксимацией понимается подбор некоторой просто вычисляемой функции, которая приближала бы значения заданной табличной функции.\n\nИзвестны значения некоторой функции \\(y(x)\\) в точках \\(x_0, x_1, x_2, \\ldots, x_n\\):\n\n[y_0, y_1, y_2, \\ldots, y_n.]\n\nНеобходимо построить интерполирующий многочлен \\(L_{n}(x)\\), совпадающий со значениями табличной функции в точках \\(x_0, x_1, x_2, \\ldots, x_n\\) и приближающий функцию \\(y(x)\\) на интервале \\([x_0,x_n]\\).\n\nДля определения коэффициентов интерполяционного полинома, проходящего через заданные точки с координатами \\(x_1, f(x_1)\\), \\(x_2, f(x_2)\\), … \\(x_n, f(x_n)\\) используется функция polyfit:\n\n\n\nПервый аргумент функции массив значений \\(x\\), второй – массив значений функции.\n\n&gt;&gt; x = [ 1  2  3  4 ];\n&gt;&gt; y = [ 0  0.6931  1.0986  1.3863 ];\n&gt;&gt; p = polyfit(x, y, 3)\n\np =\n    0.0283   -0.3137    1.4362   -1.1507\n\n\nРезультат работы функции polyfit – коэффициенты полинома, расположенные в порядке убывания степени аргумента, при которых эти множители стоят:\n\n[P_3(x) = 0.0283 x^3 - 0.3137 x^2 + 1.4362 x - 1.1507]\n\nДля вычисления значения полинома используется функция polyval. Первый аргумент функции polyval – массив коэффициентов полинома, полученный при помощи функции polyfit, второй – одно или несколько значений аргумента \\(x\\), для которых необходимо вычислить значение полиномиальной функции:\n\n&gt;&gt; x0 = 0.1;\n&gt;&gt; polyval(p,x0)\n\nans =\n   -1.0100\n\n\n% График табличной функции (точки)\nplot(x, y, 'ro', 'LineWidth', 2);\nxlabel('x');\nylabel('y');\nhold on;\n% График полинома\nfplot(@(xa) polyval(p,xa),[x(1), x(end)],'LineWidth',2);\nhold off;\n\n\nЕсли степень многочлена, которая передается в функцию polyfit меньше, чем уменьшенное на 1 количество точек табличной функции, то коэффициенты полинома вычисляются по методу наименьших квадратов.\n\n% Столбец значений аргумента: 50 точек равномерно расположенных в интервале от 0 до 5  \nx  = linspace(0,5,50)';\n\n\nКвадрат аргумента с “шумом”: к каждому вычисленному значению добавляется случайное число от 0 до 5\n\ny  = x.^2 + rand(50,1)*5;\n\n\nОпределяем коэффициенты аппроксимирующего многочлена первого и второго порядка, которые уже, очевидно, не будут проходить через все точки табличной функции\n\np1 = polyfit(x, y, 1);\np2 = polyfit(x, y, 2);\n\n\nТочками строим график табличной функции\n\nplot(x,y,'bo')\n\n\nУдерживая (не стирая) первый график (hold on) рисуем на этом же рисунке графики аппроксимирующих многочленов при помощи функции fplot, первым аргументом которой является анонимная функция от x, вызывающая функцию polyval:\n\nhold on;\nfplot(@(x) polyval(p2,x), [0 5], 'r', 'LineWidth', 2)\nfplot(@(x) polyval(p1,x), [0 5], 'g', 'LineWidth', 2)\nhold off;\nxlabel('x'); ylabel('y');\n\n\n\n\nИнтерполяции\n\nИнтерполяция кубическими сплайнами является частным случаем кусочно-полиномиальной интерполяцией. В этом специальном случае между любыми двумя соседними узлами функция интерполируется кубическим полиномом. его коэффициенты на каждом интервале определяются из условий сопряжения в узлах.\n\nДля сплайн интерполяции используется функция spline. Первый аргумент функции – строка или столбец значений аргумента, второй – строка или столбец со значениями функции, соответствующими значениям x. Третий аргумент – значения x, для которых необходимо вычислить значения функции, используя кубическую интерполяцию\n\nx  = [0 1 2 3];\ny  = exp(x);\n\nxq = linspace(0,3,10);\nyq = spline(x,y,xq)\n\nplot(x,y,'ro');\nhold on;\nplot(xq,yq,'b-');\nhold off;\nlegend('Табличная функция','Сплайн');\n\n\n\n\nДля линейно интерполяции используется функция interp1 с такой же структурой аргументов, что и функция spline. Отличие в том, что известные точки соединяются прямой линией, т.е. для определения промежуточных значений используется линейная интерполяция\n\nx  = [0 1 2 3];\ny  = exp(x);\n\nxq = linspace(0,3,10);\nyq = interp1(x,y,xq)\n\nplot(x,y,'ro');\nhold on;\nplot(xq,yq,'b-');\nhold off;\nlegend('Табличная функция','Линейная интерполяция');\n\n\n\n\nРешение систем линейных уравнений\n\nДля решения системы линейных уравнений, например\n\n[\\left{\n\\begin{aligned}\n    2 x_1 + 3 x_2 + x_3 = 5\n    x_1 + 7 x_2 + 2 x_3 = 1\n    3 x_1 + 2 x_2 + x_3 = 2\n\\end{aligned}\n\\right.]\n\nнеобходимо представить её в матричном виде\n\n[\\boldsymbol A \\cdot \\boldsymbol x = \\boldsymbol B]\n\nгде\n\n[\\boldsymbol A = \\begin{bmatrix} 2 &amp; 3 &amp; 1 \\ 1 &amp; 7 &amp; 2 \\ 3 &amp; 2 &amp; 1\\end{bmatrix}, \\quad\n    \\boldsymbol B = \\begin{bmatrix} 5 \\ 1 \\ 2 \\end{bmatrix}, \\quad\n    \\boldsymbol x = \\begin{bmatrix} x_1 \\ x_2 \\ x_3 \\end{bmatrix}, \\quad]\n\nДля определения столбца неизвестных \\(\\boldsymbol x\\) используется оператор \\\n\n&gt;&gt; A = [2 3 1; 1 7 2; 3 2 1];\n&gt;&gt; B = [5;1;2];\n&gt;&gt; x = A\\B\n\nx =\n    6.0000\n    9.0000\n  -34.0000\n\n\nЛинейное программирование\n\nЛинейное программирование — это математический численный метод для оптимизации моделей, в которых целевые функции\n\n[f(x_1,x_2,\\ldots,x_n) \\rightarrow min]\n\nи ограничения, например\n\n[g(x_1,x_2,\\ldots,x_n) &gt; 0]\n\nявляются уравнениями линейной алгебры.\n\nРассмотрим следующий пример. Предположим, что есть 4 типа продукта, для производства которых необходимо 3 типа сырья. В таблице приведены затраты сырья на производство каждого продукта, запасы сырья на складе и прибыль, получаемая от продажи единицы продукта.\n\n\n  \n    \n      Вид сырья\n      Продукт 1\n      Продукт 2\n      Продукт 3\n      Продукт 4\n      Запасы сырья\n    \n  \n  \n    \n      Сырьё 1\n      4 кг\n      2 кг\n      1 кг\n      8 кг\n      \\(\\leq 1200\\) кг\n    \n    \n      Сырьё 2\n      2 кг\n      10 кг\n      6 кг\n      0 кг\n      \\(\\leq 600\\) кг\n    \n    \n      Сырьё 3\n      3 кг\n      0 кг\n      6 кг\n      1 кг\n      \\(\\leq 1500\\) кг\n    \n    \n      Прибыль\n      15 р\n      6 р\n      12 p\n      24 p\n      максимум\n    \n  \n\n\nНеобходимо составить план производства, который бы привёл к максимальной прибыли с учетом имеющихся запасов на складе.\n\nПрибыль (целевая функция)\n\n[S = x_1 s_1 + x_2 s_2 + x_3 s_3 + x_4 s_4 \\rightarrow max]\n\nОграничения\n\n[x_1 a_{11} + x_2 a_{12} + x_3 a_{13} + x_4 a_{14} \\leq 1200]\n\n[x_1 a_{21} + x_2 a_{22} + x_3 a_{23} + x_4 a_{24} \\leq 600]\n\n[x_1 a_{31} + x_2 a_{32} + x_3 a_{33} + x_4 a_{34} \\leq 1500]\n\nВ MATLAB для решения этой задачи используется функция linprog\n\nx = linprog(f,Ane,Bne,Ae,Be,lb,ub)\n\n\n[\\min_{x} \\boldsymbol{f}^T x]\n\nПри условиях равенствах\n\n[\\boldsymbol{A}_e \\boldsymbol{x} = \\boldsymbol{B_e}]\n\nПри условиях неравенствах\n\n[\\boldsymbol{A}{ne} \\boldsymbol{x} \\leq \\boldsymbol{B{ne}}]\n\nПри условии\n\n[\\boldsymbol{L} \\leq \\boldsymbol{x} \\leq \\boldsymbol{U}]\n\nВ рассматриваемой задаче есть целевая функция и ограничения – неравенства. Функция  linprog ищет минимум функции, поэтому для максимизации прибили у коэффициентов рассматриваемой целевой функции нужно поменять знак.\n\n&gt;&gt; f = -[15 6 12 24];\n\n\nУсловия-неравенства (запасы сырья на складе) описываются матрицей коэффициентов Ane и матрицей запасов Bne\n\n&gt;&gt; Ane = [4 2 1 8; 2 10 6 0; 3 0 6 1];\n&gt;&gt; Bne = [1200; 600; 1500];\n\n\nВызываем функцию linprog\n\n&gt;&gt; x = linprog(f,Ane,Bne,[],[],[0 0 0 0],[])\n\nOptimal solution found.\n\nx =\n\n         0\n         0\n  100.0000\n  137.5000\n\n\nТаким образом, оптимальным планом будет производство 100 ед продукта 3 и 137 ед продукта 4.\n\nРешение нелинейных уравнений\n\nДля решения уравнений вида\n\n[f(x) = 0]\n\nиспользуется функция fzero, первым аргументом которой является ссылка на функцию \\(f(x)\\), вторым – начальное приближение для искомого значения решения уравнения или интервал внутри которого находится решение:\n\n&gt;&gt; fzero( @(x) cos(x) - x, 1)\n\nans =\n    0.7391\n\n\nРешение систем нелинейных уравнений\n\nДля решения системы нелинейных уравнений используется функция fsolve. Например, для решения системы\n\n[\\left{\n\t\\begin{aligned}\n\tx^2 + y^2 + z^2 - 1 &amp; = 0 \\ \n\t2x^2 + y^2 - 4z  &amp; = 0 \\ \n\t3x^2 - 4y + z^2  &amp; = 0 \n\t\\end{aligned}\n\t\\right.]\n\nнеобходимо написать m-файл с функцией\n\n% Файл f.m\nfunction y = f(x)\n    y = [x(1)^2+x(2)^2+x(3)^2-1;\n         2*x(1)^2+x(2)^2-4*x(3);\n         3*x(1)^2-4*x(2)+x(3)^2];\n\n\nДля поиска решения необходимо вызвать функцию fsolve, передав ей ссылку на функцию и вектор начального приближения \\([x_0, y_0, z_0]\\)\n\n&gt;&gt; fsolve(@y,[1;1;1])\n\nans =\n    0.7852\n    0.4966\n    0.3699\n\n\nМинимум функции одной переменной\n\nПоиск минимума функции \\(f(x)\\) на интервале \\([x_1, x_2]\\)\n\n&gt;&gt; fun = @(x) x^2 - 0.3*x^3 + 3 + cos(4*x)^2;\n&gt;&gt; fplot(fun,[-1 3]);\n&gt;&gt; fminbnd(fun,-1,3)\n\nans = \n    0.372\n\n\n\n\nМинимум функции нескольких переменных\n\nНайти минимум функции нескольких переменных\n\n[\\min_{\\boldsymbol x} f(\\boldsymbol x), \\quad \\boldsymbol{x} = [x_1,x_2,\\ldots,x_n]]\n\nПример:\n\n[f(x)=100(x_2 − x_1^2)^2+(1−x_1)^2]\n\nиспользуется функция fminsearch. Первый аргумент функции – ссылка на вектор-функцию от векторного аргумента, второй – начальное приближение\n\n&gt;&gt; fun = @(x1,x2) 100*(x2-x1.^2).^2+(1-x1).^2;\n&gt;&gt; x1 = linspace(0,3,100);\n&gt;&gt; x2 = linspace(0,3,100);\n&gt;&gt; [X1,X2] = meshgrid(x1,x2);\n&gt;&gt; f = fun(X1,X2);\n&gt;&gt; contour(X1,X2,f,200);\n&gt;&gt; fminsearch(@(x) fun(x(1),x(2)),[0, 0.5])\n\nans =\n    1.0000    1.0000\n\n\n\n\nИнтегрирование\n\nДля функции, заданной таблично, интеграл можно вычислить используя формулу трапеций, используя функцию trapz:\n\n&gt;&gt; x = 1.0:0.1:2.0;\n&gt;&gt; y = log(x);\n&gt;&gt; trapz(x, y)\n\nans =\n    0.3859\n\n\nТочное значение интеграла равно \\(\\log 4 - 1 \\approx 0.386294361119891\\).\n\nДля известной подинтегральной функции более точный результат дает использование функции quad, в которую нужно передать ссылку на подинтегральную функцию и пределы интегрирования\n\n[F = \\int_1^2 \\ln(x) dx]\n\n&gt;&gt; format long\n&gt;&gt; quad(@log, 1, 2)\n\nans =\n   0.386294334336416\n\n\nТретьим аргументом функции quad является желаемая точность результата (по умолчанию – \\(10^{-6}\\) )\n\n&gt;&gt; f = @(x) sin(x).*log(x).^2;\n&gt;&gt; quad(f, 1, 2, 1e-8)\n\nans =\n   0.1822\n\n",
      "url": "/pages/matlab/numeric/"
    },{
      
      "title": "Лабиринт",
      
      "content": "\n  Задана прямоугольная область \\(n \\times m\\) клеток\n  Каждая клетка может быть пустой или занята препятствием\n  Построить алгоритм определения пути для перемещения  из точки с координатами \\(x_0\\), \\(y_0\\) в точку с координатами \\(x_k\\), \\(y_k\\).\n  Перемещаемая точка может двигаться в произвольном направлении по клеткам, не занятым препятствиями.\n  Программа должна генерировать прямоугольную область с препятсвиями, выводить на экран поле и найденный маршрут.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/obstacles/"
    },{
      
      "title": "Интегрирование системы дифференциальных уравнений",
      
      "content": "Вдоль горизонтальной прямой движутся n материальных точек с массами \\(m_k\\) (\\(k=1,\\ldots,n\\)), связанные пружинами с заданными жесткостями \\(c_k\\)  и свободными длинами \\(L_k\\).\n\n\n\nДифференциальное уравнение движение первого тела:\n\n[m_1 \\ddot{x}1 = - c_1 (x{1}-L_1) + c_2 (x_{2}-x_{1}-L_{2})]\n\nДифференциальное уравнение движение \\(k\\)-го тела (\\(2 \\leq k \\leq n-1\\)):\n\n[m_k \\ddot{x}k = - c_k (x{k}-x_{k-1}-L_k) + c_{k+1} (x_{k+1}-x_{k}-L_{k+1}), \\quad k=2,\\ldots,n-1]\n\nДифференциальное уравнение движение \\(n\\)-го тела:\n\n[m_n \\ddot{x}n = - c_n (x{n}-x_{n-1}-L_n)]\n\nФайл-функция правых частей дифференциальных уравнений движения системы материальных точек\n\nfunction dq = dqdt(t, q, p)\n    % Матрица-столбец состояния механической системы имеет\n    % размерность (2n x 1):\n    % Количество тел (материальных точек)\n    n = size(q,1)/2;\n    % Первые n элементов столбца это координаты грузов:\n    x  = q(1:n);\n    % элементы с n+1 по 2n -- скорости тел:\n    v  = q(n+1:2*n);\n    % Столбец расстояний между соседними точками (для первой точки это сама координата x1)\n    dx = [x(1);diff(x)];\n    % Столбец сил растяжения пружин\n    Fs = (dx-p.L).*p.c;\n    % Столбец сил, действующих на точки\n    F  = -Fs + [Fs(2:n); 0];\n    % Столбец ускорений тел\n    a    = F./p.m;\n    dq = [v;a];\nend\n\n\nФайл-скрипт, запускающий процесс численного интегрирования\n\n% Массы тел\np.m = [5;10;8];\n% Свободные длины пружин\np.L = [1;1;1];\n% Жесткости пружин\np.c = [1000;1000;500];\n% Координатный столбец начальных условий\nq0 = [1.1;2.5;3.2;0;0;0];\n% Запускаем процесс интегрирования\n[t, q] = ode45(@(t,q) dqdt(t,q,p),[0 5], q0);\n% Графики изменений координат тел\nplot(t,q(:,1:3));\n\n\nЗадание\n\n\n  Добавить в модель силу сухого трения, действующую на тела, полагая, что система движется по горизонтальной плоскости в поле силы тяжести (\\(g = 9.81\\) м/с\\(^2\\)).\n  Построить графики изменения расстояний между телами от времени.\n  Построить график изменения кинетической энергии системы от времени.\n  Построить график изменения потенциальной энергии системы от времени.\n\n",
      "url": "/pages/matlab/ode/"
    },{
      
      "title": "Относительное и абсолютное орбитальное движение",
      
      "content": "Задание\n\n\n  Написать программу численного интегрирования уравнений движения материальной точки в центральном гравитационном поле Земли по отношению к геоцентрической инерциальной системе координат.\n\n\nПример функция правых частей\n\nfunction dq = dqdt(t,q,p)    \n    r  = q(1:3);    \n    v  = q(4:6);    \n    mu = p.mu;\n    a  = - mu*r/norm(r)^3;\n    dq = [v; a];\nend\n\n\np.mu = ...\n...\n\n[t, q] = ode113(@(t,q,p) ... )\n...\n\n\n\n  \n    Получить численное решение движения орбитальной станции по круговой орбите высотой 450 км на интервале трех орбитальных периодов станции. Установить требуемую абсолютную погрешность  метода численного интегрирования не более: \\(10^{-8}\\).\n  \n  \n    Получить численные решения движения наноспутника, отделившегося от станции со скоростью 1 м/с в направлении орбитальной скорости станции (случай А), в направлении противоположном орбитальной скорости станции (случай В). Установить требуемую абсолютную погрешность  метода численного интегрирования не более: \\(10^{-8}\\).\n  \n  \n    Построить на одном рисунке две траектории (для случаев А и В) движения наноспутника относительно станции в орбитальной подвижной системе координат станции на интервале её трех орбитальных периодов.\n  \n  \n    Построить на одном рисунке две траектории движения наноспутника относительно станции в орбитальной подвижной системе координат станции, используя приближенные уравнения  относительного орбитального движения (результаты ЛР №1) на интервале трех орбитальных периодов станции.\n  \n  \n    Построить два рисунка, соответствующие двум разным направлениям отделения наноспутника, на каждом из которых показать траектории движения наноспутника, полученные в результате численного интегрирования и с использованием приближенных уравнений относительного движения.\n  \n\n\nПример рисунка для случая отделения наноспутника в направлении орбитальной скорости станции:\n\n\n\n\n  Для двух рассматриваемых случаев найти абсолютную погрешность определения положения наноспутника через три орбитальных периода станции, используя приближенные уравнения относительного орбитального движения, приняв за точное положение результаты численного интегрирования движения наноспутника (п. 3).\n\n\nМетодические указания\n\nВ каждый момент времени единичные вектора орбитальной системы координат станции определяются следующим образом. Единичный вектор оси \\(x_o\\) орбитальной системы координат, направленный вдоль радиус-вектора орбиты:\n\n\n  \n    \n      [\\mathbf{e}_r = \\frac{\\mathbf{r}_1}{\n      \\mathbf{r}_1\n      }]\n    \n  \n\n\nгде \\(\\boldsymbol r_1\\) координатный столбец радиус-вектора станции в геоцентрической инерциальной системе координат. Единичный вектор нормали к плоскости орбиты:\n\n\n  \n    \n      [\\mathbf{e}_n = \\frac{\\mathbf{e}_r \\times \\mathbf{v}_1}{\n      \\mathbf{e}_r \\times \\mathbf{v}_1\n      }]\n    \n  \n\n\nединичный вектор трансверсали\n\n[\\mathbf{e}_t = \\mathbf{e}_n \\times \\mathbf{e}_r]\n\nКоординаты наноспутника в орбитальной подвижной системе станции\n\n[\\boldsymbol{\\rho} = \\begin{bmatrix} (\\boldsymbol{r}_2-\\boldsymbol{r}_1)\\cdot \\boldsymbol{e}_r \\ (\\boldsymbol{r}_2-\\boldsymbol{r}_1)\\cdot \\boldsymbol{e}_t  \\ (\\boldsymbol{r}_2-\\boldsymbol{r}_1)\\cdot \\boldsymbol{e}_n \\end{bmatrix}]\n\nгде \\(\\boldsymbol r_2\\) координатный столбец радиус-вектора наноспутника в геоцентрической инерциальной системе координат.\n",
      "url": "/pages/matlab/orbital/"
    },{
      
      "title": "Статьи",
      
      "content": "2020\n\n\n  \n    Valeriy I. Trushlyakov, Vladislav A. Urbansky, and Vadim V. Yudintsev “Reducing Environmental Damage After Emergency Engine Cutoff of the Launch Vehicle” Journal of Spacecraft and Rockets, Published Online:14 Dec 2020. https://doi.org/10.2514/1.A34912.\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. “Rotary Space Tether System for Active Debris Removal,” Journal of Guidance, Control, and Dynamics. Vol. 43, No. 2, February 2020. doi: https://doi.org/10.2514/1.G004615\n  \n  \n    Апарин М.П., Юдинцев В.В. Использование аэродинамического торможения при движении возвращаемой первой ступени ракеты-носителя // Вестник молодых ученых и специалистов Самарского университета. — 2020. — № 1 (16). — С. 6-12\n  \n\n\n2019\n\n\n  \n    V. I. Trushlyakov, V. V. Yudintsev. “Method of Active Debris Removal Using Rotating Space Tether System,” First Int’l. Orbital Debris Conf. (2019).\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. (2019). Dynamic similitude for small-scale re-entry experiment. Phys.: Conf. Ser. 1210, 12148.\n  \n  \n    Апарин М. П., Юдинцев В. В. Мягкая посадка возвращаемой первой ступени ракеты-носителя. Международная молодёжная научная конференция «XV Королёвские чтения», посвящённая 100-летию со дня рождения Д.И. Козлова: тезисы докладов 8-10 октября 2019 года.\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. (2019). Rotating tethered system for active space debris removal. J. Phys.: Conf. Ser. 1260 112032.\n  \n  \n    V. S. Aslanov, V. V. Yudintsev, Chaos in tethered tug-debris system induced by attitude oscillations of debris. Journal of Guidance, Control, and Dynamics. Vol. 42, No. 7, July 2019.\n  \n\n\n2018\n\n\n  \n    Способ очистки орбит от объектов космического мусора [Текст] : пат. 267368 Рос. Федерация : МПК7 B 64 G 1/56, B 64 G 1/64 / Трушляков В. И., Юдинцев В. В., Макаров Ю. Н., Шатров Я. Т.; заявитель и патентообладатель Госкорпорация “Роскосмос”. заявл. 09.02.18 ; опубл. 28.12.18, Бюл. № 1.\n  \n  \n    Юдинцев В. В. Динамика захвата сетью вращающегося объекта – космического мусора // Вестник Московского авиационного института. 2018. Т. 25. № 4. С. 28-39.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev  Motion Control of Space Tug During Debris Removal by a Coulomb Force. Journal of Guidance, Control, and Dynamics, 2018, March 22, 2018. doi:10.2514/1.G003251\n  \n  \n    Асланов В.С., Юдинцев В.В. Выбор параметров системы увода космического мусора с упругими элементами посредством тросовой буксировки. Вестник Московского авиационного института. 2018. Т. 25. № 1. С. 7-17.\n  \n  \n    V.I. Trushlyakov, V.V. Yudintsev, R.S. Pikalov Dynamic control of tug-debris tethered system after the capturing of the debris. Journal of Physics: Conference Series 1050 (2018) 012092. doi:10.1088/1742-6596/1050/1/012092\n  \n  \n    Патент РФ № 2658401, 16.03.2017. Универсальный транспортно-пусковой контейнер // Патент России № 2658401. 2018. Бюл. № 18. / Сивов М.Е., Юдинцев В.В.\n  \n  \n    Асланов В. С., Юдинцев В. В. Классическая механика в технологиях увода космического мусора с орбиты. Сборник научно-методических статей. Теоретическая механика Вып. 30. / Под редакцией профессора В. А. Самсонова – М.: Издательство Московского университета, 2018. – 253 с.\n  \n\n\n2017\n\n\n  \n    Как убрать космический мусор с рабочих орбит? О работе 7-й Европейской конференции по космическому мусору.\n  \n  \n    V.I. Trushlyakov V.V. Yudintsev Systems engineering design and optimization of an active debris removal mission of a spent rocket body using piggyback autonomous module. 3rd IAA Conf. Dyn. Control Sp. Syst. (DYCOSS 2017) 30 May - 1st June 2017 (Moscow) pp 667–681.\n  \n  \n    V.S. Aslanov, A.K. Misra, V. V. Yudintsev, Chaotic attitude motion of a low-thrust tug-debris tethered system in a Keplerian orbit, Acta Astronaut. 139 (2017) 419–427. doi:10.1016/j.actaastro.2017.07.008.\n  \n  \n    V.V. Yudintsev, V.S. Aslanov, Detumbling Space Debris Using Modified Yo-Yo Mechanism, J. Guid. Control. Dyn. 40 (2017) 714–721. doi:10.2514/1.G000686.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Docking of a space tug with upper stage debris object using deployable flexible beam // Proceedings of the International Astronautical Congress, IAC. — 2017. — Vol. 11. — P. 7084-7090\n  \n  \n    O.G. Lagno, T.I. Lipatnikova, Y.N. Makarov, T.V. Mironova, V.I. Trushlyakov, Y.Y. Shatrov and V.V. Yudintsev Parameters design of autonomous docking module and the choice of suitable target and primary payload for ADR. Proc. 7th Eur. Conf. Sp. Debris ESOC 18 - 21 April 2017 (Darmstadt, Germany)\n  \n  \n    Асланов В. С., Юдинцев В. В.  Тросовая буксировка объекта космического мусора с полостью, заполненной жидкостью. Труды МАИ. 2017. № 97.\n  \n\n\n2016\n\n\n  V.S. Aslanov, A.K. Misra, V.V. Yudintsev, Chaotic motions of tethered satellites with low thrust, in: 67th Int. Astronaut. Congr. IAC 2016; Guadalajara; Mex. 26 Sept. 2016 through 30 Sept. 2016, International Astronautical Federation, IAF, 2016.\nd\n  Способ проведения лётно-конструкторских испытаний автономного стыковочного модуля для очистки орбит от космического мусора Трушляков В.И., Юдинцев В.В., Макаров Ю.Н., Шатров Я.Т. Патент на изобретение RUS 2643020 06.09.2016. Патент отмечен дипломом ФИПС и Роспатента - «100 лучших изобретений России-2018».\n\n\n2015\n\n\n  \n    Юдинцев В.В. Динамика отделения наноспутника формата кубсат от транспортно-пускового контейнера // Всероссийский научно-технический журнал «Полёт», 8-9 2015, с. 10-15\n  \n  \n    В. Д. Еленев, Б. А. Титов, Е. И. Давыдов, И. Е. Давыдов, А. Г. Кочян, В. В. Юдинцев Исследование динамики малого космического аппарата с учётом воздействия упругих колебаний конструкции присоединённых панелей солнечных батарей и аэродинамического момента // Вестник СГАУ. Том 14, № 1 (2015) С. 25-35.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, The motion of tethered tug-debris system with fuel residuals, Adv. Sp. Res. 56 (2015) 1493–1501. doi:10.1016/j.asr.2015.06.032.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics, analytical solutions and choice of parameters for towed space debris with flexible appendages, Adv. Sp. Res. 55 (2015) 660–667. doi:10.1016/j.asr.2014.10.034.\n  \n\n\n2014\n\n\n  \n    V.S. Aslanov, V.V. Yudintsev, Behavior of tethered debris with flexible appendages, Acta Astronaut. 104 (2014) 91–98. doi:10.1016/j.actaastro.2014.07.028.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics, Analytical Solutions and Choice of Parameters for Towed Space Debris with Flexible Appendages, Adv. Sp. Res. 55 (2014) 660–667. doi:10.1016/j.asr.2014.10.034.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Behaviour of tethered debris with flexible appendages, Acta Astronaut. 104 (2014) 91–98. doi:10.1016/j.actaastro.2014.07.028.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics and chaos control of asymmetric gyrostat satellites, Cosm. Res. 52 (2014) 216–228. doi:10.1134/S0010952514030010.\n  \n  \n    D. S. Zaretskiy , E. Kosmodemyanskii, A. Romanov, M. Sivov , M. Trusov, V. Yudintsev 1U-3U+ Cubesat Deployer by JSC SRC “Progress”. 1st Latin American IAA CubeSat WorkShop. Brasília, Brasil. December 8th - 11th, 2014.\n  \n  \n    Круглов Г. Е., Юдинцев В. В.  Синтез процессов группового отделения малых космических аппаратов от блока выведения для разных конструктивно-компоновочных схем. Международная конференция «Научные и технологические эксперименты на автоматических космических аппаратах и малых спутниках» (SPEXP 2014), 9-11 сентября 2014 г, Самара , Россия. 2014 (с. 224-227)\n  \n\n\n2013\n\n\n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics and control of dual-spin gyrostat spacecraft with changing structure, Celest. Mech. Dyn. Astron. 115 (2013) 91–105. doi:10.1007/s10569-012-9453-8.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика буксировки твердого тела на упругом тросе в безгравитационном пространстве. Вестник СамГУ - Естественнонаучная серия, №3 (104). 2013, с. 58-66.\n  \n  \n    В.В. Андреев, С.Р. Бурназян, Г.Е. Круглов, В.В. Юдинцев, О влиянии упругих свойств конструкции разделяемых тел на их кинематические параметры после отделения, in: Сборник Трудов III Всероссийской Научно-Технической Конференции «Актуальные Проблемы Ракетно-Космической Техники» (Козловские Чтения), 2013: pp. 114–122.\n  \n  \n    B.C. Асланов, B.B. Юдинцев, Динамика буксировки твердого тела на упругом тросе в безгравитационном пространстве, Вестник СамГУ. 3 (2013) 58–66.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics of large space debris removal using tethered space tug, Acta Astronaut. 91 (2013) 149–156. doi:10.1016/j.actaastro.2013.05.020.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика и управление хаосом асимметричных спутников-гиростатов. Космические исследования, том 52, № 3, с. 229-241.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics of Large Debris Connected to Space Tug by a Tether, J. Guid. Control. Dyn. 36 (2013) 1654–1660. doi:10.2514/1.60976.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics and control of dual-spin gyrostat spacecraft with changing structure, Celest. Mech. Dyn. Astron. 115 (2013) 91–105. doi:10.1007/s10569-012-9453-8.\n  \n\n\n2012\n\n\n  \n    V. Aslanov, V. Yudintsev, Dynamics and chaos control of gyrostat satellite, Chaos, Solitons and Fractals. 45 (2012) 1100–1107. doi:10.1016/j.chaos.2012.06.008.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика буксировки космического аппарата на тросе в центральном поле Вестник Самарского государственного аэрокосмического университета имени академика С. П. Королёва (национальный исследовательский университет). №2 (33). 2012. С. 9-16.\n  \n  \n    Юдинцев В. В. Моделирование процессов раскрытия многоэлементных конструкций космических аппаратов. Всероссийский научно-технический журнал “Полет”, №5. 2012 с. 28 - 33\n  \n\n\n2011\n\n\n  Седельников А. В., Юдинцев В. В. Оценка влияния температурных деформаций упругих элементов космической лаборатории на поле микроускорений ее внутренней среды // Известия СНЦ РАН. 2011. Т. 13 № 1(2). С. 344-346. ISSN 0579-2975.\n\n\n2010\n\n\n  \n    V. Aslanov, G. Kruglov, V. Yudintsev, NewtonEuler equations of multibody systems with changing structures for space applications, Acta Astronaut. 68 (2011) 2080–2087. doi:10.1016/j.actaastro.2010.11.013.\n  \n  \n    И.В. Белоконов, Г.E. Круглов, В.И. Трушляков, B.B. Юдинцев, Оценка возможности управляемого схода с орбиты верхней ступени РН “Союз” за счёт использования остатков топлива в баках, Вестник СГАУ. 2 (2010) 105–111.\n  \n  \n    Андреев В. В., Круглов Г. Е., Юдинцев В. В. Моделирование подвижных элементов конструкции космического аппарата. Решетневские чтения: Материалы XIV международной научной конференции, посвященной памяти конструктора ракетно-космических систем академика М .Ф. Решетнёва  (10-12 ноября, 2010 г., г. Красноярск): в 2х частях, под. ред. Ю. Ю. Логинова; Сибирский государственный аэрокосмический университет, 2010 г., ч. II, стр. 370-371.\n  \n\n\n2009\n\n\n  \n    Воронин В. В., Юдинцев В. В. Моделирование системы раскрытия створок солнечных батарей с механизмом синхронизации. Тезисы докладов XXXV Самарской областной студ. науч. конференции, Самара. 2009, с. 214.\n  \n  \n    Юдинцев В. В. Моделирование процесса отделения боковых блоков РН “Союз” в системе MSC/ADAMS. Стр. 631-638: C56 Современные информационные технологии и ИТ-образование. Сборник докладов научно-практической конференции. Под ред. Проф. В. А. Сухомлина. - М.: ИНТУИТ.РУ, 2009.-848с.\n  \n\n\n2008\n\n\n  \n    Юдинцев В. В. Использование пакета MSC/ADAMS для моделирования механических систем ракетно-космической техники, Сборник трудов IX международной научно-технической конференции «Компьютерное моделирование 2008», г. Санкт-Петербург, С. 269-272.\n  \n  \n    Юдинцев В. В. Параметризация матрицы масс уравнений движения систем твердых тел РКТ, Общероссийский научно-технический журнал «Полет», №9, 20-24, 2008\n  \n\n\n2006\n\n\n  \n    Асланов В. С., Круглов Г. Е., Юдинцев В. В. Матричная форма уравнений движения систем РКТ Общероссийский научно-технический журнал «Полет», №4, 2006.\n  \n  \n    Аншаков Г. П., Асланов В. С., Балакин В. Л., Дорошин А. В., Квашин А. С., Круглов Г. Е. Юдинцев В. В. Динамические процессы в ракетно-космических системах. Вестник Самарского государственного аэрокосмического университета им. академика С. П. Королева, №1(3), 2003 (3/1)\n  \n\n\n2002\n\n\n  \n    Кобзев Ю. Н., Круглов Г. Е., Петров Н. К., Щиблев Ю. Н. Юдинцев В. В. Разработка, научно-техническое обоснование и внедрение мероприятий по повышению скоростного напора при отделении боковых блоков ракеты носителя “Союз” с целью повышения её грузоподъемности. Материалы конференции. “Первые Уткинские чтения”, Балтийский государственный технический университет “Военмех”, СпБ, 2002. (4/1)\n  \n  \n    Юдинцев В. В. Уравнения движения системы связанных твердых тел с переменной структурой, Сборник трудов XII Всероссийского научно-технического семинара по управлению движением и навигации летательных аппаратов. Самарский гос. аэрокосм. университет. Самара, 2002.\n  \n\n\n2001\n\n\n  Асланов В. С., Балакин В. Л., Дмитриев В. В., Дорошин А. В., Круглов Г. Е. Юдинцев В. В. Научные исследования высшей школы по приоритетным направлениям науки и техники. Тезисы докладов отчетной конференции-выставки подпрограммы 205 “Транспорт” научно-технической программы Министерства образования РФ. М.: Изд-во МАИ, 2001 г.Транспортные ракетно-космические системы для глобального мониторинга, навигации и связи.\n\n\n2000\n\n\n  Асланов В. С., Круглов Г. Е., Юдинцев В. В. Синтез процесса раскрытия солнечных батарей КА, Сборник трудов X Всероссийского научно-технического семинара по управлению движением и навигации летательных аппаратов. Самарский гос. аэрокосм. университет. Самара, 2000 г.\n\n\n1999\n\n\n  Асланов В. С., Круглов Г. Е., Юдинцев В. В. “Параметрический синтез процесса отделения боковых блоков ракеты-носителя “Союз””, Вестник Академии космонавтики, стр. 31, Самара, 1999 г.\n\n",
      "url": "/pages/papers/"
    },{
      
      "title": "Патенты",
      
      "content": "\n  \n    Способ очистки орбит от объектов космического мусора [Текст] : пат. 267368 Рос. Федерация : МПК7 B 64 G 1/56, B 64 G 1/64 / Трушляков В. И., Юдинцев В. В., Макаров Ю. Н., Шатров Я. Т.; заявитель и патентообладатель Госкорпорация “Роскосмос”. заявл. 09.02.18 ; опубл. 28.12.18, Бюл. № 1.\n  \n  \n    Универсальный транспортно-пусковой контейнер // Патент России № 2658401. 2018. Бюл. № 18. / Сивов М.Е., Юдинцев В.В.\n  \n  \n    Способ проведения лётно-конструкторских испытаний автономного стыковочного модуля для очистки орбит от космического мусора Трушляков В.И., Юдинцев В.В., Макаров Ю.Н., Шатров Я.Т. Патент на изобретение RUS 2643020 06.09.2016. Патент отмечен дипломом ФИПС и Роспатента - «100 лучших изобретений России-2018».\n  \n  \n    Узел крышки транспортно-пускового контейнера Сивов М. Е., Юдинцев В. В., Трусов М. Г., Кирсанов А. А., Зарецкий Д. С. RU 2 620 630 C1, 18.02.2016\n  \n  \n    Транспортно-пусковой контейнер Сивов М. Е., Юдинцев В. В., Трусов М. Г., Кирсанов А. А., Зарецкий Д. С. RU 2 631 360 C1, 19.08.2016.\n  \n  \n    Стенд для раскрытия батареи солнечной Сороколетов В. И., Плетнева Н. А., Богданов Н. А., Юдинцев В. В., Афанасьев А. П. RU 2 567 678 C1, 03.07.2014.\n  \n  \n    Устройство отделения хвостового отсека ракетного блока Божко А. В., Бурназян С. Р., Круглов Г. Е., Солунин В. С., Юдинцев В. В. RU 2 497 732 C1, 06.06.2012.\n  \n\n\n",
      "url": "/pages/patents/"
    },{
      
      "title": "Многоугольник и точка",
      "description": "Задание для курсовой работы\n",
      "content": "\n  \n    Многоугольник задан координатами своих \\(N\\) вершин в порядке обхода их по контуру по часовой стрелке.\n  \n  \n    Для точки с координатами \\((x,y)\\) определить, принадлежит ли она стороне многоугольника или лежит внутри или вне его.\n  \n  \n    Программа должна показать на экране многоугольник и точку и вывести на этом же рисунке информацию о взаимном положении точки и многоугольника:\n  \n\n\n\n  координаты ближйшей точки многоугольника\n  расстояние от заданной точки до ближайшей: положительное, если заданная точка лежит вне многоугольника, отрицательное, если точка лежит внутри многоугольника.\n\n\n\n  Результат работы программы должны выводиться на экран и сохраняться в графический файл формата png.\n\n\n\n",
      "url": "/pages/python/course_works/point_polygon/"
    },{
      
      "title": "Пересечение многоугольников",
      
      "content": "\n  Найти пересечение и объединение двух выпуклых многоугольников.\n  Многоугольники задаются координатами вершин в порядке обхода по контуру.\n  Координаты вершин заданы в текстовом файле.\n  Программа должна изобразить на экране исходные многоугольники и многоугольник – результат пересечения (объединения).\n\n\nИсточник: http://algolist.manual.ru/olimp/geo_prb.php\n\nСписок заданий\n",
      "url": "/pages/python/course_works/polygons/"
    },{
      
      "title": "Ломаная линия",
      
      "content": "В текстовом файле заданы координаты точек ломаной линии в виде:\n\nx1,y1\nx2,y2\nx3,y3\n...\nxn,yn\n\n\n\n  Нарисовать ломаную линию на экране.\n  Проверить является ли эта ломаная линия самопересекающейся.\n  Найти точки пересечения и обозначить эти точки на экране.\n  Записать координаты точек пересечения в текстовый файл.\n  Результат работы должен выводиться на экран и сохраняться в файле формата png.\n\n",
      "url": "/pages/python/course_works/polyline/"
    },{
      
      "title": "Компьютерная графика",
      "description": "Презентации к дисциплине “Компьютерная графика” для студентов второго курса Института ракетно-космической техники Самарского университета.\n",
      "content": "\n  Введение. Основы работы в Inkscape\n  Python и библиотека matplotlib\n  Основы Gnuplot\n  Преобразование поворота\n  Анимация в Mathematica\n  imagemagic и ffmpeg\n  Основы Blender\n\n",
      "url": "/pages/graphics/presentations/"
    },{
      
      "title": "Основы Python",
      "description": "Презентации к дисциплине “Технологии и языки программирования” для студентов первого курса Института ракетно-космической техники Самарского университета.\n",
      "content": "Семестр 1\n\n\n  Введение\n  Основы Python 1. Синтаксис\n  Основы Python 2. Списки, кортежи, множества\n  Основы Python 3. Словари\n  Функции\n  Элементы функционального программирования\n  Модули и пакеты\n  Ввод и вывод\n\n\nСеместр 2\n\n\n  Обработка ошибок\n  Основы ООП 1.\n  Основы ООП 2.\n  Библиотека numpy\n  Библиотека scipy\n  Машинная арифметика\n  Библиотека matplotlib\n  Библиотека pandas\n\n",
      "url": "/pages/python/presentations/"
    },{
      
      "title": "Презентации к курсу \"Методы вычислений\"",
      
      "content": "\n  Метод Гаусса\n  СЛАУ специального вида\n  Итерационные методы решения СЛАУ\n  Методы решения нелинейных уравнений и систем\n  Решение задач на собственные значения\n  Многошаговые методы решения ОДУ\n  Многочлены наилучших приближений\n\n\n",
      "url": "/pages/numerical_methods/presentations/"
    },{
      
      "title": "Динамика твёрдого тела и систем тел",
      "description": "Презентации к дисциплине “Динамика твёрдого тела и систем твёрдых тел” для студентов первого курса магистратуры  Института ракетно-космической техники Самарского университета.\n",
      "content": "Кинематика твёрдого тела\n\n\n  Ортогональные матрицы\n  Углы Эйлера\n  Кватернионы\n  Кинематические уравнения\n\n\nДинамика твёрдого тела\n\n\n  Основы динамики твёрдого тела\n  Случай Эйлера\n  Случай Лагранжа\n\n\nДинамика систем твёрдых тел\n\n\n  Уравнения связей\n  Метод Верещагина\n  Структура механической системы\n  Метод Виттенбурга (сферические шарниры)\n  Метод Виттенбурга (цилиндрические шарниры)\n  Метод Кейна\n\n\nПрикладные задачи динамики твёрдого тела и систем тел\n\n\n  Отделение створок головного обтекателя\n  Отделение космического аппарата\n\n",
      "url": "/pages/mbs/presentations/"
    },{
      
      "title": "Презентации к курсу \"Базы данных\"",
      
      "content": "\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра. Нормализация: четыре нормальные формы.\n  Лекция 4 Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 5. Основы SQL. Манипулирование данными.\n  Лекция 6. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 7. Основы NoSQL.\n\n",
      "url": "/pages/databases/presentations/"
    },{
      
      "title": "Презентации",
      
      "content": "Учебные презентации\n\n\n  Динамика твёрдого тела и систем тел\n  Основы Python\n  Основы MATLAB\n  Компьютерный практикум по механике\n  Компьютерная графика\n\n\nПрезентации для конференций и семинаров\n\n\n  \n    V. Trushlyakov, V. Yudintsev Method of Active Debris Removal Using Rotating Space Tether System. The First International Orbital Debris Conference (IOC) \nDecember 9–12, 2019, Sugar Land, Texas. \n  \n  \n    Трушляков В. И., Юдинцев В. В. Вращающаяся тросовая система для увода космического мусора. III International scientific conference “Mechanical Science and Technology Update” (MSTU-2019). 23-24 April, 2019 (Omsk, Russia).\n  \n  \n    Трушляков В.И., Юдинцев В. В. Космический буксир на базе ТГК “Прогресс” для активного увода космического мусора. Презентация для Девятого Международного Аэрокосмического Конгресса. МГУ им. М.В. Ломоносова, 28-31 августа 2018 г.\n  \n  \n    V. Yudintsev The problems of nanosatellite cluster launching and the deployers for nanosatellites separation. Presentation for the XIV International Summer Space School “Future Space Technologies and Experiments in Space”, Samara University, Samara, Russia, 20 Aug - 1 Sep, 2018.\n  \n  \n    V. Trushlyakov, V. Yudintsev Progress-M spacecraft as the basis for the space tug for adr missions. Presentation for 5th European Workshop on Space Debris Modeling and Remediation - CNES HQ - Paris, June 25-27, 2018.\n  \n  \n    Проблема космического мусора: современные направления исследований обзор работ 7-ой Европейской конференции по космическому мусору (офис центра управления полетами ЕКА, Дармштадт, Германия, 18-21 апреля 2017 г.)\n  \n  \n    Модификация механизма Йо-Йо: гашение угловой скорости орбитальной ступени при помощи механизма Йо-Йо без образования космического мусора. Презентация подготовлена для семинара кафедры теоретической механики по материалам статьи “Detumbling Space Debris Using Modified Yo-Yo Mechanism” Journal of Guidance, Control, and Dynamics, Vol. 40, No. 3 (2017), pp. 714-721.\n  \n  \n    Асланов В. С., Юдинцев В. В. Стыковка с объёктом космического мусора с использованием упругой разворачиваемой штанги. Presentation for 68th International Astronautical Congress (IAC), Adelaide, Australia, 25-29 September 2017.\n  \n  \n    Vladimir S. Aslanov, Arun K. Misra, Vadim V. Yudintsev Chaotic motions of tethered satellites with low thrust. Presentation for 67th International Astronautical Congress (IAC), Guadalajara, Mexico, 26-30 September 2016.\n  \n  \n    The Removal of Large Space Debris Using Tethered Space Tug. Presentation for the 5th Eucass - European Conference for Aerospace Sciences - Munich, Germany, 1-4 July 2013.\n  \n  \n    Dynamics of towed non-functional satellite by tether\n  \n\n\n",
      "url": "/pages/presentations/"
    },{
      
      "title": "Задача Прима-Краскала",
      
      "content": "Дана плоская страна и в ней n городов. Нужно соединить все города телефонной связью так, чтобы общая длина телефонных линий была минимальной.\nВ декартовой системе координат положение \\(i\\)-го города, \\(i = 1,...,n\\), задано парой координат \\((x[i],y[i])\\). \\(d[i,j]\\) - декартово расстояние между i-ым городом и j-ым городом , \\(j=1,...,n\\). В задаче речь идет о телефонной связи, т. е. подразумевается транзитивность связи: если i-й город связан с j-ым, а j-ый с k-ым, то i-й связан с k-ым.\n\nИсточник: http://pkgn.ru/do/TRPP/TrppKurs.pdf\nАлгоритм Краскала\n\nСписок заданий\n",
      "url": "/pages/python/course_works/prima/"
    },{
      
      "title": "Задание 2.",
      "description": "Динамика твёрдого тела и систем тел\n",
      "content": "\n\nОриентация системы координат \\(C x_c y_c z_x\\), связанной с космическим аппаратом по отношению к орбитальной системе координат определяется углом рыскания, углом тангажа и углом крена в указанной последовательности. Первый разворот на угол рыскания \\(\\psi\\) выполняется вокруг оси \\(C x_c\\), второй разворот на угол на угол тангажа \\(\\vartheta\\) вокруг оси \\(C z_c\\), третий поворот на угол собственного вращения \\(\\varphi\\) вокруг оси \\(C y_c\\). При нулевых значениях углов система координат, связанная с космическим аппаратом, совпадает с орбитальной системой координат.\n\nВ момент времени \\(t_1\\) ориентация космического аппарата определялась углами \\(\\psi_1 = 10^o\\),  \\(\\vartheta_1 = 5^o\\) и \\(\\varphi_1 = 0^o\\). В момент времени \\(t_2\\) ориентация космического аппарата определялась углами \\(\\psi_2 = 40^o\\),  \\(\\vartheta_2 = 30^o\\) и \\(\\varphi_1 = -10^o\\).\n\n\n  Запишите кватернион \\(\\Lambda_1\\) преобразования координат вектора из системы, связанной с КА в момент времени \\(t_1\\), в орбитальную систему координат:\n\\(R^{(0)} = \\Lambda_1 \\circ R^{(1)} \\circ \\bar{\\Lambda}_1\\)\n  Запишите кватернион \\(\\Lambda_2\\) для преобразования координат из системы, связанной с КА в момент времени \\(t_2\\), в орбитальную систему координат:\n\\(R^{(0)} = \\Lambda_2 \\circ R^{(2)} \\circ \\bar{\\Lambda}_2\\)\n  Запишите кватернионы для преобразования координат из системы, связанной с КА в момент времени \\(t_1\\), в систему, связанную с КА в момент времени \\(t_2\\):\n\\(R^{(2)} = \\Lambda_{21} \\circ R^{(1)} \\circ \\bar{\\Lambda}_{21}\\)\n  Запишите матрицу преобразования координат из системы, связанной с КА в момент времени \\(t_1\\) в систему координат, связанную с КА в момент времени \\(t_2\\).\n  Сравните результаты преобразования координат произвольного вектора, используя кватернион и матрицу.\n\n",
      "url": "/pages/mbs/quat/"
    },{
      
      "title": "Темы рефератов курса \"Управление IT-сервисом и контентом\"",
      
      "content": "Реферат оформляется в соответствии с “СТО 02068410-004-2018 Общие требования к учебным текстовым документам” и представляется в виде презентации на одном из занятий.\n\n\n  Обзор ГОСТов серии 24. «Единая система стандартов автоматизированных систем управления».\n  Лицензирование программного обеспечения (свободные, несвободные, условно-бесплатные, коммерческие, BSD, MIT,…). Практика использования свободных лицензий на предприятиях.\n  Криптографические методы защиты информации (история, алгоритмы, программное обеспечение, правовое регулирование в области криптографии на территории России)\n  Электронная цифровая подпись (история, алгоритмы, программное обеспечение, правовое регулирование электронной цифровой подписи в России).\n  Реклама в Интернет: виды, особенности, эффективность.\n  Обзор одного из решений Service Desk.\n\n\n",
      "url": "/pages/it/referats/"
    },{
      
      "title": "Относительное орбитальное движение",
      
      "content": "Задание\n\nНаноспутник отделяется от космической станции в плоскости её орбиты под углом \\(\\alpha\\) к орбитальной скорости c заданной скоростью.\n\nСтанция движется по круговой орбите высотой h.\n\nВысота орбиты станции, скорость и направление отделения задаются в текстовом файле.\n\nПостроить траекторию движения наноспутника относительно станции в течение первых трёх орбитальных периодов станции для заданных значений скорости отделения спутника и угла \\(\\alpha\\).\n\nСкорость отделения (м/с) и угол отделения (градус) задаются пользователем в диалоговом режиме. Угол отсчитывается от направления орбитальной скорости станции против часовой стрелки.\n\nМетодические указания\n\nСписок заданий\n",
      "url": "/pages/python/course_works/relative_orbital_motion/"
    },{
      
      "title": "Продольные колебания стержня",
      
      "content": "Стержень, как система материальных точек, связанных пружинами\n\nПредставим однородный стержень постоянного сечения \\(A\\) массы \\(M\\) в виде системы \\(n\\) материальных точек, соединенных невесомыми линейно-упругими элементами – пружинами. Масса материальных точек:\n\n[m_i = M/n]\n\nЖесткость пружин:\n\n[c_i = n \\cdot \\frac{EA}{L}]\n\nгде \\(E\\) – модуль Юнга, \\(L\\) – длина стержня.\n\nУравнение движения массы \\(i\\) имеет вид (в проекции на горизонтальную ось \\(x\\) )\n\n[m_i \\ddot{x}i = -F_i + F{i+1}, \\quad i = 1, \\ldots, n-1]\n\nДля последней массы (\\(i=n\\))\n\n[m_n \\ddot{x}_n = -F_n]\n\nСилы, действующие на массы вычисляются следующим образом\n\n[F_k = c_k (x_k - x_{k-1} - l_0), \\quad k=2,\\ldots,n]\n\nДля первой точки\n\n[F_1 = c_1 (x_1 - l_0)]\n\nгде \\(l_0\\) - свободная длина пружины\n\n[l_0 = \\frac{L}{n}]\n\n\n\nПрограмма (файл-скрипт)\n\n% Модуль Юнга Н/м2\nE  = 1000000;\n% Площадь поперечного сечения стержня м2\nA  = 0.001;\n% Погонная масса кг/м\nmu = 10.0;\n% Длина стержня м\nL  = 1.0;\n% Масса стержня\nM   = L*mu;\n% Количество материальных точек, на которые разбивается стержень\nN   = 30;\n% Начальное расстояние между точками (l0)\np.L = L/N;\n% Масса материальной точки\np.m = M/N;\n% Жесткость пружин\np.c = N*E*A/L;\n%\n% Начальное положение точек\nx0  = (1:N)'/N*(L+0.1);\n% Начальная скорость\nvx0 = zeros(N,1);\n% Вектор состояния\nq0  = [x0;vx0];\n\n% Интегрирование\n[t, q] = ode113(@(t,q) dqdt(t,q,p),0:0.002:2,q0,odeset('RelTol',1e-8));\n\n% Вектор деформаций пружин\ndx = [q(:,1)-p.L (q(:,2:N) - q(:,1:N-1))-p.L];\n% Максимальная деформация\ndx_max = max(max(dx));\n% Минимальная деформация\ndx_min = -dx_max;\n% Открываем файл для записи видео\nv = VideoWriter('rod_d.avi');\nopen(v);\n% Фигура\nfigure('Position',[100 100 1920 1080]);\naxis([0 L*1.3,-0.5, 0.5]);\nset(gca,'FontSize',20);\ngrid on; hold on;\n% Палитра\ncolormap('jet');\n% Для каждого момента времени из таблицы результатов интегрирования\nfor i=1:size(t,1)\n    % Очищаем рисунок\n    cla;\n    % Массив деформаций пружин\n    dydx = ([q(i,1) diff(q(i,1:N))] - repmat(p.L,1,N));\n    % Вершины прямоугольников, изображающих пружины\n    % Каждый столбец содержит 4-ку координат для прямоугольника\n    % Координаты x   \n    vertex_x  = [0 q(i,1) q(i,1) 0; q(i,1:N-1)' q(i,2:N)' q(i,2:N)' q(i,1:N-1)'];\n    % Координаты y\n    vertex_y  = repmat([0.1 0.1 -0.1 -0.1],N,1);     \n    % Рисуем все прямоугольники сразу\n    % Третий аргумент - деформация каждой пружины для раскраски прямоугольника\n    patch(vertex_x', vertex_y', dydx,'FaceColor','flat');\n    % Приведение диапазона деформаций к диапазону цветов\n    caxis([dx_min dx_max]);\n    colorbar;\n    text(0.1,0.45,sprintf('T=%5.3f c. Длина стержня L=%5.3f м',t(i),q(i,N)),'FontSize',20);   \n    % График деформаций\n    fplot(@(x) interp1([0 q(i,1:N)],[0 dydx]*0.1/dx_max,x,'next'),[0 q(i,N)],'k-','LineWidth',1);\n    frame = getframe(gcf);\n    writeVideo(v,frame);\nend\nclose(v);\n\n\nФайл-функция правых частей дифференциальных уравнений движения системы материальных точек\n\nfunction dq = dqdt(t, q, p)\n\nn  = size(q,1)/2;\nx  = q(1:n);\n\n% Расстояние между точками для определения деформаций пружин\n% x1 (x2-x1) (x3-x2) (x4-x3) ... (xn - x_n-1)\nxdif = [x(1);diff(x)];\n\n% Из расстояний между точками вычитается свободная длина пружины\n% определяется деформация\n% x1-l0 (x2-x1)-l0 (x3-x2)-l0 (x4-x3)-l0 ... (xn - x_n-1)-l0\ndx   = xdif - repmat(p.L,n,1);\n\n% По деформации определяется сила\n% F = [-(x1-l0)*c -(x2-x1-l0)*c ...]\nF    = -dx*p.c;\n% На все точки, кроме последей, действуют еще силы со стороны соседней пружины справа\n% с противоположным знаком. На последнюю точку действует только одна пружина,\n% поэтому к действующей на нее силе добавляется ноль\nF    = F - [F(2:end); 0];\n\n% Ускорения точек\na    = F/p.m;\n% Результат работы функции -- скорости и ускорения точек\ndq   = [q(n+1:end);a];\n\nend\n\n\n\n\nСтержень, как распределённая система\n\nБабаков И.М. Теория колебаний. 4-е изд., испр. - М.: Дрофа, 2004. - 591 с\n\nУпругие свободные колебания однородного стержня постоянного сечения описываются линейным уравнением в частных производных с постоянными коэффициентами\n\n[\\frac{\\partial^2 y}{\\partial t^2} - c^2  \\frac{\\partial^2 y}{\\partial x^2} = 0]\n\nгде велчиина \\(c\\) представляет собой скорость распространения звука в материале стержня, зависящая от модуля упругости \\(E\\) материала и его плотности:\n\n[c^2 = \\frac{E \\cdot A}{\\mu}]\n\nВ последней формуле плотность материала стержня определяется отношением погонной массы \\(\\mu\\) к площади поперечного сечения \\(A\\).\n\nСложные малые колебания рассматриваемой системы с бесконечным числом степеней свободы представляются в виде суммы гармонических колебаний с частотами \\(p_i\\) и формами колебаний \\(d_i(x)\\), определяющих распределение деформаций по длине стержня\n\n[y_i(x,t) = d_i(x) \\sin (p_i \\cdot t + \\alpha_i)]\n\nгде \\(d_i(x)\\) – \\(i\\)-я форма главного колебания  – амлитудное значение деформации, как функция положения точки на стержне.\n\nПодстановка \\(y(x,t) = d(x) \\sin (p \\cdot t + \\alpha)\\) в уравнение движения приводит к уравнению собственных форм колебаний:\n\n[d’‘(x) + a^2 d(x) = 0]\n\nгде\n\n[a^2 = \\frac{p^2 \\mu}{EA}]\n\nРешение полученного однородного дифференциального уравнения второго порядка  имеет следующий вид:\n\n[d_i(x) = B \\cos a_i x + C \\sin a_i x]\n\nПостоянные \\(B\\) и \\(C\\) определяются из граничных условий – условий закрепления стержня. Например для закрпеленного с одной стороны стержня граничные условия будут иметь вид:\n\n[d(0) = 0]\n\n[d’(L) = 0]\n\nПодставляя эти граничные условия в решение, получим\n\n[B = 0]\n\nи\n\n[C a_i \\cos a_i L = 0]\n\nНетривиальное решение этого уравнения имеет вид:\n\n[\\cos a_i L  = 0 \\quad a_i = \\frac{1+2k}{2 L} \\pi, \\quad k=0,1,2,\\ldots,\\infty]\n\nТаким образом, ряд сообственных частот продольных колебаний стержня c закреплённым (\\(x=0\\)) будет определяться следующим образом:\n\n[p_k = \\sqrt{\\frac{EA}{\\mu}} \\frac{1+2k}{2 L} \\pi, \\quad k=0,1,2,\\ldots,\\infty]\n\nОбщее решение имеет следующий вид\n\n[y(x, t) = \\sum_{i=1}^{\\infty} d_i(x) (M_i \\cos p_i t + N_i \\sin p_i t)]\n\nПостоянные \\(M_i\\), \\(N_i\\) определяются из начальных условий – распределения начальной деформации по длиней стержня:\n\n[y(x,0) = f(x)]\n\nи распределением начальных скоростей:\n\n[\\dot{y}(x,0) = \\gamma(x)]\n\nВ общем случае константы \\(M_i\\), \\(N_i\\) определяются следующим образом:\n\n[M_i = \\int_0^L d_i(x) f(x) dx]\n\n[N_i = \\frac{1}{p_i} \\int_0^L d_i(x)\\gamma(x) dx]\n\n% Модуль Юнга Н/м2\nE  = 1000000;\n% Площадь поперечного сечения м2\nA  = 0.001;\n% Погонная масса kg/м\nmu = 10.0;\n% Длина стержная м\nL  = 1.0;\n% Количество учитываемых собственных форм\nk  = 1:10;\na  = (2*k-1)*pi*0.5/L;\n% Массив частот\np  = a*sqrt(E*A/mu); % рад/с\n% Начальная деформация\n% К концу стержня приложена растягивающая сила F\nF  = 100; % Н\ny0 = @(xx) interp1(linspace(0,L,10),F*linspace(0,L,10)/(E*A),xx);\n% Постоянные, определяемые по начальным условиям (для частоты i)\nM  = @(i)  (2/L)*integral(@(xx) y0(xx).*sin(a(i).*xx),0, L);\nM  = @(i)  (2*F/(L*E*A))*sin(a(i)*L)/(a(i)^2.0);\n% Начальная скорость деформаций равна нулю, поэтому (для частоты i)\nN  = @(i) 0;\n% Слагаемые общего решения\nyk = @(i,t,x) (M(i)*cos(p(i)*t)+N(i)*sin(p(i)*t))*sin((2*i-1)*pi*x*0.5/L);\n% Слагаемые деформации\nek = @(i,t,x) (M(i)*cos(p(i)*t)+N(i)*sin(p(i)*t))*cos((2*i-1)*pi*x*0.5/L)*(2*i-1)*pi*0.5/L;\n% Общее решение y(t,x)\ny   = @(t,x) sum(arrayfun(@(i) yk(i,t,x),k));\n% Деформация\neks = @(t,x) sum(arrayfun(@(i) ek(i,t,x),k));\n% ------------------------------------------------------------------------\n% Рисуем\n% ------------------------------------------------------------------------\n% Видео\nv = VideoWriter('rod_c.avi');\nopen(v);\n\n% Разделяем балку на 30 частей (для раскраски)\nx = linspace(0,L,30);\nfigure('Position',[100 100 900 600]);\naxis([0 1.3 -0.5 0.5]);\nhold on;\n% Цветовая палитра JET\ncmap = colormap(jet(128));\n% Максимальная деформация\nmaxd =  0.2;\nmind = -0.2;\ndef2index = @(d) floor((d-mind)/((maxd-mind)/size(cmap,1)));\nfor t=0:0.002:2\n    cla;\n    yx = arrayfun(@(xx) y(t,xx),x);    \n    pos = x + yx;    \n    defx = arrayfun(@(xx) eks(t,xx),x);\n    for j = 1:size(x,2)\n        col = cmap( def2index(defx(j)),:);\n        prev_point = 0;\n        if j ~= 1\n            prev_point = pos(j-1);\n        end\n        patch([prev_point pos(j) pos(j) prev_point],...\n              [0.1 0.1 -0.1 -0.1],col,'EdgeColor','none');            \n    end\n    plot(pos, arrayfun(@(xx) eks(t,xx),x));\n    xlabel('x, м');ylabel('y, м');box('on');\n\n    text(0.1,0.45,sprintf('T=%5.3f c. Длина стержня L=%5.3f м',t,yx(end)+L));    \n    text(0.1,0.35,sprintf('Частоты (Гц): '));    \n    text(0.1,0.31,sprintf('%3.1f | ',(2*pi./p).^-1));    \n\n    frame = getframe;    \n    writeVideo(v,frame);    \nend\nclose(v);\n\n\n\n",
      "url": "/pages/matlab/rod/"
    },{
      
      "title": "Пользовательские функции и файл-скрипты",
      
      "content": "Файл-скрипт\n\nЛюбую последовательность команд в MATLAB можно оформить в виде m-файла.\n\n\n\n\n  Файл-скрипт не имеет входных и выходных аргументов.\n  Файл-скрипт работает с данными из рабочей области.\n  Все переменные, объявленные в файл-скрипте, являются глобальными.\n\n\nСтруктура файл-скрипта\n\n% Файл-скрипт my_script.m\n% Комментарий,\n% который появляется при вызове команды\n% help my_script\n\nx = 0:0.1:0.1;\ny = sin(x);\n\nplot(x,y);\n\n\nЗапустить, или другими словами выполнить последовательность действий, записанных в файл-скрипте, можно несколькими способами\n\n  запустить скрипт из редактора, нажав F5 (MS Windows)\n  набрать в консоли (Command window) имя скрипта и нажать Enter.\n\n\nВо втором случае файл-скрипт должен находится в текущем (рабочем) каталоге\n\n\n\nили в списке каталогов, которые просматривает MATLAB. Этот список можно изменить нажав кнопку Set Path\nна ленте Home\n\n\n\nФайл-скрипт можно для удобства разделить на секции при помощи удвоенного знака процента %%. Код в каждой секции можно выполнить отдельно от остального кода, нажав F9 (MS Windows), когда курсор находится в нужной секции.\n\n\n\nФайл-функции\n\nСобственные функции можно создавать тремя основными способами, используя\n\n\n  inline функции\n  анонимные функции\n  файл-функции\n\n\nInline-функции\n\nInline-функция объявляется при следующим образом:\n\n&gt;&gt; f1 = inline('x1^2+x2^2', 'x1', 'x2');\n&gt;&gt; f1(4,2)\n\n\nт.е. вызывается функция inline, в которую первым аргументов передается строка - выражение от аргументов функции, которые передаются следующим аргументами также в виде строк. В выражениях inline-функций не могут использоваться имена переменных из рабочей среды, а только переменные – аргументы, объявленные в функции inline.\n\nВызывается объявленная inline, как и любая другая функция, например, для объявленной выше функции двух переменных:\n\n&gt;&gt; f1(4,2)\n\n\nАнонимные функции\n\nБолее практичны в сравнении с inline-функциями анонимные функции, которые могут содержать имена переменных из рабочей среды. Анонимные функции также можно использовать для объявления коротких однострочных функций, создание для которых отдельных m-файлов нецелесообразно.\n\nАнонимная функция объявляется при помощи символа @, за которым в круглых скобках следуют аргументы функции, а затем её выражение, например, для объявления функции\n\n[f(x_1, x_2) = x_1^2 + x_2^2]\n\nнеобходимо написать\n\n&gt;&gt; f = @(x1,x2) x1^2+x2^2;\n\n\nАнонимные функции удобно использовать внутри выражений, например для построения графика функции \\(x^2 + sin(x)\\) на интервале от 0 до 5 можно написать\n\n&gt;&gt; f = @(x) x.^2 + sin(x);\n&gt;&gt; fplot( f, 0, 5 );\n\n\nно проще использовать анонимную функцию прямо в функции fplot\n\n&gt;&gt; fplot( @(x) x.^2 + sin(x), 0, 5);\n\n\nФайл-функция\n\n\n  Файл-функция содержит определение одной или нескольких функций.\n  По-умолчанию все переменные, объявленные внутри файл-функции, являются локальными.\n  Файл-функция является самостоятельным программным модулем, который связан с другими модулями и головной программой через входные и выходные параметры.\n\n\nСоздание файл-функции: File -&gt; New -&gt; Function\n\n\n\n% Комментарий к функции\n% \nfunction [res1, res2] my_function(x1, x2)\n    res1 = x1^2 + x2^2;\n    res2 = x1 + x2;\n\n\nПо умолчанию все переменные внутри функции являются локальными. Для того, чтобы несколько функций использовали одну переменную, её необходимо объявить глобальной.\n\n% Комментарий к функции\n% \nfunction [res1, res2] my_function(x1, x2)\n    global g;\n    res1 = g + x1^2 + x2^2;\n    res2 = x1 + x2;\n\n\nИмя файла и имя объявленной в нем функции должны совпадать. Как и для файл-скриптов каталог, в котором содержатся вызываемые функции, должен быть текущим (рабочим) или добавлен в список просматриваемых MATLAB.\n\nФункция прекращает работу после выполнения последнего оператора. Принудительно завершить функцию можно директивой return.\n\nФайл-функция вместе с определением основной функции может содержать определения вспомогательных функций, доступных к вызову только из основной функции. Переменные, используемые во внутренних функциях локальные.\n\nfunction f = myfun(x)\n    f1 = infun(x);\n    f  = f1 + cos(x);\n\n% Внутренняя функция\nfunction res = infun(x)\n    a = 3;\n    res = sin(x*3);\n\n\n",
      "url": "/pages/matlab/scripts/"
    },{
      
      "title": "SQL-запросы",
      
      "content": "Описание базы данных\n\nОписание БД\n\nЗадание\n\nПостройте SQL-запросы для получения следующей информации из базы данных.\n\nЧасть 1\n\n\n  Количество товаров, поступивших до заданной даты\n  Количество товаров заданной категории\n  Количество товаров в каждой категории (таблица вида: категория, количество)\n  Количество товаров заданного производителя\n  Количество товаров по каждому производителю (таблица вида: имя производителя, количество)\n  Постройте запрос, возвращающий два столбца: наименование товара, категория\n  Постройте запрос, возвращающий два столбца: наименование товара, производитель\n  Постройте запрос, возвращающий два столбца: Дата покупки, фамилия покупателя\n  Постройте запрос, возвращающий два столбца: фамилия покупателя, общее количество покупок (не товаров)\n  Постройте запрос, возвращающий два столбца: дата покупки, фамилия покупателя, филиал\n  Список товаров, отсортированных по наименованию (по алфавиту)\n  Список покупок (purchases), отсортированных дате\n  Даты последних 5 покупок (purchases)\n  Даты первых 5 покупок (purchases)\n  Фамилии последних 5 покупателей\n  Фамилии первых 5 покупателей\n\n\nЧасть 2\n\n\n  Список первых 3 клиентов, купивших товаров на максимальную сумму в заданном диапазоне дат\n  Список первых 3 клиентов, купивших максимальное количество товара в заданном диапазоне дат\n  Товар, который покупали чаще всего в заданном диапазоне дат\n  Товар, который покупали чаще всего в заданном диапазоне дат по филиалам\n  Средний чек в диапазоне дат\n  Средний чек в диапазоне дат по филиалам\n  Суммарная стоимость проданных товаров каждого филиала в диапазоне дат\n  Суммарная стоимость проданных товаров в диапазоне дат\n  Список филиалов по убыванию объема продаж (суммарная стоимость) до заданной даты\n  Список филиалов по убыванию количества проданного товара до заданной даты\n  Список товаров с указанием проданного количества товара в каждом магазине до заданной даты\n  Список товаров, проданных в заданном филиале до заданной даты\n  Список клиентов, покупавших любой товар в заданном магазине до заданной даты\n  Список клиентов, покупавших любой товар в двух магазинах сети\n  Список клиентов, покупавших любой товар во всех магазинах сети\n  Количество товара каждой категории, проданных в филиале до заданной даты\n  Количество товара каждой категории, проданных во всех филиалах до заданной даты\n  Суммарная стоимость товаров по филиалам на заданную дату\n  Суммарная стоимость товаров во всех филиалах на заданную дату\n  Количество товаров в каждом филиале на заданную дату\n  Какого товара меньше всего осталось в каждом из филиалов на заданную дату?\n  Какого товара больше всего осталось в каждом из филиалов на заданную дату?\n  Количество товаров каждого наименования во всех филиалах на заданную дату\n  Остатки товаров каждого наименования в филиале на заданную дату\n  Список пяти самых дешевых товаров в филиале на заданную дату\n  Список пяти самых дорогих товаров в филиале на заданную дату\n  Дата, в которую поступило товара на максимальную сумму в заданный филиал\n  Суммарная стоимость поступивших товаров на каждую дату поступления в заданный филиал\n  Суммарная стоимость товаров каждого производителя в филиале на дату\n  Суммарное количество товаров каждого производителя в филиале на дату\n  Суммарное количество проданных товаров каждого производителя в филиале до заданной даты\n  Суммарная стоимость проданных товаров каждого производителя в филиале до заданной даты\n  Суммарная стоимость проданных товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество проданных товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество поступивших товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество поступивших товаров каждого производителя в филиал до заданной даты\n  Суммарная стоимость поступивших товаров каждого производителя в филиал до заданной даты\n  Изменение суммарной стоимости товаров заданного производителя в филиале в диапазоне дат\n\n\nМетодические рекомендации\n\nПри работе с базой данных SQLite необходимо учитывать, что даты в таблицах SQLite хранятся в виде целого числа, которое представляет собой количество секунд прошедших с начала (по Гринвичу) первого января 1970 года – Unix-время (этот момент называют Unix-эпохой). Эту особенность представления даты и времени в SQLite следует учитывать при выводе (форматировании) и сравнении дат.\n\nНапример, следующий сценарий выводит таблицу имен покупателей с датами совершенных ими покупок до 20 января 2019 года.\n\nselect \n\tcustomers.customer_name, strftime(\"%d.%m.%Y\", purchase_date, 'unixepoch') as purchase_date_string\nfrom \n\tpurchases\nleft join \n\tcustomers on customers.customer_id  = purchases.customer_id \nwhere \n\tpurchase_date &lt; CAST(strftime('%s', '2019-01-20') AS INTEGER)\norder by \n\tpurchase_date;\n\n\nРезультат\n\ncustomer_name                |purchase_date_string|\n-----------------------------|--------------------|\nГусев Пров Дмитриевич        |06.01.2019          |\nБорисова Евдокcия Григорьевна|06.01.2019          |\nДорофеев Митофан Демидович   |10.01.2019          |\n\n\nВ этом сценарии для преобразования из внутреннего Unix-времени в “читаемый” текстовый формат даты ГГГГ.ММ.ДД  используется функция strftime, которая преобразует числовое значение даны в строку в соответствии с заданным форматом, который передается первым аргументом функции. Второй аргумент функции  strftime – столбец таблицы, который содержит дату, “закодированную” целым числом. Третий аргумент – формат хранения даты ‘unixepoch’.\n\nДля того, чтобы сравнить заданную текстовым представлением дату (в примере это ‘2019-01-20’) со значением в таблице, например, в условии WHERE, необходимо преобразовать строку в ГГГГ-ММ-ДД в строку, представляющую целое число секунд с Unix-эпохи, а затем преобразовать эту строку в целое число, которое и будет сравниваться со значениями в столбце purchase_date таблицы. Для преобразования из строки в целое число используется функция CAST(СТРОКА AS INTEGER), например результатом работы функции CAST(‘123’ AS INTEGER) будет целое число 123.\n\nПри работа с базой данных из среды Python, преобразование даты в формат Unix-времени и обратно можно выполнять в коде, используя метод объекта datetime – datetime.timestamp(), например:\n\nimport sqlite3\nimport datetime\nfrom tabulate import tabulate \n\npath = \"./drive/My Drive/databases/goods.db\"\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"\"\"\nSELECT \n  customers.customer_name, purchases.purchase_id, COUNT(purchase_items.product_id)\nFROM\n  purchase_items \nLEFT JOIN \n  purchases on purchase_items.purchase_id = purchases.purchase_id\nLEFT JOIN \n  customers on customers.customer_id = purchases.customer_id\nWHERE \n  purchases.purchase_date BETWEEN ? AND ? \nGROUP BY \n  purchases.purchase_id\nORDER BY \n  customer_name\n\"\"\"\n\ncursor.execute(sql,(datetime.datetime(2019,8,1).timestamp(),  \n                    datetime.datetime(2020,1,1).timestamp() ))\n\nrows = cursor.fetchall()\nprint(tabulate(rows))\n\ncursor.close()\nconn.close()\n\n\n\n",
      "url": "/pages/databases/sql/"
    },{
      
      "title": "Основы работы c SQLite",
      "description": "Работа в Google Colab с базой данных SQLite, расположенной на диске Google Drive\n",
      "content": "Google Colab позволяет выполнять программы, написанные на языке Python прямо в браузере без необходимости установки на компьютер дополнительного программного обеспечения.\n\nДля использования Google Colab необходимо иметь учетную запись Google. Если вы используете смартфон на платформе Android, то такая учетная запись у вас уже есть, однако для безопасности вашей основной учетной записи рекомендуется создать новую учетную запись на время выполнения лабораторных работ.\n\nАдрес Google Colab: https://colab.research.google.com.\n\nДоступ к Google Drive для хранения базы данных\n\nБаза данных может храниться локально, на том же компьютере, на котором запускается прикладное программное обеспечение для работы с базой данных или на удаленном компьютере.\n\nGoogle Colab (точнее Python, запускаемый в среде Google Colab) позволяет работать и с условно «локальной» базой данных и с базой данных на удаленном сервере. В первом случае может использоваться СУБД SQLite, которая будет хранится на облачном диске Google Drive. Для среды Google Colab это будет локальная БД.\n\nДля доступа к диску Google Drive сервису Google Colab необходимо дать разрешение на подключение к диску. К сожалению  Google Colab через каждые 12 часов «забывает» полученные ранее разрешения, поэтому через каждые 12 часов необходимо заново разрешать доступ Google Colab к вашему облачному диску. Данные (файл базы данных SQLite) в Google Colab конечно сохраняются.\n\nДля подключения и разрешения доступа Google Colab к диску Google Drive можно использовать следующий код:\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\n\n\nGoogle Colab предложит перейти по предложенной ссылке для разрешения доступа к диску\n\n\n\nПосле того, как вы разрешите доступ к диску Google Drive, появится окно с кодом, который нужно вставить в показанное выше поле “Enter your authorization code”:\n\n\n\nПосле ввода кода и нажатия Enter появится сообщение о том, что диск подключен “Mounted at /content/drive/”.\n\n\n\nПодключение к базе данных\n\nПодключаем модуль для работы с базой SQLite\n\nimport sqlite3\n\n\nСоздаем на диске Google каталог databases. Указываем путь к будущей (или уже существующей) базе данных.\n\n\n\npath = \"./drive/My Drive/databases/mydatabase.db\"\n\n\nПодключаемся к базе mydatabase.db. Если этого файла нет в каталоге, то он будет создан.\n\nconn = sqlite3.connect(path)\n\n\nСоздание таблицы\n\nСоздадим таблицу музыкальных альбомов (albums) с пятью столбцами:\n\n\n  \n    \n      title\n      artist\n      release_date\n      publisher\n      media_type\n    \n  \n  \n    \n      Наименование альбома\n      Исполнитель\n      Дата выхода\n      Издатель\n      Тип носителя\n    \n  \n\n\n# Создаем объект типа cursor для доступа к данным\ncursor = conn.cursor()\n# Создание простейшей таблицы, все поля (столбцы) которой имеют тип text\ncursor.execute(\"CREATE TABLE albums (title text, artist text, release_date text, publisher text, media_type text)\")\n# Подтверждаем изменения (обязательно)\nconn.commit()\n# Закрываем курсор\ncursor.close()\n# Закрываем соединение (рекомендуется)\nconn.close()\n\n\nДобавление записей в таблицу\n\nДобавление в таблицу двух строк:\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"INSERT INTO albums VALUES (?, ?, ?, ?, ?)\"\nval1 = (\"The Serpen't Egg\", \"Dead Can Dance\", \"1988\", \"4AD\", \"CD\")\nval2 = (\"Everyday Is Christmas\", \"SIA\", \"2017\", \"Atlantic\", \"CD\")\ncursor.execute(sql, val1)\ncursor.execute(sql, val2)\nconn.commit()\ncursor.close()\nconn.close()\n\n\nЗапрос данных из таблицы\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"SELECT artist, title, release_date from albums\"\ncursor.execute(sql)\n\nfor i in cursor:\n    print(i)\n\ncursor.close()\nconn.close()\n\n\nДля наглядного представления табличных данных можно использовать библиотеку pandas:\n\nimport pandas as pd\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"SELECT artist, title, release_date from albums\"\ncursor.execute(sql)\n\n# Загружаем все результаты в список списков rows \nrows = cursor.fetchall()\ncursor.close()\nconn.close()\n\n\nСоздаем объект DataFrame на основе списка rows, указывая наименования столбцов (columns=…):\n\npd.DataFrame( rows, columns=('Исполнитель', 'Альбом', 'Год') )\n\n\nРезультат будет выглядеть так:\n\n\n\n\n\n",
      "url": "/pages/databases/sqlite_start/"
    },{
      
      "title": "Структуры",
      
      "content": "Структура это тип данных, который позволяет объединить группу связанных данных в рамках одного имени.\n\nСоздание структуры\n\n&gt;&gt; a.x = 1:5;\n&gt;&gt; a.y = sin(a.x);\n&gt;&gt; a\n\na = \n  struct with fields:\n    x: [1 2 3 4 5]\n    y: [0.8415 0.9093 0.1411 -0.7568 -0.9589]\n\n\nВ приведенном выше примере структура a имеет два поля (свойства, атрибута) x и y, в которых хранятся матрицы строки. Структура может хранить данные любых типов\n\n&gt;&gt; a.Description = 'Описание структуры'\n\na = \n  struct with fields:\n              x: [1 2 3 4 5]\n              y: [0.8415 0.9093 0.1411 -0.7568 -0.9589]\n    Description: 'Описание структуры'\n\n\nДля создания структуры может использоваться функция struct\n\nСоздание пустой структуры\n\ns = struct\n\ns = \n  struct with no fields.\n\n\nСоздание структуры парами имя поля  – значение. Имена полей задаются строковыми константами\n\n&gt;&gt; s = struct('x',[1 2 3],'y',[10 20 30])\n\ns = \n  struct with fields:\n    x: [1 2 3]\n    y: [10 20 30]\n\n",
      "url": "/pages/matlab/struct/"
    },{
      
      "title": "Структурное программирование",
      
      "content": "Оператор ветвления\n\nОператор ветвления выполняет фрагмент кода только при выполнении некоторого условия. В самом простом виде оператор ветвления в MATLAB записывается следующим образом:\n\nif a &lt; 10\n    x = 1;\nend\n\n\nПеременной x будет присвоено значение 1, если значение переменной a будет меньше 10. Если необходимо выполнить определенный код в случае невыполнения условия, то оператор if можно записать в следующем виде\n\nif a &lt; 10\n    x = 1;\n    z = 5;\nelse\n    x = 2;\n    z = 10*x;\nend\n\n\nПри наличии нескольких условий и нескольких фрагментов кода, исполняемых при выполнении этих условий, используется следующая структура оператора ветвления\n\nif a &lt; 10 \n    x = 1;\nelseif a &gt; 20\n    x = 2;\nelse \n    x = 3;\nend\n\n\nВ результате выполнения этого кода переменная x будет равна 1 если a меньше 10, 3 – если a больше 20 и 2 если а будет принадлежать интервалу от 10 до 20.\n\n\n  \n    \n      В выражениях-условиях могут применятся логические операторы И (&amp;&amp;), ИЛИ (\n       \n      ), НЕ (~):\n    \n  \n\n\nif a &gt;= 10 &amp;&amp; a &lt;= 20 \n    x = 3;\nelseif a &gt; 20\n    x = 2;\nelse \n    x = 1;\nend\n\n\nЦикл for\n\nЦикл for позволяет заданное количество раз выполнить фрагмент кода. В  MATLAB  цикл for определяется при помощи ключевого слова for, обозначающего заголовок цикла и end, обозначающего окончание выполняемого в цикле блока кода.\n\nСледующий код\n\nfor i = 1:10\n    fprintf('%i - %3.1f', i, cos(i/2.0))\nend\n\n\nвыведет на таблицу значений аргумента и функции \\(\\cos i/2\\) для \\(i\\) изменяющегося в диапазоне от 1 до 10 с шагом 1 (1:10), как указано в заголовке цикла\n\n  1   0.9\n  2   0.5\n  3   0.1\n  4  -0.4\n  5  -0.8\n  6  -1.0\n  7  -0.9\n  8  -0.7\n  9  -0.2\n 10   0.3\n\n\nПеременная \\(i\\) в приведённом примере называется переменной-интератором. Эта переменная принимает значения в соответствии с заданной последовательностью (от 1 до 10).\n\nВ заголовке цикла в качестве ‘источника’ значений для переменной-итератора может быть матрица строка. Например, результат работы следующего примера будет точно таким же, как и у предыдущего\n\na = 1:10;\nfor i = a\n    fprintf('%i - %3.1f', i, cos(i/2.0))\nend\n\n\nЕсли в качестве источника используется матрица, то переменная-итератор будет принимать значений столбцов этой матрицы. В результате работы следующего кода\n\na = [1 2 3; 4 5 6];\nfor i = a\n    i\nend\n\n\nцикл выполнится 3 раза и переменна \\(i\\) будет принимать значения [1; 4], [2; 5] и [3; 6].\n\nВ MATLAB следует избегать использования циклов. Использование циклов приводит к снижению скорости выполнения кода. Где это возможно, циклы следует заменять матричными операциями.\n\nРассмотрим для примера код, который вычисляет количество четных чисел в случайно последовательности\n\na = round(rand(1,10)*20);\n\n\nВ цикле for переменная el последовательно принимает значения элементов из матрицы-строки a. В теле цикла определяется остаток от деления элемента последовательности на 2, и если этот остаток равен 0 (число четное), то этот элемент добавляется к переменной-сумматору s. После выхода из цикла переменная s будет содержать сумму чётных элементов матрицы строки a.\n\ns = 0;\n% перебираем все значения из массива a\n% следующая строка читается как \"ДЛЯ каждого элемента el из a\"\nfor el = a\n    %  ЕСЛИ остаток деления на 2 равен нулю, то el это \n    %  чётное число и его добавляем в сумматор\n    if mod(el,2) == 0\n       s = s + el;\n    end\nend\ns\n\n\nЭтот код можно заменить одной строкой\n\ns = sum(a(mod(a,2)==0))\n\n\nРезультатом работы выражения mod(a,2)==0 является логическая матрица-строка, равная по форме исходной матрице-строке a, в логической матрице на местах четных элементов матрицы a стоят 1 (ИСТИНА), на местах остальных элементов нули\n\n&gt;&gt; mod(a,2)==0\n\nans =\n  1×10 logical array\n   1   1   0   0   1   1   0   0   1   1\n\n\nэтот результат используется в качестве индекса оператора () для извлечения четных элементов из матрицы a\n\n&gt;&gt; a(mod(a,2)==0)\n\nans =\n     6    14     2    10    12     4\n\n\nдалее определяется сумма всех извлеченных элементов при помощи функции sum.\n\nЦикл while (пока)\n\nЦикл while используется при необходимости выполнения фрагмента кода (тела цикла), пока выполняется некоторое условие. Предположим, что необходимо вычислить сумму первой последовательной цепочки четных чисел заданной матрицы-строки\n\n% Последовательность\na = [2 4 8 3 2 5 6 7];\n% Сумматор\ns = 0;\n% Начальное значение индекса числа в массиве a\ni = 1;\n% Если i-ое число четное И (&amp;&amp;) его номер не больше 8 (количество элементов в массиве а)\nwhile mod(a(i),2)==0 &amp;&amp; i &lt;= numel(a)\n    % ТО добавляем это число в сумматор\n    s = s + a(i);\n    % переходим к следующему индексу (увеличиваем на 1)\n    % иначе цикл станет бесконечным\n    i = i + 1;\nend\n\n\nПосле ключевого слова while в заголовке цикла указывается логическое выражение. Цикл будет выполнятся до тех пор, пока результатом этого выражения будет ИСТИНА. Цикл while может не выполниться ни одного раза, если при входе в цикл результатом логического выражения будет ЛОЖЬ.\n\n",
      "url": "/pages/matlab/structural/"
    },{
      
      "title": "Таблицы",
      
      "content": "Объект table для представления данных в табличном виде, но в отличие от обычной матрицы таблица может содержать данные разных типов.\n\nПример таблицы, которая в первом столбце содержит строковые данные, а во втором столбце – числовые:\n\n&gt;&gt; T1 = table( {'AA'; 'AB'; 'BA'}, (1:3)' )\n\nT1 =\n  3×2 table\n    Var1    Var2\n    ____    ____\n    'AA'     1  \n    'AB'     2  \n    'BA'     3  \n\n\nСледует обратить внимание, что были переданы матрица-столбец ячеек и числовая матрица-столбец. Если передать строки, то результатом будет таблица, содержащая одну строку с матрицей ячеек в первом столбце и матрицей-строкой во втором\n\n&gt;&gt; T1 = table( {'AA', 'AB', 'BA'}, (1:3) )\n\nT1 =\n  1×2 table\n            Var1               Var2    \n    ____________________    ___________\n    'AA'    'AB'    'BA'    1    2    3\n\n\nСтолбцам таблицы были автоматически присвоены имена ‘Var1’ и ‘Var2’. Эти имена можно использовать для обращения к столбцам\n\n&gt;&gt; T1.Var1\n\nans =\n  3×1 cell array\n    {'AA'}\n    {'AB'}\n    {'BA'}\n\n&gt;&gt; T1.Var2\n\nans =\n     1\n     2\n     3\n\n\nПри создании таблицы можно задать имена столбцов при помощи свойства VariableNames\n\n&gt;&gt; T1 = table( {'AA'; 'AB'; 'BA'}, (1:3)', 'VariableNames', {'Variant', 'Value'} )\n\nT1 =\n  3×2 table\n    Variant    Value\n    _______    _____\n     'AA'        1  \n     'AB'        2  \n     'BA'        3  \n\n\nМожно создать пустую таблицу заданных размеров, при этом необходимо указать тип данных для каждого столбца\n\n&gt;&gt; T = table('Size',[5 3],'VariableTypes',{'string','double','datetime'})\n\nT =\n  5×3 table\n      Var1       Var2    Var3\n    _________    ____    ____\n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n\n\nЗаполняем первую строку таблицы\n\n&gt;&gt; T.Var1(1) = 'Вариант 1';\n&gt;&gt; T.Var2(1) = 5;\n&gt;&gt; T.Var3(1) = datetime(2020,5,20);\n&gt;&gt; T\n\nT =\n  5×3 table\n       Var1        Var2       Var3    \n    ___________    ____    ___________\n    \"Вариант 1\"     5      20-May-2020\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n\n\nПри создании таблицы можно задать имена строк\n\n&gt;&gt; T = table('Size',[3 3],'VariableTypes',{'string','double','datetime'}, 'RowNames', {'Иванов', 'Петров', 'Сидоров'});\n\nT =\n  3×3 table\n                 Var1       Var2    Var3\n               _________    ____    ____\n    Иванов     &lt;missing&gt;     0      NaT \n    Петров     &lt;missing&gt;     0      NaT \n    Сидоров    &lt;missing&gt;     0      NaT \n\n\nИмя строки может использоваться для доступа к элементу таблицы\n\n&gt;&gt; T({'Иванов'},1) = {'Хорошо'}\n\nT =\n  3×3 table\n                 Var1       Var2    Var3\n               _________    ____    ____\n    Иванов     \"Хорошо\"      0      NaT \n    Петров     &lt;missing&gt;     0      NaT \n    Сидоров    &lt;missing&gt;     0      NaT \n\n\nЭтот же элемент таблицы можно изменить, используя имя столбца и номер строки\n\n&gt;&gt; T.Var1{1} = 'Удовлетворительно'\n\nT =\n  3×3 table\n                      Var1            Var2    Var3\n               ___________________    ____    ____\n    Иванов     \"Удовлетворительно\"     0      NaT \n    Петров     &lt;missing&gt;               0      NaT \n    Сидоров    &lt;missing&gt;               0      NaT \n\n\n",
      "url": "/pages/matlab/table/"
    },{
      
      "title": "Компьютерные и экспериментальные методы в механике",
      
      "content": "Основы регрессионного анализа, полный факторный эксперимент\n\nМ. Ю. Черняк, М. С. Эльберг Планирование и организация эксперимента. Практикум. стр. 27.\n\nЗадания 1 - 4\n\nДля изучения зависимости некоторой величины от воздействующих факторов были поставлены эксперименты по плану ПФЭ \\(2^3\\). В качестве факторов (\\(X_1\\), \\(X_2\\), \\(X_2\\)), влияющих на отклик, были выбраны следующие:\n\n\n  \n    \n      Уровни факторов\n      \\(X_1\\)\n      \\(X_2\\)\n      \\(X_3\\)\n    \n  \n  \n    \n      Нижний\n      6\n      40\n      0.22\n    \n    \n      Основной\n      10\n      80\n      0.40\n    \n    \n      Верхний\n      14\n      120\n      0.31\n    \n  \n\n\nНа основании экспериментальных данных вывести математическую модель (линейную и нелинейную) в кодированных и натуральных значениях факторов.\n\nВариант 1\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      0.11\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.22\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.16\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.10\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.22\n      0.20\n      0.18\n    \n  \n\n\nВариант 2\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      1.10\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.18\n      0.20\n    \n    \n      0.18\n      0.16\n      0.16\n      0.16\n    \n    \n      0.14\n      0.12\n      0.12\n      0.16\n    \n    \n      0.11\n      0.12\n      0.12\n      0.10\n    \n    \n      0.24\n      0.23\n      0.23\n      0.21\n    \n    \n      0.20\n      0.22\n      0.22\n      0.18\n    \n  \n\n\nВариант 3\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.12\n      0.11\n      0.12\n    \n    \n      0.06\n      0.07\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.21\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.17\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.11\n      0.10\n    \n    \n      0.24\n      0.23\n      0.22\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nВариант 4\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.12\n      0.12\n      0.12\n    \n    \n      0.06\n      0.07\n      0.08\n      0.08\n    \n    \n      0.20\n      0.18\n      0.20\n      0.20\n    \n    \n      0.18\n      0.16\n      0.17\n      0.17\n    \n    \n      0.14\n      0.12\n      0.13\n      0.16\n    \n    \n      0.11\n      0.12\n      0.11\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nЗадания 5 - 6\n\nДля изучения зависимости некоторой величины от воздействующих факторов были поставлены эксперименты по плану ПФЭ \\(2^3\\). В качестве факторов (\\(X_1\\), \\(X_2\\), \\(X_2\\)), влияющих на отклик, были выбраны следующие:\n\n\n  \n    \n      Уровни факторов\n      \\(X_1\\)\n      \\(X_2\\)\n      \\(X_3\\)\n    \n  \n  \n    \n      Нижний\n      3\n      11\n      0.2\n    \n    \n      Основной\n      7\n      26\n      0.25\n    \n    \n      Верхний\n      11\n      41\n      0.3\n    \n  \n\n\nНа основании экспериментальных данных вывести математическую модель (линейную и нелинейную) в кодированных и натуральных значениях факторов.\n\nВариант 5\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      0.11\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.22\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.16\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.10\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nВариант 6\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      1.10\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.18\n      0.20\n    \n    \n      0.18\n      0.16\n      0.16\n      0.16\n    \n    \n      0.14\n      0.12\n      0.12\n      0.16\n    \n    \n      0.11\n      0.12\n      0.12\n      0.10\n    \n    \n      0.24\n      0.23\n      0.23\n      0.21\n    \n    \n      0.20\n      0.21\n      0.22\n      0.18\n    \n  \n\n\n",
      "url": "/pages/stat/task1/"
    },{
      
      "title": "Анализ текста",
      
      "content": "Написать программу, которая для загруженного текста из файла определяет:\n\n  количество знаков с пробелами;\n  количество знаков без пробелов;\n  количество знаков препинания;\n  количество слов;\n  максимальную длину слова;\n  среднюю длину слова;\n  количество предложений;\n  максимальную длину предложений (в словах);\n  среднюю длину предложений (в словах).\n\n\nВ отдельный текстовый файл программа должна вывести частотный словарь, каждая строка которого содержит слово и частоту его употребления.\n\nДля демонстрации работы программы использовать тексты из библиотеки http://lib.ru/\n\nСписок заданий\n",
      "url": "/pages/python/course_works/text/"
    },{
      
      "title": "Временные ряды",
      
      "content": "timeseries\nСправка MathWorks\n\nОбъект timeseries предназначен для представления изменяющихся в дискретном времени данных. Для создания временного ряда используется функция timeseries\n\n&gt;&gt; ts1 = timeseries((1:5)','Name','MyTimeSeries')\n  timeseries\n\n  Common Properties:\n            Name: 'MyTimeSeries'\n            Time: [5x1 double]\n        TimeInfo: [1x1 tsdata.timemetadata]\n            Data: [5x1 double]\n        DataInfo: [1x1 tsdata.datametadata]\n\n  More properties, Methods\n\n\nПри создании временного ряда ts первым аргументом был передан массив значений ряда от 1 до 5 с шагом 1 . Вторым аргументом задано имя временного ряда (свойство ‘Name’). Значения времени переданы не были, поэтому MATLAB задает эти значения автоматически, считая, что первая точка данных (1) соответствует моменту времени 0, последняя 4. Это некоторые абстрактные значения, не привязанные к конкретным единицам времени. Значения времени содержаться в атрибуте (свойстве) объекта Time\n\n&gt;&gt; ts1.Time\n\nans =\n     0\n     1\n     2\n     3\n     4\n\n\nДля того, чтобы задать и массив значений времени и массив значений исследуемой функции используется следующий способ вызова функции timeseries\n\n&gt;&gt; ts1 = timeseries([1 3 2 5 7]',[0 10 20 30 40],'Name',' Ряд 1');\n\n\nПервый аргумент (1:5)’ это значения функции (данные), второй – соответствующие этим значениям временные метки. В примере это массив [0 10 20 30 40].\n\nВременными метками могут быть конкретные значения даты и времени, которые могут быть переданы в функцию timeseries в виде массива строк. Для того чтобы преобразовать массив дат в массив текстового представления этих дат используется функция datestr\n\n&gt;&gt; datestr(datetime(2020,04,1:5,12,0,0))\n\nans =\n  5×20 char array\n    '01-Apr-2020 12:00:00'\n    '02-Apr-2020 12:00:00'\n    '03-Apr-2020 12:00:00'\n    '04-Apr-2020 12:00:00'\n    '05-Apr-2020 12:00:00'\n\n\nТогда\n\n&gt;&gt; date_string_array  = datestr(datetime(2020,04,1:5,12,0,0));\n&gt;&gt; ts1 = timeseries([1 3 2 5 7]', date_string_array, 'Name', ' Ряд 1');\n\n\nОчень просто построить график временного ряда. Достаточно передать в функцию plot имя объекта timeseries\n\n&gt;&gt; plot(ts1);\n\n\nЧтобы метки дат на оси x отображались в нужном формате используем функцию datetick\n\n&gt;&gt; datetick('x','dd.mm.yy');\n\n\n\n\nНекоторые функции для работы с timeseries\n\nresample\n\nФункция пересчитывает значения временного ряда для новых значений времени, передаваемых в функцию вторым аргументом. Результатом работы функции  resample является новый временной ряд\n\n&gt;&gt; ts2 = resample(ts1,[3 12 25 31 39]);\n&gt;&gt; ts2.Data\n\nans =\n    1.6000\n    2.8000\n    3.5000\n    5.2000\n    6.8000\n\n\nДля сравнения двух временных рядов построим их графики на одном рисунке\n\n&gt;&gt; plot(ts1,'ro-');\n&gt;&gt; hold on;\n&gt;&gt; plot(ts2,'g^--');\n&gt;&gt; hold off;\n\n\n\n\nКак видно из результата, по умолчанию для пересчета значений используется линейная интерполяция. Способ интерполяции значений временного ряда задаётся функцией setinterpmethod\n\nts3 = setinterpmethod(ts2,'zoh');\n\n\nФункция возвращает новый временной ряд. Первый аргумент – преобразуемый временной ряд, второй – способ интерполяции значений. Возможны два варианта ‘zoh’ и ‘linear’. ‘zoh’ – интерполяция нулевого порядка, которая представляет временной ряд в виде кусочно-постоянной функции\n\nplot(ts3)\n\n\n\n\nФункция detrend\n\nФункция detrend удаляет из временного ряда постоянное число, равное среднему значению ряда, или линейную составляющую, вычисленную по методу наименьших квадратов.\n\nСоздадим временной ряд для интервала времени от 0 до 10 с шагом 0.2. Функция представляет собой сумму периодической функции с линейной функцией.\n\n&gt;&gt; t = 0:0.2:10\n&gt;&gt; y = sin(5*t)+3*t;\n&gt;&gt; ts1 = timeseries(y,t);\n\n\nСоздадим два новых временных ряда на основе исходного, применив функцию detrend\n\n&gt;&gt; ts2 = detrend(ts1,'constant');\n&gt;&gt; ts3 = detrend(ts1,'linear');\n\n\n\n\n",
      "url": "/pages/matlab/timeseries/"
    },{
      
      "title": "Хронологические таблицы",
      
      "content": "Объект типа timetable предназначен для хранения представления и обработки табличных данных, предполагая, что каждая строка таблицы связана с меткой времени. Тип timetable объединяет функционал типов timeseries и table.\n\nСоздание timetable\n\n&gt;&gt; date_array = datetime(2020,4,1:2:6)';\n&gt;&gt; timetable(date_array, [1;2;3], [5;6;7], [8;9;10])\n\nans =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5        8 \n    03-Apr-2020     2       6        9 \n    05-Apr-2020     3       7       10 \n\n\nИспользуя свойство VariableNames можно задать имена столбцов таблицы\n\n&gt;&gt; T1.Properties.VariableNames = {'C1', 'C2', 'C3'};\n&gt;&gt; T1\n\nT1 =\n  3×3 timetable\n    date_array     C1    C2    C3\n    ___________    __    __    __\n    01-Apr-2020    1     5      8\n    02-Apr-2020    2     6      9\n    03-Apr-2020    3     7     10\n\n\nСвойство Variables позволяет получить матрицу данных таблицы. Для созданной выше таблицы T1 это будет\n\n&gt;&gt; T1.Variables\n\nans =\n     1     5     8\n     2     6     9\n     3     7    10\n\n\nОбъект timetable может содержать столбцы любого типа\n\n&gt;&gt; T2 = timetable(date_array, [1;2;3], [5;6;7], {'A';'B';'C'})\n\nT2 =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5      'A' \n    03-Apr-2020     2       6      'B' \n    05-Apr-2020     3       7      'C' \n\n\nИзвлечение данных при помощи свойства Variables из такой таблицы приведёт к ошибке\n\n...\nUnable to concatenate the table variables 'Var1' and 'Var3', because their types are double and cell.\n\n\nОбъект timetable можно создать на основе объекта table\n\n&gt;&gt; SBER_table = readtable('SBRCY.csv');\n&gt;&gt; table2timetable(SBER_table);\n\n\nВ таблице должен быть хотя бы один столбец, имеющий тип DateTime. Первый столбец в таблице, который имеет тип DateTime, используется для меток времени\n\nt0 = table((1:5)',(10:10:50)',(hours(0):hours(1):hours(4))')\nt1 = table2timetable(t0)\n\n\nФункции timetable\n\nretime\n\nФункция retime используется для пересчета значений timetable в новой шкале времени.\n\nНапример, рассмотрим таблицу, содержащую 3 строки, соответствующие трём датам: 1, 3 и 5 апреля 2020 года:\n\n&gt;&gt; date_array = datetime(2020,4,1:2:6)';\n&gt;&gt; T1 = timetable(date_array, [1;2;3], [5;6;7], [10;15;8])\n\nT1 =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5       10 \n    03-Apr-2020     2       6       15 \n    05-Apr-2020     3       7        8 \n\n\nНа основе этой таблицы создадим таблицу TR с шагом по времени 1 день. Для этого можно вторым аргументом явно указать в функции retime новый массив дат\n\n&gt;&gt; TR = retime(T1,datetime(2020,4,1:1:6)')\n\nTR =\n  6×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020      1       5      10 \n    02-Apr-2020    NaN     NaN     NaN \n    03-Apr-2020      2       6      15 \n    04-Apr-2020    NaN     NaN     NaN \n    05-Apr-2020      3       7       8 \n    06-Apr-2020    NaN     NaN     NaN \n\n\nКак видно, для новых значений времени, которых не было в исходной таблице, данных не появилось. Чтобы новая таблица содержала значения в столбцах для новых дат, необходимо третим аргументом указать тип интерполяции, например, линейная (‘linear’), сплайн (‘spline’), следующее значение (‘next’):\n\n&gt;&gt; T2 = retime(T1,datetime(2020,4,1:1:6)','linear')\n\nT2 =\n  6×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020      1       5       10\n    02-Apr-2020    1.5     5.5     12.5\n    03-Apr-2020      2       6       15\n    04-Apr-2020    2.5     6.5     11.5\n    05-Apr-2020      3       7        8\n    06-Apr-2020    3.5     7.5      4.5\n\n\nЕсли новый массив времени содержит меньшее количество точек, то вместо интерполяции используются агрегатные функции (среднее, минимум, максимум).\n\nx = linspace(0,5,50);\nVAR1 = 2*x + sin(x);\nVAR2 = cos(x);\n\nT1 = timetable(seconds(x)',VAR1',VAR2');\n\nplot(T1.Time,T1.Var1,'-', T1.Time,T1.Var2, '--');\n\nhold on;\n\nx2 = linspace(0,5,10);\nT2 = retime(T1,seconds(x2)','nearest');\nplot(T2.Time,T2.Var1,'o', T2.Time,T2.Var2, '^');\n\nhold off;\n\nlegend('Var1','Var2','retime Var1','retime Var2');\n\n\n\n",
      "url": "/pages/matlab/timetable/"
    },{
      
      "title": "TLE",
      
      "content": "\n  Написать модуль, содержащий функции, которые в заданном текстовом файле (текстовом блоке) выявляют двухстрочные элементы орбиты и возвращает в виде списка строк результаты анализа (расшифровку) двухстрочных элементов, найденных в файле. Тектовый файл может содержать произвольный текст с включенными в него двухстрочными элементами орбиты.\n  Написать программу, которая демонстрирует использование разработанного модуля.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/tle/"
    },{
      
      "title": "Город",
      
      "content": "Источник\n\nНеобходимо написать программу - помощник архитектора в рисовании очертания города. Город задается расположением зданий. Город рассматривается как двумерный и все здания в нем - прямоугольники, имеющие одинаковое основание (город построен на равнине). Здания задаются тройкой чисел\n\n(L[i],H[i],R[i])\n\nгде L[i]~ и R[i] есть координаты левой и правой стен здания i, а H[i] - высота этого здания. На рисунке здания описываются тройками\n\n(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29),(24,4,28)\n\n\n\n\nКонтур, показанный на втором рисунке, задается последовательностью\n\n(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)\n\n\n\n\n\n  Ввод представляет собой последовательность троек, задающих дома.\n  Все координаты есть целые числа, меньшие 10000.\n  Во входном файле минимум одно и максимум 50 зданий.\n  Каждая тройка, обозначающая здание находится в отдельной строке во входном файле.\n  Все целые числа в тройке разделены одним или несколькими пробелами.\n  Тройки отсортированы по L[i], т.е. по левой х-координате здания, таким образом, здание с самой маленькой левой х-координатой является первым во входном файле.\n  Вывод будет состоять из вектора, описывающего очертание, как показано в примере выше.\n  В векторе очертания\n\n\n(v[1],v[2],v[3], ... , v[n-2],v[n-1],v[n]),\n\n\nv[i], когда i-четное число, означает горизонтальную линию (высоту). Когда i-нечетное, v[i]-означает вертикальную линию (х-координату). Последний элемент в векторе линии контура будет 0.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/town/"
    },{
      
      "title": "Команды среды разработки Турбо Паскаль",
      
      "content": "\n  \n    \n      Сочетание клавиш\n      Действие\n    \n  \n  \n    \n      F10\n      вход в меню\n    \n    \n      Ctrl+F9\n      запуск программы\n    \n    \n      Alt+F5\n      просмотр пользовательского экрана\n    \n    \n      F2\n      сохранение программы\n    \n    \n      F3\n      открытие сохраненной программы\n    \n    \n      Alt+F3\n      закрытие активного окна\n    \n    \n      Alt+X\n      выход из Турбо Паскаль\n    \n    \n      F1\n      контекстная помощь\n    \n    \n      Ctrl+F1\n      справка об операторе, на котором установлен курсор\n    \n    \n      Alt+Backspace\n      отмена последнего изменения\n    \n    \n      Ctrl+Y\n      удаление строки\n    \n    \n      Shift+стрелки\n      выделение блока текста\n    \n    \n      Ctrl+Insert\n      копирование выделенного блока в буфер\n    \n    \n      Shift+Insert\n      вставка из буфера\n    \n  \n\n\n",
      "url": "/pages/informatics/tp_cheat_sheet/"
    },{
      
      "title": "Пересечение треугольников",
      
      "content": "В тектовом файле заданы координаты верщин \\(n\\) треугольников:\n\nx11 y11 x12 y12 x13 y13\nx21 y21 x22 y22 x23 y23\nx31 y31 x32 y32 x33 y33\n...\nxn1 yn1 xn2 yn2 xn3 yn3\n\n\nОпределить точки пересечения сторон треугольников и сохранить координаты этих точек в текстовый файл, в котором указаны номера, пересекающихся треугольников и координаты точек пересечения:\n\n1-2 x1 y1\n2-3 x2 y2\n...\nn-k xm ym\n\n\nПрограмма должна показать на экране треугольники, точки пересечния и их координаты.\n\nРезультат работы программы выводится на экран и сохраняется в файл формата png.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/triangles/"
    },{
      
      "title": "Двухимпульсный перелет",
      
      "content": "Задана начальная масса \\(m_0\\) космического аппарата, находящегося на круговой орбите высотой \\(h_0\\). Задана высота конечной орбиты \\(h_k\\) и эффективность двигателя – удельный импульс 1500…3500 м/с. Указанные исходные данные загружаются из текстового файла\n\nm0\nh0\nIs\n\n\n\n  Определить затраты топлива, необходимые для двухимпульного перехода с одной орбиты на другую.\n  Определить продолжительность перелёта.\n  Определить приращение скорости и затраты топлива на первый и второй импульс.\n  Вывести на экран исходные данные и результаты расчёта. Сохранить результаты в тектовый файл\n\n\nНачальная масса КА          : m0 кг\nУдельный импульс            : Is м/c\nНачальная орбита (круговая) : h0 x h0 км\nКонечная  орбита (круговая) : hk x hk км\n\nСуммарные затраты топлива   : ms кг\nПродолжительность перелёта  : ts с\n...\n...\n\n\n\n  Построить график зависимостей затрат топлива в зависимости от высоты конечной орбиты при \\(h_0\\) = 200 км для нескольких значений удельных импульсов (1500, 2000, 2500, 3000 и 3500 м/с).\n\n\nСтр. 48 http://www.iki.rssi.ru/books/2010sukhanov.pdf\n\nСписок заданий\n",
      "url": "/pages/python/course_works/two_impulse_transfer/"
    },{
      "image": {"path":"/assets/img/mbs/Orbital_stage.png"},
      "title": "Задание 5.",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел. Задание №5. Движение твердого тела под действием следящей силы.\n",
      "content": "Построить модель движения орбитальной ступени ракеты-носителя после отделения космического аппарата под действием силы тяги сопла торможения.\n\nВ начальный момент времени ступень находится в покое по отношению к орбитальной подвижной системе координат, которая считается инерциальной.\n\nОписание механической системы\n\n\n  Схема орбитальной ступени показана на рисунке 1.\n\n\n\nРисунок 1 – Схема ступени (все линейные размеры в миллиметрах)\n\n\n  Инерционно-массовые характеристики ступени\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса ступени\n      5000 кг\n    \n    \n      Положение центра масс, \\(x_c\\)\n      3 м\n    \n    \n      Момент инерции относительно продольной оси\n      5000 кг\\(\\cdot\\)м \\(^2\\)\n    \n    \n      Момент инерции относительно любой поперечной оси\n      20000 кг\\(\\cdot\\)м \\(^2\\)\n    \n  \n\n\n\n  Тяга реактивного сопла увода\n\n\n\nРисунок 2 – Закон изменения тяги реактивного сопла\n\nЗадание\n\nЗаписать уравнения движения и разработать программу моделирования движения орбитальной ступени относительно орбитальной системы координат \\(O x_0 y_0 z_0\\), которую считать инерциальной.\n\nВ качестве параметров, определяющих угловое положение ступени, использовать\n\n  кватернионные параметры;\n  направляющие косинусы;\n  углы Эйлера (пассивная точка зрения).\n\n\nПоследовательность поворотов углов Эйлера выбирается из следующей таблицы по номеру в ведомости:\n\n\n  \n    \n      Вариант\n      Последовательность\n      Вариант\n      Последовательность\n    \n  \n  \n    \n      1\n      123\n      7\n      321\n    \n    \n      2\n      321\n      8\n      313\n    \n    \n      3\n      231\n      9\n      212\n    \n    \n      4\n      231\n      10\n      323\n    \n    \n      5\n      132\n      11\n      121\n    \n    \n      6\n      213\n      12\n      131\n    \n  \n\n\nПостроить графики изменения проекций угловой скорости ступени на связанные оси: \\(\\omega_x, \\omega_y, \\omega_z\\).\n\nПостроить графики изменения координат и проекций скорости центра масс ступени на оси орбитальной подвижной системы координат: \\(x,y,z\\), \\(V_x, V_y, V_z\\).\n\nОпределить направление вектора кинетического момента ступени после окончания работы реактивного сопла (через 30 секунд после начала движения) в системе координат \\(O x_0 y_0 z_0\\).\n\nОпределить угол нутации и угловую скорость прецессии орбитальной ступени после окончания работы реактивного сопла (через 30 секунд после начала движения).\n\nПример MATLAB-кода для углов Брайнта\n\nГлавный файл-скрипт для запуска процесса интегрирования\n\n% Масса\nparams.m = 5000.0;\n% Матрица тензора инерции\nparams.J = [5000.0,     0,     0;\n            0     , 20000,     0;\n            0     , 0    , 20000];\n% Матрциа обратная матрице тензора инерции\nparams.invJ = inv(params.J);\n\n% Функция силы от времени\n% Текущее значение силы интерполируется по таблице значений\nparams.sopForceTable = @(t) interp1([0 5 10 15 30 50],[1000 380 150 50 0 0],t);\n\n% Точка приложения силы в ССК                     \nparams.pFsop = [1.5; \n                1.5*sin(45*pi/180.0); \n                1.5*cos(45*pi/180.0)];  \n            \n% Единичный вектор направления силы в ССК\nparams.nFsop = [-cos(20*pi/180.0); \n                +sin(20*pi/180.0)*cos(55*pi/180.0);\n                -sin(20*pi/180.0)*cos(35*pi/180.0)];                    \n% Начальные условия\n% Положение центра масс\nr0 = [0;0;0];\n% Скорость центра масс\nv0 = [0;0;0];\n% Начальная ориентация (углы Брайнта 1-2-3)\na0 = [0;0;0];\n% Начальная угловая скорость\nw0 = [0;0;0];\n\n% Начальный вектор состояния\nq0 = [r0;a0;v0;w0];\n% Интервал интегрирования\ntspan = 0:0.2:30;\n% Относительная погрешность\noption = odeset('RelTol',1e-8);\n\n% Запуск процесса интегрирования дифференциальных уравнений\n[t, q] = ode45(@(t,q) dqdt_orbital_stage(t,q,params), tspan, q0, option);\n\n\nФайл-функция правых частей\n\nfunction dq = dqdt_orbital_stage(t,q,params)\n%dqdt_orbital_stage.m Файл-функция правых частей дифференциальных уравнений \n% движения орбитальной ступени\n\n  r = q(1:3);   % Положение центра масс\n  a = q(4:6);   % Углы Брайнта\n  v = q(7:9);   % Скорость центра масс\n  w = q(10:12); % Угловая скорость\n\n% Матрица преобразования координат из \n% связанной системы координат (ССК) \n% в орбитальную (ОСК)\nA = Axyz(a(1),a(2),a(3));\n\n% Модуль силы\nF = params.sopForceTable(t);\n\n% Вектор силы в ССК\n% Значение * единичный вектор направления\nFsop_b = F*params.nFsop;\n\n% Вектор момента этой силы относительно ССК\nMsop_b = cross(params.pFsop, Fsop_b);\n\n% Вектор силы в ИСК\nFsop_0 = A*Fsop_b;\n\n% Ускорение центра масс\ndv = Fsop_0/params.m;\n\n% Угловое ускорение \ndw = params.invJ*(Msop_b - cross(w,params.J*w));\n\n% Кинематические уравнения для углов Брайнта\n% (производные углов)\nda = kinematicEq123(a, w);\n\n% Собираем ответ \n% Значение правой части системы ДУ\ndq = [v; da; dv; dw];\n\nend\n\n\nФункция вычисления производных углов Брайнта (функция кинематических уравнений)\n\nfunction da = kinematicEq123(a, w)\n%kinematicEq123.m Кинематические уравнения для углов Брайнта\n% Последовательность XY'Z'' (пассивная точка зрения)\n% \n% Аргументы:\n%   a - строка или столбец углов Брайнта в радианах  \n%   w - строка или столбец угловых скоростей радиан/с\n% Результат:\n%   res - столбец производных углов Брайнта\n% \n     c3 = cos(a(3));\n     s3 = sin(a(3));\n     c2 = cos(a(2));\n     s2 = sin(a(2));\n     \n     da = [ w(1)*c3/c2 - w(2)*s3/c2;\n            w(1)*s3 + w(2)*c3;\n           -w(1)*c3*s2/c2 + w(2)*s3*s2/c2 + w(3)];\nend\n\n\nФайл-функция Axyz.m\n\nfunction A = Axyz(a1, a2, a3)\n  A = Ax(a1)*Ay(a2)*Az(a3);\nend\n\n\nfunction A = Ax(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [1,  0,  0;\n       0,  c, -s;\n       0,  s,  c];\nend\n\n\nfunction A = Ay(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c,  0,  s;\n       0,  1,  0;\n      -s,  0,  c];\nend\n\n\nfunction A = Az(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c, -s,  0;\n       s,  c,  0;\n       0,  0,  1];\nend\n\n",
      "url": "/pages/mbs/upperstage/"
    },{
      
      "title": "Видео",
      
      "content": "Канал youtube\n",
      "url": "/pages/videos/"
    }
  ], 
  "documents": [
    {
      
      "title": "Electrostatic Space Tug",
      "date": "2018-04-02 00:00:00 +0400",
      
      "content": "Вышла новая статья про уборку космического мусора в Journal of Guidance, Control, and Dynamics. В этот раз не про трос, а про “тяговый луч”.\n\nНа высоких орбитах, в частности на геостационарной орбите можно для буксировки пассивных объектов использовать электростатическое поле, зарядив сам буксир и буксируемый объект разными или одинаковыми по знаку зарядами. В зависимости от этого будет схема «тяни» или «толкай».\n\nВ первом случае, буксир создает силу тяги, направленную в сторону мусора, толкая его перед собой: медленно, но верно переводя на орбиту захоронения. Для геостационарной орбиты это орбиты, находящиеся на 200 км выше (спуск мусора к Земле получается слишком дорогим).\n\n\n\nЕсли электрические заряды буксира и мусора разные по знаку, то буксир будет притягивать мусор, поэтому сила тяги буксира должна быть направлена от космического мусора.\n\n\n\nИдея использование электростатического поля для буксировки мусора запатентована (https://patents.justia.com/patent/8210480), правда в патенте речь идет о противоположных зарядах.\n\nДля создания необходимого заряда космического мусора и самого буксира можно использовать электронные или ионные пушки, например электрореактивные двигатели — тяга в электрореактивных (ионных) двигателях как раз создается за счёт ионизированного газа, разгоняемого магнитным полем. Этот поток заряженных частиц можно исползовать для передачи заряда.\n\n«Тяга», создаваемая электрическим полем невелика (десятки миллиньютонов), но достаточна для изменения орбиты космического мусора на высоких орбитах.\n\nСтатья посвящена вопросу устойчивого управления буксиром в процессе орбитальной транспортировки.\n\nV. S. Aslanov, V. V. Yudintsev Motion Control of Space Tug During Debris Removal by a Coulomb Force. Journal of Guidance, Control, and Dynamics, 2018, March 22, 2018. doi:10.2514/1.G003251 \n",
      "categories": [],
      "tags": ["космонавтика","space debris","космический мусор"],
      
      "collection": "posts",
      "url": "/blog/2018-04-02-electrostatic-space-tug/"
    },{
      
      "title": "Net",
      "date": "2018-04-14 00:00:00 +0400",
      
      "content": "Экспериментирую с MATLAB-моделью сети (для захвата сетью космического мусора). В этой модели 257 тел. Сеть представлена 256 материальными точками-узлами, соединенными односторонними упругими связями. С объектом (шаром) взаимодействуют только узлы сети.\n\nНесмотря на все упрощения MATLAB-кода скорость интегрирования пока очень низкая: расчёт 5 секунд времени модели требует около 6,5 минут машинного времени (i5-2500 3.3Ghz x 4 / Linux). Что же будет при захвате более сложных вращающихся объектов?\n\n\n",
      "categories": ["mechancis"],
      "tags": ["debris"],
      
      "collection": "posts",
      "url": "/blog/mechancis/2018-04-14-net/"
    },{
      
      "title": "Использование утилиты ffmpeg",
      "date": "2018-05-13 00:00:00 +0400",
      
      "content": "Памятка по основным командам утилиты ffmpeg для преобразования видеофайлов.\n\nИзменение размера изображения\n\nffmpeg −i input.avi −s 320x240 result.mp4\n\n\nИзвлечение фрагмента\n\nСохранить в файл result.wmv фрагмент видео из файла input.wmv начиная с 30 секунды (-ss) продолжительностью 10 секунд (-t).\n\nffmpeg −ss 00:00:30.0 −i input.wmv −c copy −t 00:00:10.0 result.wmv\n\n\nИзвлечение одного кадра\n\nСохранить один кадр на первой секунде и сохранить его в файл video_frame.png\n\nffmpeg -ss 00:00:01 -i video.avi -vframes 1 video_frame.png\n\n\nИзвлечение нескольких кадров\n\nИзвлечение кадра каждую секунду:\n\nffmpeg -i net_case_1.avi -vf fps=1 case_1_%3d.png\n\n\nВидеопрезентация из серии изображений\n\nСоздаётся видеофайл из изображений p01.png, p02.png, p03.png, …, которые сменяют друг-друга каждые 5 секунд (1/5). Частота кадров видеофайла 30 кадров/с.\nffmpeg -r 1/5 -i p%2d.png -c:v libx264 -r 30 -y -pix_fmt yuv420p slide_show.mp4\n\n\nДобавление аннотации\n\nffmpeg -i net.avi -vf \"drawtext=text='Net capture':fontcolor=black@0.6:fontsize=18:box=1:boxcolor=black@0.0:x=5:y=5\" -b:v 4M -y net_annotated.avi\n\n\nСоздание анимированного gif\n\nffmpeg −i video.avi video.gif\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-05-13-ffmpeg/"
    },{
      
      "title": "Истечение газа из ёмкости постоянного объёма",
      "date": "2019-01-02 00:00:00 +0400",
      
      "content": "Пример кода на языке Python (в Google Colab) решения задачи истечения газа через отверстие из ёмкости постоянного объёма.\n\nПо книге Е. В. Герц, Г. В. Крейнин Расчёт пневмоприводов Справочное пособие М.: Машиностроение, 1975.\n\nДана ёмкость с постоянным объемом \\(V_1\\) и начальным давлением \\(p_1\\), соединенная со средой с давлением \\(p_a\\). Из ёмкости через отверстие с эффективной площадью \\(f\\) начинает истекать газ. Процесс происходит без теплообмена с окружающей средой. Необходимо найти закон изменения давления в ёмкости.\n\nПодключение необходимых библиотек\n\nimport math\nimport scipy\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\n\n# Настройка свойств графиков \"по умолчанию\"\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\nКонстанты и начальные условия\n\n# Ускорение свободного падения\ng = 9.807\n# Газовая постоянная, \nR = 29.27\n# Температура, К\nT = 280.0\n# Показатель адиабаты\nk  = 1.4\n# Критическое соотношение давлений\nsk = (2/(k+1))**(k/(k-1))\n\n# Объём ёмкости м3\nV1 = 0.018\n# Начальное давление в ёмкости, кгс/м2\np1 = 5.0e4\n# Эффективная площадь отверстия м2\nf  = 0.7*1.76e-4\n# Давление среды, кгс/м2\npa = 1.0e4\n\n\nВесовой расход газа\n\nВесовой расход газа \\(G_m\\) зависит от режима истечения газа, определяемого соотношением давлений \\(\\sigma\\).\n\n[\\sigma = \\frac{p_2}{p_1}]\n\nПри \\(\\sigma &lt; \\sigma^*\\) (надкритический расход)\n\n[G_m = \\sqrt{\\frac{2 k g}{k-1}} \\frac{fp_1 \\varphi(\\sigma^*)}{\\sqrt{RT}}]\n\nДля \\(\\sigma &gt; \\sigma^*\\) (подкритический расход)\n\n[G_m = \\sqrt{\\frac{2 k g}{k-1}} \\frac{fp_1 \\varphi(\\sigma)}{\\sqrt{RT}}]\n\nгде\n\n[\\sigma = \\frac{p_2}{p_1}, \\quad \\sigma^* = \\left(\\frac{2}{k+1}\\right)^{k/(k-1)},\\quad \\varphi(\\sigma) = \\sqrt{\\sigma^{2/k}-\\sigma^{(k+1)/k}}]\n\n\ndef Gm(p1, p2, f):\n  '''\n  Функция вычисляет весовой расход газа (кгс/с)\n  при истечении из емкости с давлением p1 (кгс/м2)\n  в ёмкость c давлением p2 (кгс/м2) (p2 &lt; p1) \n  через отверстие с эффективной площадью f (м2)  \n  '''  \n  # Соотношение давлений (куда/откуда)\n  s   = p2/p1\n  phi = lambda x: math.sqrt(x**(2.0/k)-x**((k+1.0)/k)) \n  \n  if s &lt; sk:\n    # Надкритический расход (истечение со скоростью звука)\n    # Вместе с вычисленным расходом возвращаем признак 1 \n    res = [1, math.sqrt(2*k*g/(k-1))*f*p1*phi(sk)/math.sqrt(R*T)]\n  else:\n    # Подкритический расход\n    # Вместе с вычисленным расходом возвращаем признак 0\n    res = [0, math.sqrt(2*k*g/(k-1))*f*p1*phi(s)/math.sqrt(R*T) ]\n    \n  return res \n\n\nДифференциальное уравнение изменения давления в ёмкости\n\n[\\frac{dp_1}{dt} = - \\frac{G_m k R T}{V_1}]\n\ndef dp1dt(t, q):  \n  '''\n  Функция правой части дифференциального уравнения dp1/dt = ...\n  '''\n  p1 = q[0]  \n  gm = -Gm(p1, pa, f)[1]  \n  return gm*k*R*T/V1\n\n\nИнтегрирование\n\nsol = scipy.integrate.solve_ivp(dp1dt, [0, 1], [p1], method='LSODA', rtol = 1e-10)\n# Извлекаем давление из результатов интегрирования\npt  = sol.y.flatten()\n# Вычисляем расход по полученным результатам интегрирования\nGt  = np.array([ Gm(x, pa, f) for x in pt ])\n\n\nРезультаты\n\nГрафик изменения давления в ёмкости\n\nplt.plot(sol.t[Gt[:,0]&gt;0],pt[Gt[:,0]&gt;0]/1e4,'r',sol.t[Gt[:,0]&lt;1],pt[Gt[:,0]&lt;1]/1e4,'g');\nplt.legend(['Надкритический режим','Подкритический режим'])\nplt.xlim([0,1]);plt.xlabel('t, c');plt.ylabel('p, кгс/см$^2$');\n\n\nГрафик весового расхода газа\n\nplt.plot(sol.t[Gt[:,0]&gt;0],Gt[Gt[:,0]&gt;0,1],'r',sol.t[Gt[:,0]&lt;1],Gt[Gt[:,0]&lt;1,1],'g');\nplt.legend(['Надкритический режим','Подкритический режим'])\nplt.xlim([0,0.9]);plt.xlabel('t, c');plt.ylabel('Весовой расход, кгс/c');\n\n\nКод в Google CoLab.\n",
      "categories": ["mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-01-02-discharge-constant-volume-python/"
    },{
      
      "title": "Движение спускаемого аппарата в атмосфере",
      "date": "2019-01-05 00:00:00 +0400",
      
      "content": "Пример кода на языке Python (в Google Colab) для моделирования движения спускаемого аппарата (СА) в атмосфере Земли. Рассматривается простейшая плоская модель движения СА, как материальной точки с постоянными коэффициентами лобового сопротивления и подъёмной силы. Показано использование параметра events интегратора для остановки процесса интегрирования при достижении СА поверхности Земли.\n\nПодключаем необходимые библиотеки\n\n\nfrom collections import namedtuple\nimport scipy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\n\nОбъявляем функцию, для вычисления плотности воздуха и ускорения свободного падения на заданной высоте.\n\n# Модель атмосферы в диапазоне от 0 до 100 км с погрешностью 1,5%\n# В. А. ЯРОШЕВСКИЙ \"АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ\"\n# Ученые записки ЦАГИ, т. XL, №3, 2009.\na  = np.array([-6.3759,-7.3012,-1.1817])\nb  = np.array([-0.4754,-0.0096,-0.0068,-0.0120,0.0042]);\nc  = np.array([ 0.1803, 0.0872,-0.0153, 0.0145,0     ]);\n\ndef rho(h):\n  # Функция вычисления плотности воздуха\n  # высота h задаётся в километрах\n  # результат -- плотность кг/м3\n  x = h/50.0-1\n  sa = a[0] + a[1]*x + a[2]*x*x\n  sbc= np.sum( (b[i]*np.cos((i+1)*np.pi*x) + c[i]*np.sin((i+1)*np.pi*x) for i in range(5)) )\n  return np.exp(sa + sbc)\n\n# Гравитационный параметр Земли\nmu = 398600.4415e9\n# Радиус Земли\nRe = 6371000.0\n\ndef g_acc(h):\n  # Вычисление ускорения свободного падения м/с^2 на высоте h (в метрах)\n  return mu/(Re+h)**2\n\n\nУравнения движения имеют следующий вид:\n\n[\\frac{dV}{dt} = - \\frac{C_d S_m q}{m} - g \\sin \\theta,\\quad V \\frac{d \\theta}{dt} = \\frac{C_l S_m q}{m} - \\left(g-\\frac{V^2}{r}\\right) \\cos \\theta, \\quad \\frac{dr}{dt} = V \\sin \\theta]\n\nгде \\(V\\) - скорость СА; \\(\\vartheta\\) – угол наклона траектории (угол между вектором скорости и линией местного горизонта); \\(r\\) – расстояние от центра Земли до центра масс СА; \\(g\\) – ускорение свободного падения на высоте \\(h\\); \\(m\\) – масса СА; \\(S_m\\) – характерная площадь (площадь Миделя); \\(C_d\\) – аэродинамический коэффициент лобового сопротивления; \\(C_l\\) – аэродинамический коэффициент подъёмной силы; \\(q\\) – Скоростной напор:\n\n[q = \\frac{\\rho V^2}{2}]\n\nФункция правых частей дифференциальных уравнений:\n\ndef dydt(t, y, p):  \n  # Функция правых частей дифференциальных уравнений\n  # вычисление правых частей дифференциальных уравнений для\n  # момента времени t и вектора состояния y = [r(t), v(t), theta(t)]\n\n  # Радиус-вектор точки в момент времени t\n  r     = y[0]\n  # Скорость  в момент времени t\n  v     = y[1]\n  # Угол наклона траекториии  в момент времени t  \n  theta = y[2]\n\n  # Высота (км)\n  h     = (r - Re)*0.001\n  # Скоростной напор Н/м^2\n  q     = rho(h)*v*v/2  \n  # Ускорение свободного падения\n  g     = g_acc(r - Re)\n\n  # dv/dt =   \n  dv    = - q*p.CD*p.Sm/p.mass - g*np.sin(theta)\n  # dtheta/dt =   \n  dtheta= (q*p.CL*p.Sm/p.mass - (g - v*v/r)*np.cos(theta))/v\n  # dr/dt =    \n  dr    = v*np.sin(theta)\n\n  return (dr,dv,dtheta)\n\n\nСледующая функция используется для останова процесса интегрирования при достижении спускаемым аппаратом нулевой высоты. Функция возвращает высоту полета и устанавливает два атрибута, один из которых указывает на направление изменения контролируемой функции (высоты) при пересечении нулевого значения. В рассматриваемом случае атрибут direction равен минус 1, т.е. процесс интегрирования остановится только если высота пересечет ноль уменьшаясь. Второй атрибут – terminal предписывает остановить процесс интегрирования.\n\ndef event_h_eq_0(t, y):\n  # Функция-\"детектор\", передаваемая в интегратор (параметр events),\n  # для определения времени достижения нулевой высоты и\n  # остановки процесса интегрирования  \n  # функция возвращает высоту  \n  return y[0]-Re  \n\n# функция определяется условие h = 0 при движении \"вниз\"\nevent_h_eq_0.direction = -1\n# функция-детектор активна\nevent_h_eq_0.terminal  = True  \n\n\nПараметры спускаемого аппарата (масса, аэродинамические коэффициенты, площадь миделя) будут храниться в структуре params.\n\nparams = namedtuple(\"params\", \"CD CL mass\")\n# Масса тела\nparams.mass = 4000.0\n# Аэродинамические коэфиициенты,\n# которые в общем случае зависят от числа Маха,\n# угла атаки\nparams.CD   = 1.5    # Коэффицент лобового сопротивления\nparams.CL   = 0      # Коэффицент подъёмной силы\n# Площадь миделя\nparams.Sm   = 3      \n\n\nНачальные условия движения:\n\n# Начальные условия\nh0     = 100e3 # Начальная высота [м]\nv0     = 7800. # Начальная скорость [м/c]\ntheta0 = -0.1  # начальный угол наклона траектории [радиан]\n\n\nЗапускаем процесс интегрирования, передавая функции solve_ivp ссылку на функцию правых частей, интервал интегрирования, список начальных условий, используемый численный метод и ссылку на функцию для останова интегрирования. Функция правых частей должна иметь два аргумента: время и вектор состояния. Объявленная ранее функция dydt имеет три аргумента, включая ссылку на структуру с параметрами спускаемого аппарата, поэтому эту функция адаптируется к требованиям solve_ivp при помощи лямбда-функции.\n\nsol = scipy.integrate.solve_ivp(lambda t,y: dydt(t,y,params), [0, 1000], [Re+h0, v0, theta0], method='LSODA', events = event_h_eq_0, rtol = 1e-8)\n\n\nПостроение графиков\n\n# Зависимость высоты от времени\nplt.plot(sol.t,(sol.y[0]-Re)*0.001);\nplt.xlabel('t, c');plt.ylabel('h, км');\n\n",
      "categories": ["mechanics"],
      "tags": ["python","space"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-01-05-reentry-1/"
    },{
      
      "title": "Способ очистки орбит от объектов космического мусора",
      "date": "2019-02-22 00:00:00 +0400",
      
      "content": "Изобретение относится к методам и средствам очистки орбит от космического мусора, главным образом отработанных ступеней ракет-носителей. Способ включает выведение в область очистки космического аппарата-буксира и автономного стыковочного модуля на тросе. Автономный модуль стыкуется с орбитальной ступенью и гасит кинетический момент ступени своими управляющими двигателями. Кинетический момент связки гасится двигателями буксира и двигателями автономного модуля.\n\nОткрыть документ\n",
      "categories": ["mechanics"],
      "tags": ["space"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-02-22-patent/"
    },{
      
      "title": "Пример использования библиотеки sympy для поиска экстремума функции",
      "date": "2019-06-09 00:00:00 +0400",
      
      "content": "Рассмотрим алгоритм поиска экстремума функции одной переменной при помощи библиотеки sympy. Дана следующая функция от \\(x\\):\n\n[f(x)  = \\frac{\\sqrt{x^2+a^2} + k \\sqrt{b^2+(h-x)^2}}{v_1}]\n\nДля нахождения экстремума функции найдем ее производную по \\(x\\), используя библиотеку sympy, и решив уравнение\n\n[\\frac{df(x)}{dx} = 0,]\n\nнайдем значение x, которому соответсвует минимум или максимум функции.\n\nПоключаем библиотеки\n\n\n# numpy всегда пригодится\nimport numpy as np\n# Для построения графиков\nimport matplotlib.pyplot as plt\n# Научный питон  \nfrom scipy import optimize\n# Символьный питон\nfrom sympy import *\n\n\n\nОбъявляем используемые в функции символьные параметры\n\na, b, h, k, x, v1 = symbols('a, b, h, k, x, v1')\n\n\nОбъявляем функцию\n\nf  = (sqrt(x**2+a**2) + k*sqrt(b**2+(h-x)**2))/v1\n\n\nНайдем её производную при помощи функции библиотеки sympy diff. Первый аргумент функции diff – дифференцируемое выражение, второй – переменная, по которой необходимо найти производную:\n\ndf = diff(f, x)\n\n\nВ результате переменная df будет содержать следующее выражение\n\n&gt;&gt; df\n\n(k*(-h + x)/sqrt(b**2 + (h - x)**2) + x/sqrt(a**2 + x**2))/v1\n\n\nВ полученном выражении для производной заменим символы (параметры) a, b, h, k, v1 их значениями (a=10, b=10, h=10, k=5, v1=5). Для этого создаем словарь\n\nparams = {a:10, b:10, h:10.0, k:5, v1: 5}\n\n\nкоторый подставим в найденную производную, используюя метод subs\n\ndf_par = df.subs(params)\n\n\nРезультатом будет выражение, которое зависит только от x:\n\n&gt;&gt; df_par\n\nx/(5*sqrt(x**2 + 100)) + (x - 10.0)/sqrt((-x + 10.0)**2 + 100)\n\n\nСоздадим на основе символьного выращения f_par лямбда-функцию от x\n\ndf_num = lambda xnum: df_par.subs( {x: xnum} ) \n\n\nЧисленным методом найдем значение x, при котором производная обращается в 0. Для этого используем функцию root модуля scipy.optimize, передав этой функции имя лямбда-функции и начальное приближение \\(x_0 = 5\\):\n\nsol = optimize.root(df_num, 5.0)\n\n\nРезультатом будет следующее значение \\(x\\):\n\n&gt;&gt; sol.x\n\narray([8.6777724])\n\n\n",
      "categories": ["programming"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/programming/2019-06-09-sympy/"
    },{
      
      "title": "Плоская модель сети",
      "date": "2019-06-30 00:00:00 +0400",
      
      "content": "Код простейшей модели взаимодействия сети с твердым телом, например, при улавливании створки головного обтекателя сетью, как это пытается делать компания SpaceX.\n\nМодель плоская. Cтворка описывается выпуклым многоугольником, а сеть представлена системой материальных точек, соединённых невесомыми пружинками с заданными коэффициентами жёсткости и демпфирования.\n\nИз выпускной квалификационной работы Савичевой А. С.\n\n\n",
      "categories": ["mechanics","programming"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/mechanics/programming/2019-06-30-net2D/"
    },{
      
      "title": "Модель движения наноспутника",
      "date": "2019-07-03 00:00:00 +0400",
      
      "content": "Пример использование языка программирования Python с библиотеками numpy, scipy, sympy, matplotlib для построения и интегрирования уравнений движения наноспутника формата кубсат внутри транспортно-пускового контейнера.\n\nСсылка на Jupyter-Notebook\n\n\n\n",
      "categories": ["programming","mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/programming/mechanics/2019-07-03-cubesat-python/"
    },{
      
      "title": "Движение механической системы с двумя степенями свободы",
      "date": "2019-07-29 00:00:00 +0400",
      
      "content": "Пример использование языка программирования Python с библиотеками numpy, scipy, sympy, matplotlib для построения и интегрирования уравнений движения механической системы с двумя степенями свободы.\n\nСсылка на Jupyter-Notebook\n\n",
      "categories": ["mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-07-29-mech-python/"
    },{
      
      "title": "Модель физического маятника в Simulink",
      "date": "2019-08-01 00:00:00 +0400",
      
      "content": "Построение модели физического маятника в Simulink. Ссылка на Youtube видео\n\n",
      "categories": ["cae"],
      "tags": ["matlab","simulink"],
      
      "collection": "posts",
      "url": "/blog/cae/2019-08-01-simulink-pendulum/"
    },{
      
      "title": "Решение нестационарной задачи теплопроводности в MATLAB",
      "date": "2019-12-10 00:00:00 +0400",
      "description": "Использование модуля pde-toolbox для решения плоской нестационарной задачи теплопроводности.\n",
      "content": "Рассматривается нестационарная плоская задача теплопроводности. Пластина со сторонами \\(a = 0.4\\) м, \\(b+d=0.051\\) м нагревается в тонком слое толщиной \\(d=1\\) мм (на верхней грани) за счёт внутренних источников тепла. В слое в одну секунду генерируется 8 кДж тепла. Со всех граней пластины излучается тепло рассеивается по закону Стефана-Больцмана. Степень черноты материала пластины - 0.8.\n\n\n\nТемпература точек пластины \\(T(x,y,t)\\) есть функция времени и координат. Эта зависимость определяется дифференциальным уравнением в частных производных:\n\n[\\frac{\\partial T}{\\partial t} = k \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + \\frac{q}{\\rho c_p}]\n\nгде\n\n  \\(k\\) – теплопроводность [Вт/(м\\(\\cdot\\)К)],\n  \\(\\rho\\) – плотность [кг/м\\(^3\\)],\n  \\(c_p\\) – удельная теплоёмкость [Дж/(кг\\(\\cdot\\)K)],\n  \\(q(x,y)\\) – функция внутренних источников тепла [Вт/(м\\(^3\\))].\n\n\nСоздаем модель, указывая тип задачи: нестационарная (transient) задача теплопроводности (thermal)\n\n% Нестационарная модель\nthermalModelT = createpde('thermal','transient');\n\n\n% Размеры пластины\na = 0.4;\nb = 0.05;\n% Толищина \"горячего\" слоя\nd = 0.001;\n\n% Описание геометрии: Прямоугольник\ng = decsg([3 4 -a/2 a/2 a/2 -a/2 0.00 0.00 b b;\n           3 4 -a/2 a/2 a/2 -a/2 b b b+d b+d]');\n\n% Модель\ngeometryFromEdges(thermalModelT,g);\n\n\nСвойства материала пластины\n\nk   = 50;   % теплопроводность\nrho = 7800; % плотность\ncp  = 468;  % удельная теплоёмкость\nthermalProperties(thermalModelT,'ThermalConductivity',k,'MassDensity',rho,'SpecificHeat',cp);\n\n\nГраничные условия\n\nДля корректного определения граничных условий необходимо увидеть геометрию тела с идентификаторами ребер (edges) и областей (faces).\n\npdegplot(thermalModelT,'EdgeLabels','on','SubdomainLabels','on');\naxis equal\n\n\n\n\nИдентификаторы ребер (E1, 2, 3, … 7) и областей (F1, F2) используются при задании граничных условий. Пластина излучает со всех своих ребер, степень черноты тела принята равной 0.8. Температура среды 4 К.\n\n% Постоянная Стефана-Больцмана\nthermalModelT.StefanBoltzmannConstant = 5.670373E-8; \n% Излучение со всех ребер\n% Степень черноты 0.8\n% Температура среды 4 К \nthermalBC(thermalModelT,'Edge',[1 2 4 5 6 7],'Emissivity',0.8,'AmbientTemperature', 4);\n\n\nВнутренний источник тепла в тонком слое на верхней границе тела (область F2). В этом слое генерируется \\(2 \\cdot 10^7 \\cdot 0.4 \\times 0.001 = 8\\) кДж в секунду. В общем случае, это может быть не число (\\(2 \\cdot 10^7\\)), а ссылка на функцию координат и времени.\n\ninternalHeatSource(thermalModelT,2e7,'Face',2);\n\n\nСоздание сетки\n\ngenerateMesh(thermalModelT,'Hmax',0.03);\npdeplot(thermalModelT); \naxis equal\ntitle 'Сетка'\n\n\n\n\nРасчёт\n\nЗапускаем расчёт на интервале от 0 до 3600 с с шагом 1 с.\n\ntfinal = 3600;\ntlist = 0:1:tfinal;\n\n% Начальная температура тела\nthermalIC(thermalModelT,273);\n\n% Вывести статистическую информацию решателя\nthermalModelT.SolverOptions.ReportStatistics  = 'on';\n\n% Решаем\nresult = solve(thermalModelT,tlist)\n\n\nРезультаты\n\nПосле выполнения функции solve в консоль MATLABа (Command Window) выводится следующая информация\n\n34 successful steps\n0 failed attempts\n49 function evaluations\n1 partial derivatives\n12 LU decompositions\n48 solutions of linear systems\n\n\nПостроим карту температуры пластины на момент времени t=3600 c. Решение получено в numel(tlist)) точках, поэтому распределение температуры в момент времени t=3600 c будет соответствовать самому последнему набору значений массива result.Temperature(:,sol_index), где sol_index будет равен numel(tlist) = 3601.\n\nsol_index = numel(tlist));\npdeplot(thermalModelT,'XYData',result.Temperature(:,sol_index),'Contour','on','ColorMap','hot'); \n% Покажем метки точек, для которых далее будут построены графики изменения температуры\nhold on;\n% Рисуем метки точек\nplot(0,0.000,'bo'); \nplot(0,0.051,'bo'); \n% Рисуем подписи точек\ntext(0,-0.010,'T2','FontSize',18);\ntext(0, 0.060,'T1','FontSize',18);\nhold off;\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nxlim([-0.25 0.25]);\nylim([-0.05 0.15]);\n\n\n\n\nГрафик изменения температуры на верхней и нижней грани пластины.\n\n% Генерируем матрицу размера numel(sol_index)x2 с температурами точек Т1 и Т2. \nprobeTemp = cell2mat(arrayfun(@(i) interpolateTemperature(result,[0.000 0.000],[0.051 0.000],i)',(1:length(tlist))','UniformOutput',false));\n% Первый график на интервале от 0 до 100 с\nsubplot(1,2,1);\nplot(tlist,probeTemp(:,1),'r-','LineWidth',2); hold on;\nplot(tlist,probeTemp(:,2),'b-','LineWidth',2); hold off;\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nlegend('T1','T2');\nxlabel('t, c');\nylabel('Температура, K');\nxlim([0,100]);\n% Второй график на всем интервале от 0 до 3600 с\nsubplot(1,2,2);\nplot(tlist,probeTemp(:,1),'r-','LineWidth',2); hold on;\nplot(tlist,probeTemp(:,2),'b-','LineWidth',2); hold off;\n%plot(tlist,probeTemp(:,2)-probeTemp(:,1),'b-','LineWidth',2);\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nlegend('T1','T2');\nxlabel('t, c');\nylabel('Температура, K');\n\n\n\n\nНиже на видео показана динамика изменения температуры. Стрелками показаны направления тепловых потоков. Показана температура на верхней грани, нижней грани и разница температур. Для построения видео использовался следующий код\n\nv = VideoWriter('temperature.avi');\nopen(v);\n% Фигура\nfigure('Position',[100 100 1920 1080]);\nhold on;\n% Для каждого момента времени из таблицы результатов интегрирования\n[qTx,qTy] = evaluateHeatFlux(result);\nfor i=1:5:size(tlist,2)\n    % Очищаем рисунок\n    cla;\n    %[qTx,qTy] = evaluateHeatFlux(result,0.2,0.05,1:length(tlist));    \n    pdeplot(thermalModelT,'XYData',result.Temperature(:,i),'Contour','on', ...\n                     'FlowData',[qTx(:,i) qTy(:,i)], ...\n                     'ColorMap','hot','Levels',3);        \n    axis([-0.25 0.25,-0.05, 0.15]);    \n    % Определим температуру в двух точках [0,0] и [b+d, 0]\n    % координаты точек задаются двумя массивами координат x и y\n    % [x1, x2, x3, ...], [y1, y2, y3, ...]\n    Temp = interpolateTemperature(result,[0 0],[b+d 0],i);\n    text(0,-0.010,sprintf('%5.1f',Temp(2)),'FontSize',20);\n    text(0,+0.060,sprintf('%5.1f',Temp(1)),'FontSize',20);    \n    % Разница температур\n    text(0,-0.03,sprintf('dT = %5.1f',Temp(1)-Temp(2)),'FontSize',20);    \n    % Время\n    text(-0.2, 0.12,sprintf('t = %5.1f', tlist(i)),'FontSize',20);\n    % Шрифт для подписей осей\n    set(gca,'FontSize',20);\n    % Сетка\n    grid on;   \n    frame = getframe(gcf);    \n    writeVideo(v,frame);\nend\nclose(v);\n\n\n\n\n",
      "categories": ["cae"],
      "tags": ["matlab","термодинамика"],
      
      "collection": "posts",
      "url": "/blog/cae/2019-12-10-pde-thermal/"
    },{
      
      "title": "Модель отделения створки головного обтекателя",
      "date": "2020-03-10 00:00:00 +0400",
      "description": "Интегрирование уравнений движения совместно с уравнениями связей на примере модели движения створки головного обтекателя ракеты-носителя\n",
      "content": "Движение створки головного обтекателя ракеты-носителя\n\nГоловной обтекатель отделяется от ракеты-носителя после того, как ракета-носитель набрала высоту, на которой действие набегающего потока разреженного воздуха уже невелико, что позволяет сбросить “лишнюю” массу головного обтекателя, который до этого момента защищал выводимый на орбиту космический аппарат при движении ракеты-носителя в плотных слоях атмосферы. Существует несколько способов отделения головного обтекателя. Далее рассматривается способ отделения с разделением обтекателя  на две створки и последующим их разворотом [2,3].\n\nСхема системы\n\nДля отделения головного обтекателя производится его механическое разделение на две створки, при этом каждая створка остается шарнирно-закрепленной на ракете-носителе. После этого начинается разворот створок под действием толкателей (по два на створку), каждый из которых закреплен одним концом на створке, а другим – упирается в переходный отсек ракеты-носителя. Толкатели создают момент относительно оси вращения створки, разворачивая её относительно ракеты. При достижении некоторого угла (более 45 градусов) шарнирная связь между створкой и ракетой-носителем разрывается и створка продолжает свободное движение.\n\n\n\nСистемы координат\n\nПостроим модель отделения обтекателя с момента его разделения на две створки до свободного движения створок. Будем считать, что створка – это абсолютно-твердое тело с массой значительно меньшей массы ракеты-носителя, что позволять не учитывать влияние движения створки на движение ракеты-носителя. Будет рассматриваться плоское движение створки, полагая, что все силы действуют на створку в одной плоскости, перпендикулярной оси её вращения, проходящей через центр масс створки.\n\nПоскольку необходимо исследовать движение створки относительно ракеты, для записи уравнений движения удобней использовать неинерциальную систему координат \\(O x_0 y_0 z_0\\), которая связана с ракетной-носителем, движущейся с постоянным ускорением вдоль оси \\(O x_0\\). Также при записи уравнений движения будет использоваться система координат \\(C x_1 y_1 z_1\\), связанная со створкой.\n\n\n\nУравнения движения\n\nДля записи уравнений систем многих тел для получения компактных уравнений движения целесообразно использовать матричную форму записи, которую потом легко перевести на языки компьютерной алгебры. Рассматриваемая механическая система простая и имеет небольшое число степеней свободы. Так при плоском движении на первом этапе движения (этапе разворота) створка имеет одну степень свободы относительно ракеты-носителя, на втором этапе – этапе свободного движения – три степени свободы. Для записи уравнений движения можно использовать уравнения Лагранжа, чтобы получить минимальное количество уравнений движения, но здесь для записи уравнений будут использованы уравнения движения центра масс и уравнения движения вокруг центра масс с учетом действия на створку силы реакции в шарнире. Уравнения движения створки будут решаться совместно с уравнениями связей. Такой подход позволит на всех этапах движения системы  использовать один набор обобщенных координат: положение центра масс и поворот створки, а также определить в процессе интегрирования уравнений движения силы реакции связей в шарнире створки.\n\nУравнение движения центра масс створки\n\nВ системе координат \\(O x_0 y_0 z_0\\) движение центра масс створки описывается одним матричным уравнением, которому соответствует три скалярных уравнения\n\n[m \\ddot{\\boldsymbol r}^{(0)} = \\boldsymbol{P}^{(0)} + \\boldsymbol \\Phi^{(0)} + \\boldsymbol R^{(0)}]\n\nгде \\(\\boldsymbol{P}^{(0)}\\) – координатный столбец вектора силы толкателя, \\(\\boldsymbol \\Phi^{(0)}\\) – координатный столбец переносной силы инерции, \\(\\boldsymbol R^{(0)}\\) – координатный столбец силы реакции в шарнире. Верхним индексом в круглых скобках обозначается то, что координатные столбцы векторов в уравнении записаны в системе координат \\(O x_0 y_0 z_0\\). В неинерциальной системе координат к активным силам и силам реакции необходимо добавить переносную силу инерции, направленную вдоль продольно оси ракеты-носителя. Координатный столбец переносной силы инерции определяется следующим образом:\n\n[\\boldsymbol \\Phi^{(0)} = - \\begin{bmatrix} 1 \\ 0 \\ 0 \\end{bmatrix} m g n_x]\n\nгде \\(m\\) – масса створки, \\(g\\) – ускорение свободного падения, \\(n_x\\) – перегрузка, с которой движется ракета-носитель, которая определяет “действующую” на створку переносную силу инерции в неинерциальной системе координат \\(O x_0 y_0 z_0\\)\n\nСила толкателя, действующего на створку, пропорциональна расстоянию между точками \\(P_0\\) и \\(P_1\\) и направлена вдоль вектора \\(P_0 P_1\\). Обозначим это вектор буквой \\(d\\). В системе координат \\(O x_0 y_0 z_0\\) этот вектор определяется следующим образом\n\n[\\boldsymbol d^{(0)} = - r_{p0}^{(0)} + r^{(0)} + \\boldsymbol{A}1 \\boldsymbol{\\rho}{p1}^{(1)}]\n\nРассматривается плоское движение створки, поэтому действие двух толкателей на створку можно заменить действием одного толкателя с силой равной суммарной силе двух толкателей. Обозначим как \\(\\boldsymbol{e}_P\\) единичный вектор, вдоль которого действует сила толкателя P\n\n\n  \n    \n      [\\boldsymbol{e}_P^{(0)} = \\frac{\\boldsymbol d^{(0)}}{\n      \\boldsymbol d^{(0)}\n      },]\n    \n  \n\n\nтогда координатный столбец силы, действующей на створку, в системе координат \\(O x_0 y_0 z_0\\) будет иметь вид\n\n[\\boldsymbol{P}^{(0)} = \\boldsymbol{e}_P^{(0)} P(d),]\n\nгде \\(P(d)\\) зависимость силы толкателя от его длины (перемещения штока). Сила пружинного толкателя линейно зависит перемещения штока:\n\n[P(d) = P_0 + \\frac{P_0-P_K}{h} (d-d_0)]\n\nгде \\(P_0\\) - начальное усилие толкателя (двух толкателей в рассматриваемой плоской задачи), \\(P_K\\) - конечное усилие толкателя (это также суммарная сила от действия двух толкателей), \\(d_0\\) - начальная длина толкателя (расстояние от точки \\(p_0\\) до \\(p_1\\) ), \\(h\\) - ход толкателя.\n\n\n\nУравнение движения вокруг центра масс\n\nДвижение створки вокруг центра масс описывается динамическим уравнением Эйлера, которые в матричной форме в системе координат, связанной со своркой, имеют вид:\n\n[\\boldsymbol{J}^{(1)} \\dot{\\boldsymbol{\\omega}}^{(1)} + \\boldsymbol{\\omega}^{(1)} \\times \\boldsymbol{J}^{(1)} \\boldsymbol{\\omega}^{(1)} = \\boldsymbol{M}^{(1)}(P) + \\boldsymbol{M}^{(1)}(R)]\n\nВ правой части уравнений движения вокруг центра масс момент от силы толкателя и момент от силы реакции \\(\\boldsymbol{R}\\). Момент от силы толкателя в системе координат, связанной со створкой  записывается следующим образом:\n\n[\\boldsymbol{M}^{(1)}(P) = \\tilde{\\boldsymbol{r}}_{p1}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{P}^{(0)}]\n\nЗдесь и далее оператор тильда обозначает кососимметричную матрицу, записанную из компонент координатного столбца вектора\n\n[\\tilde{\\boldsymbol{a}} = \\begin{bmatrix} 0 &amp; - a_z &amp; a_y \\ a_z &amp; 0 &amp; - a_x \\ - a_y &amp; a_x &amp; 0 \\end{bmatrix}]\n\nКососимметричная матрица используется для матричной записи векторного произведения двух координатных столбцов векторов\n\n[\\boldsymbol{a} \\times \\boldsymbol{b} = \\tilde{\\boldsymbol{a}} \\boldsymbol{b} = - \\tilde{\\boldsymbol{b}} \\boldsymbol{a}]\n\nМомент от силы реакции относительно центра масс створки:\n\n[\\boldsymbol{M}^{(1)}(R) = \\tilde{\\boldsymbol{c}}_{11}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{R}^{(0)}]\n\nС учётом полученных выражений для моментов, уравнение движения вокруг центра масс принимает вид\n\n[\\boldsymbol{J}^{(1)} \\dot{\\boldsymbol{\\omega}}^{(1)} = \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{P}^{(0)} + \\tilde{\\boldsymbol{c}}{11}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{R}^{(0)} - \\boldsymbol{\\omega}^{(1)} \\times \\boldsymbol{J}^{(1)} \\boldsymbol{\\omega}^{(1)}]\n\nВ уравнения движения центра масс и движения вокруг центра масс входят неизвестные силы реакции, которые можно определить, дополнив полученные уравнения движения уравнениями связей.\n\nУравнения связей\n\nПоложение шарнирной точки, связанной со створкой, в системе координат \\(O x_0 y_0 z_0\\) определяется суммой вектора положения центра масс створки и положения шарнирной точки створки относительно центра масс \\(\\mathbf{r}_1^{(0)} + \\mathbf{A}_1 \\mathbf{c}_{11}^{(1)}\\). Матрица поворота или матрица преобразования координат используется в этом выражении для преобразования координат вектора \\(\\mathbf{c}_{11}^{(1)}\\) из системы координат, связанной со створкой в систему координат \\(O x_0 y_0 z_0\\). Система координат, связанная со створкой \\(C_1 x_1 y_1 z_1\\), повёрнута относительно системы координат \\(O x_0 y_0 z_0\\) на угол \\(\\varphi\\) вокруг оси \\(z_0\\), поэтому матрица поворота имеет простой вид\n\n[\\mathbf{A}_1 = \\begin{bmatrix} \\cos \\varphi &amp; -\\sin \\varphi &amp; 0 \\ \\sin \\varphi &amp; \\cos \\varphi &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}]\n\nШарнирная точка створки должна совпадать с соответствующей шарнирной точкой на ракете-носителе, положение которой относительно  \\(O x_0 y_0 z_0\\) определяется неизменным координатным столбцом \\(\\mathbf{c}_{01}^{(0)}\\), поэтому\n\n[\\mathbf{c}{01}^{(0)} = \\mathbf{r}_1^{(0)} + \\mathbf{A}_1 \\mathbf{c}{11}^{(1)}]\n\nПолученное уравнение представляет собой уравнение связи, которое говорит о том, что створка и ракета-носитель в процессе движения имеют одну общую точку – шарнирную точку. При развороте створки относительно шарнира ограничивается и угловое движение створки как твёрдого тела относительно двух других осей, перпендикулярных оси шарнира, однако если на створку действует плоская система сил, лежащая в плоскости \\(O x_0 y_0 z_0\\), в которой также находится и центр масс створки, то дополнительные уравнения связей можно не записывать.\n\nДля интегрирования дифференциальных уравнений движения совместно с алгебраическими уравнениями связей, обычно используют следующую технику решения, которая позволят использовать для интегрирования уравнений движения “стандартные” численные методы решения обыкновенных дифференциальных уравнений. Уравнения связей дважды дифференцируют для получения уравнений связей на  ускорения. Учитывая постоянство координатных столбцов \\(\\mathbf{c}_{11}^{(1)}\\) и \\(\\mathbf{c}_{01}^{(0)}\\), после первого дифференцирования уравнения связи получим:\n\n[\\mathbf{0} = \\mathbf{v}1^{(0)} + \\dot{\\mathbf{A}}_1 \\mathbf{c}{11}^{(1)}]\n\nПроизводная матрицы поворота определяется выражением [1]:\n\n[\\dot{\\mathbf{A}}_1 = \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)}]\n\nгде \\(\\tilde{\\mathbf{\\omega}}_1^{(1)}\\) – кососимметрическая матрица, составленная из компонент вектора угловой скорости створки в проекциях на оси системы координат, связанной со створкой\n\n[\\tilde{\\mathbf{\\omega}}_1^{(1)} = \\begin{bmatrix} 0 &amp; - \\omega_z^{(1)} &amp; \\omega_y^{(1)} \\ \\omega_z^{(1)} &amp; 0 &amp; - \\omega_x^{(1)} \\ - \\omega_y^{(1)} &amp; \\omega_x^{(1)} &amp; 0 \\end{bmatrix}]\n\nС учётом последнего выражения, матричное уравнение связи примет вид\n\n[\\mathbf{0} = \\mathbf{v}1^{(0)} + \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nЭто уравнение, в отличие исходного уравнения связи, уже говорит о том, что не положения, а скорости общих точек створки и ракеты-носителя должны совпадать. При условии того, что начальные условия будет удовлетворять исходному уравнению связи и при точном интегрировании уравнений движения исходное уравнение связи тоже будет выполняться, однако вследствие неизбежной погрешности численного интегрирования возможен так называемый “дрейф” связи – нарушение исходного уравнения связи и удаление шарнирных на створке и ракете-носителе друг от друга. В рассматриваемой задаче, учитывая небольшой интервал времени, на котором рассматривается движение системы, эта погрешность будет мала при разумном выборе точности интегрирования системы дифференциальных уравнений.\n\nПосле второго дифференцирования уравнение связи принимает вид\n\n[\\mathbf{0} = \\mathbf{a}1^{(0)} + \\mathbf{A}_1 \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)} + \\mathbf{A}1 \\tilde{\\boldsymbol{\\varepsilon}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nПолученное уравнение связи требует, чтобы ускорения общих точек створки и ракеты-носителя были одинаковы в процессе интегрирования уравнений движения. Начальные условия должны удовлетворять исходному уравнению связи и уравнению связи, записанному для скоростей точек.\n\nПерепишем уравнение связи, выделив матрицу коэффициентов перед ускорениями, используя тождество \\(\\tilde{\\mathbf a} \\mathbf b = - \\tilde{\\mathbf b} \\mathbf a\\)\n\n[\\mathbf{0} = \\mathbf{a}1^{(0)} + \\mathbf{A}_1 \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)} - \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} \\boldsymbol{\\varepsilon}_1^{(1)}]\n\nСобрав из линейных и угловых ускорений створки столбец \\(6 \\times 1\\), запишем это уравнение в блочном матричном виде\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; - \\mathbf{A}_1 \\tilde{\\mathbf{c}}{11}^{(1)} \n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \n    \\end{bmatrix}\n    = - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nСистема дифференциально-алгебраических уравнений в матричном виде\n\nЭтап 1\n\nОбъединив уравнения движения и уравнения связи в одно блочное матричное уравнение, получим для первого этапа движения (вращение створки)\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T\n        \n        \\mathbf{E}{3 \\times 3} &amp; - \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} &amp; \\mathbf{0}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}_1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nПоскольку\n\n[(\\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)})^T  = - \\tilde{\\mathbf{c}}_{11}^{(1)} \\mathbf{A}_1^T,]\n\nс точностью до знака полученная матрица коэффициентов является симметричной. Умножив уравнение связи на минус 1, получим симметричную матрицу коэффициентов\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T\n        \n        - \\mathbf{E}{3 \\times 3} &amp; \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} &amp; \\mathbf{0}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}_1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nСтруктура этой системы дифференциально-алгебраических уравнений следующая\n\n[\\begin{bmatrix} \\boldsymbol{M} &amp; \\boldsymbol{Q}^T \n    \\boldsymbol{Q}^T &amp; \\boldsymbol{0} \n    \\end{bmatrix} \\begin{bmatrix} \\ddot{\\boldsymbol{X}} \\ \\boldsymbol{R} \\end{bmatrix}=\n    \\begin{bmatrix}\n    \\boldsymbol{L} \\ \\boldsymbol{B}\n    \\end{bmatrix}]\n\nЭту систему можно представить в виде двух матричных уравнений\n\n[\\begin{aligned}\n    \\boldsymbol{M} \\ddot{\\boldsymbol{X}} + \\boldsymbol{Q}^T \\boldsymbol{R} = \\boldsymbol{L} \n    \\boldsymbol{Q}^T \\ddot{\\boldsymbol{X}} = \\boldsymbol{B} \n    \\end{aligned}]\n\nВыразив из первого уравнения \\(\\ddot{\\boldsymbol{X}}\\)\n\n[\\ddot{\\boldsymbol{X}} = \\boldsymbol{M}^{-1} ( \\boldsymbol{L} - \\boldsymbol{Q}^T \\boldsymbol{R} )]\n\nи подставив во второе уравнение, получим систему линейный уравнений для определения сил реакций\n\n[(\\boldsymbol{Q}^T \\boldsymbol{M}^{-1} \\boldsymbol{Q}^T) \\boldsymbol{R}  = \\boldsymbol{Q}^T \\boldsymbol{M}^{-1}  \\boldsymbol{L} - \\boldsymbol{B},]\n\nчто позволяет найти столбец ускорений\n\n[\\ddot{\\boldsymbol{X}} = \\boldsymbol{M}^{-1} (\\boldsymbol{L} - \\boldsymbol{Q}^T  (\\boldsymbol{Q}^T \\boldsymbol{M}^{-1} \\boldsymbol{Q}^T)^{-1} (\\boldsymbol{Q}^T \\boldsymbol{M}^{-1}  \\boldsymbol{L} - \\boldsymbol{B}) )]\n\nЭтап 2\n\nНа втором этапе движения механическая связь между створкой и ракетной-носителем отсутствует. Для учёта этого уравнение связи можно заменить на матричное уравнение (три скалярных уравнения)\n\n[\\mathbf{R}^{(0)} = 0]\n\nтогда, система уравнений примет вид\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T \n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3}  &amp; \\mathbf{E}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nКод\n\nПримеры кода на языках MATLAB и Python, реализующие описанный алгоритм.\n\nКод на языке MATLAB\n\nФайл-скрипт main.m\n\n\nclc; clear all;\n% Положение шарнирной точки отчносительно центра масс створки с ССК\np.c11 = [-4.0;  1.0; 0.0];\n% Положение точки закрепления толкателя на створке относительно центра масс\n% створки в ССК\np.rp1 = [-3.5; -0.8; 0.0];  \n% Положение точки закрепления толкателя на РН относительно БСК\np.rp0 = [ 0.0;  0.2; 0.0];  \n% Ускорение свободного падения\np.g   = 9.807;            \n% Начальное усиле толкателей\np.P0  = 30000;            \n% Конечное усилие толкателей\np.Pk  = 10000;            \n% Ход толкателя\np.h   = 0.4;   \n% Начальная длина толкателя\np.d0  = 0.5;\n% Масса створки\np.m   = 1000;  \n% Тензор инерции створки\np.J   = diag([10000,10000,10000]);            \n%\np.phimax   = 60;            \n\n% Начальные условия\nq0 = [4.0; 1.0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]; \n% Первый этап\np.Stage = 1;\nopt = odeset('Events', @(t,q) PhiEvent(t,q,p));\n[t1,q1] = ode45(@(t, q) dqdt(t, q, p), 0:0.02:2, q0, opt);\n% Второй этап\np.Stage = 2;\n[t2,q2] = ode45(@(t, q) dqdt(t, q, p), [t1(end):0.02:3], q1(end, :)');\n% Склейка результатов двух этапов\nt = [t1(1:end - 1); t2];\nq = [q1(1:end - 1, :); q2];  \n\n\nФайл-функция правых частей дифференциальных уравнений dqdt.m\n\nfunction [dq, R]= dqdt(t, q, p)\n% Извлекаем компоненты из вектора состояния\n% Координатный столбцец центра масс\nr   = q(1:3);     \n% Углы поворота створки\n% в плоской задаче испольуется только последний, а остальные принимаются\n% равными нулю\nphi = q(4:6); \n% Координатный столбец скорости центра масс створки в СК РН\nv   = q(7:9); \n% Координатный столбец угловой скорости\nw   = q(10:12);       \n% в плоской задаче испольуется только последнее значение - wz, а остальные принимаются\n% равными нулю\nwz  = w(3);\n\n% Этап движения \nStage = p.Stage;\n% Матрица поворота вокруг оси z\nA     = @(a) [cos(a), -sin(a) 0; sin(a), cos(a), 0;0 0 1];\n% Оператор тильда\ntilde = @(a) [0 -a(3) a(2); a(3) 0 -a(1); -a(2) a(1) 0];\n% Матрица поворота на угол phi вокруг оси z\nA1    = A(phi(3));\n\n% Матрица коэффиицентов при ускорениях в уравнениях связей, ограичивающих\n% перемещение шарнирной точки\nQ     = - A1*tilde(p.c11);\n% Матрица коэффициентов при реакциях в уравнении движения створки вокруг\n% центра масс\nQT    = - tilde(p.c11)*A1';\n\n% Вектор от точки закрепления толкателя на РН до точки закрепления\n% толкателя на створке\nd     = - p.rp0 + r + A1*p.rp1;\n% Модуль этого вектора\nnd    = norm(d);\n% Единичный вектор этого напарвления  \ned    = d/nd;\n\n% Если длина толкателя не больше его начальной длины и хода\n% вычисляем силу\nif nd &lt; p.d0 + p.h\n   Pin0 = ed*(p.P0 - (p.P0-p.Pk)*(nd-p.d0)/p.h );    \n% иначе, толкатель уже не работает\nelse\n   Pin0 = [0;0;0]; \nend\n% Координатный столбец силы в ССК створки\nPin1          = A1'*Pin0;\n% Координатный столбец силы инерции в СК РН (вдоль продольной оси)\nInertialForce = [-1;0;0]*p.m*p.g;\n\nE3 = eye(3);\nZ3 = zeros(3);\n\nif Stage == 1\n    % Матрица коэффициентов для первого этапа \n    M = [p.m*E3   Z3 -E3; \n             Z3  p.J -QT; \n             E3  Q    Z3];\nend\nif Stage == 2\n    % Матрица коэффициентов для второго этапа \n    % Реакции равны нулю\n    M = [p.m*E3   Z3  E3; \n             Z3  p.J -QT; \n             Z3   Z3  E3];\nend\n\n% Матрица-столбец правой части ДАУ\nB = [Pin0 + InertialForce; \n     tilde(p.rp1)*Pin1;\n     -A1*tilde(w)*tilde(w)*p.c11];\n\n% Находим ускорения и реакции  \nX = M\\B;                            \n\nR = X(7:9);\n\n% Кинематические уравнения для плоского движения \n% Производня последнего угла равна угловой скорости, остальные компоненты\n% равны нулю\ndphi = [0;0;wz];\n\n% Производня вектора состояния\ndq = [v; dphi; X(1:6)];                \n\nend\n\n\nФайл-функция событий системы дифференциальных уравнений dqdt.m\n\nФайл-функция событий передается в качестве параметра в функцию интегрирования дифференциальных уравнений и предназначена для остановки процесса интегрировании при заданном условии, которое задается функцией, изменяющей знак. В рассматриваемой задаче такой функцией будет угол поворота створки.\n\n\nfunction [Value, isterminal, direction] = PhiEvent(t, q,p)\n    \n    % Если угол поврота превышает phimax...\n    Value = q(6)-deg2rad(p.phimax);     \n    % при увеличении угла, \n    direction = 1;                       \n    % то остановить интегрирование\n    isterminal = 1;                     \n\nend\n\n\n\n\nКод на языке Python\n\nВес код программы можно разместить в одном файле. Удобно для решения подобных задач использовать Jupyter notebook\n\n\n# Массивы, матрицы\nimport numpy as np\n# Для численного интегрирования дифференциальных уранвений\nfrom scipy.integrate import solve_ivp\n\n# Для построения графиков\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n# Настройки графиков по умолчанию\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n# Для передачи параметров в функцию объеденим их в структуру namedtuple\nfrom collections import namedtuple\n\n\n\n\n# Параметры системы\nParameters = namedtuple('Parameters' , 'm J c11 c01 rp0 rp1 d0 h P0 PK nx g phimax')\n\nparam1 = Parameters(m=1000.0, \n                    J=np.diag([5000,10000,10000.]), \n                    c11 = np.array([-4.0, 1.0, 0.0]),\n                    c01 = np.array([ 0.0, 2.0, 0.0]),                    \n                    rp0 = np.array([ 0.0, 0.4, 0.0]),\n                    rp1 = np.array([-3.5,-0.6, 0.0]),\n                    d0  = 0.5,\n                    h   = 0.4,\n                    P0  =  50000,\n                    PK  =  40000,\n                    nx  = 1.0,\n                    g   = 9.807,\n                    phimax = np.deg2rad(50))\n\n\nФункции матрицы поворота и оператор тильда\n\n\n# Матрица 0 3x3\nZ3 = np.zeros((3, 3))\n\n# Единичная матрица 3x3\nE3 = np.identity(3)\n\n# Матрица поворота  \ndef Az(a):  \n  return np.array([[np.cos(a), -np.sin(a), 0],[np.sin(a), np.cos(a), 0],[0, 0, 1.0]]);\n\n# Тильда\ndef tilde(a):  \n  return np.array([[     0, -a[2],  a[1] ], \n                   [  a[2],     0, -a[0] ],\n                   [ -a[1],  a[0],    0  ] ])\n\n\nФункция правых частей системы дифференциальных уравнений.\n\n\ndef dqdt(t,q,p):  \n  # координатный столбец центра масс  \n  r   = q[0:3]\n  # углы поворота створки\n  a   = q[3:6]\n  # в рассматриваемой плоской задаче \n  # используется только один - последний из трёх\n  phi = a[2]  \n  # координатный столбец скорости центра масс  \n  v   = q[6:9]\n  # координатный столбец угловой скорости створки  \n  w   = q[9:12]\n\n  # Вычисляем матрицу поворота для текущего значения угла\n  A1 = Az(phi)\n\n  # Коэффициенты при ускорениях в уравнениях связей\n  Q = np.dot(A1, tilde(p.c11))\n  \n  # Переносная сила инерции\n  F  = np.array([-1,0,0])*p.m*p.g*p.nx\n  \n  # Вектор p0p1\n  d  = -p.rp0 + r + np.dot(A1,p.rp1)\n  # Длина вектора\n  dn = np.sqrt(np.dot(d,d))\n  # Едичиный вектор направления силы в базисе x0y0z0\n  eP = d/dn\n  \n  # Сила толкателя  \n  P  = 0*eP\n\n  if dn&lt;p.d0+p.h:\n    P  = (p.P0 + (dn-p.d0)*(p.P0-p.PK)/p.h)*eP \n    \n\n  # Матрица коэффициентов\n  A = np.block([[E3*p.m,  Z3,             -E3],\n                [Z3    , p.J, np.transpose(Q)],\n                [-E3   ,   Q,              Z3]])\n\n  if STAGE == 2:\n    # Матрица коэффициентов\n    A = np.block([[E3*p.m,  Z3,             -E3],\n                  [Z3    , p.J, np.transpose(Q)],\n                  [Z3    ,   Z3,             E3]])\n  \n    # Матрица правой части\n  B = np.block([ F + P, \n                -np.cross(w,np.dot(p.J,w)) + np.cross(p.rp1, np.dot(np.transpose(A1),P)),\n                 np.dot(np.dot(A1,np.dot(tilde(w),tilde(w))),p.c11)])\n\n  X = np.linalg.solve(A,B)\n\n  dq = np.block([v,w,X[0:6]])\n  \n  return dq\n\n\n\nФункция-“детектор”, передаваемая в интегратор (параметр events), для определения времени перехода от этапа 1 к этапу 2 и остановки процесса интегрирования функция возвращает разницу между углом потери связи и текущим углом\n\n\ndef event_phi_eq_phimax(t, q):\n  return param1.phimax-q[5]\n\n# функция-детектор останавливает процесс интегрирование\nevent_phi_eq_phimax.terminal = True\n# при пересечении функции нуля при убывании\nevent_phi_eq_phimax.direction = -1.0\n\n\n\nЗапускаем процесс интегрирования\n\n\nq0 = [4, 1, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0];\n\nSTAGE = 1\ns1 = solve_ivp(lambda t, y: dqdt(t, y, param1), [0, 1.5], q0,  \n               events = [event_phi_eq_phimax],  rtol = 1e-7, max_step=0.1)\n\n\nSTAGE = 2\n\nq1 = s1.y[:,-1]\ns2 = solve_ivp(lambda t, y: dqdt(t, y, param1), [s1.t[-1], 2], q1, rtol = 1e-6, max_step=0.1)\n\n\n\nГрафик изменения угла и угловой скорости створки\n\n\nplt.plot(s1.t,s1.y[5]*180/np.pi,'r-')\nplt.plot(s2.t,s2.y[5]*180/np.pi,'r--')\nplt.plot(s1.t,s1.y[11]*180/np.pi,'b-')\nplt.plot(s2.t,s2.y[11]*180/np.pi,'b--')\nplt.xlabel('t, c'), plt.ylabel('$\\\\varphi$, $\\\\omega$');\nplt.grid(ls='--'), plt.legend(['$\\\\varphi$ Этап 1','$\\\\varphi$ Этап 2']);\n\n\n\nИсточники\n\n\n  Маркеев А. П.  Теоретическая механика: Учебник для университетов. 3-е изд. — М.; Ижевск: РХД, 2007. — 592 с.\n  Колесников К.С., Кокушкин В.В., Борзых С.В., Панкова Н.В. Расчет и проектирование систем разделения ступеней ракет: учебное пособие. М.: МГТУ им. Н.Э. Баумана. 2006. 376 с.\n  Круглов Г. Е. Аналитическое проектирование механических систем [Электронный ресурс] : учеб. пособие. Самарский государственный аэрокосмический университет им. С. П. Королева. 2000.\n\n",
      "categories": ["mechanics"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2020-03-10-fairing/"
    },{
      
      "title": "Уравнения Лагранжа II рода в Wolfram Mathematica",
      "date": "2020-04-10 00:00:00 +0400",
      "description": "Пример построения и интегрирования уравнений движения механической системы с двумя степенями свободы\n",
      "content": "Открыть пример\n",
      "categories": [],
      "tags": ["Mathematica","Механика"],
      
      "collection": "posts",
      "url": "/blog/2020-04-10-Mathematica-mech/"
    },{
      
      "title": "Игра Жизнь на SQL",
      "date": "2020-05-09 00:00:00 +0400",
      "description": "Реализации игры Жизнь на языке SQL.\n",
      "content": "В процессе подготовки материалов для очередной лекции по Базам данных студентов Института экономики и управления Самарского университета возникла идея реализовать алгоритм игры “Жизнь” на SQL.\n\nБаза данных состоит из двух таблиц: таблица cells с координатами клеток колонии, вместе с номером поколения, которому эти клетки принадлежат, и “константная” таблица относительных координат смежных клеток (dxdy). Алгоритм смены поколений записан в процедуре NextGen. При помощи объединения (UNION) результатов двух SELECT выбираются клетки, переходящие в следующее поколение (клетки c 2 или 3 соседями), и определяются рождающиеся клетки (граничащие ровно с 3 соседями). Результат с номером нового поколения вставляется в таблицу cells.\n\nПодробности…\n",
      "categories": [],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/2020-05-09-Game-of-Life-SQL/"
    },{
      
      "title": "Простая функция определения плотности воздуха",
      "date": "2020-05-19 00:00:00 +0400",
      
      "content": "Простая функция аппроксимирующая плотность воздуха в диапазоне высот от 0 до 100 км\n\n% Модель атмосферы в диапазоне от 0 до 100 км с погрешностью 1,5%\n% В. А. ЯРОШЕВСКИЙ \"АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ\"\n% Ученые записки ЦАГИ, т. XL, №3, 2009.\n%\n% density = rho(h)\n% Atmospheric density\n%   h [meters]\n%   density [kg/m^3]\nfunction density = rho(h)\n\na  = [-6.3759,-7.3012,-1.1817];\nb  = [-0.4754,-0.0096,-0.0068,-0.0120,0.0042];\nc  = [ 0.1803, 0.0872,-0.0153, 0.0145,0     ];\n\n\nx = (h*0.001)/50.0-1; \nsa = a(1) + a(2)*x + a(3)*x*x;\n\n%rho = sum(arrayfun(@(i) b(i)*cos(i*pi*x) + c(i)*sin(i*pi*x), 1:5));\nrho = 0;\nfor i=1:5\n    rho = rho + b(i)*cos(i*pi*x) + c(i)*sin(i*pi*x);\nend\n\ndensity = exp(sa + rho);\n\nend\n\n",
      "categories": ["programming","cae"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/programming/cae/2020-05-19-atm-density-matlab/"
    },{
      
      "title": "Пример построения сложного запроса к базе данных",
      "date": "2020-05-20 00:00:00 +0400",
      
      "content": "Составить запрос к базе данных, формирующий список производителей товаров, проданных до заданной даны во всех филиалах (магазинах), с указанием суммарной стоимости проданных товаров для каждого производителя.\n\nНачнём с простого запроса к таблице покупок. Выведем номер (идентификатор) покупки, дату и идентификатор покупателя – вся эта информация есть в таблице purchases:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id \nFROM \n\tpurchases \nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\n\n\nРезультат выполнения запроса, из которого следует, что до 30 января 2019 года (некоторая произвольно заданная дата) было совершено 7 покупок:\n\npurchase_id|purchase_date|customer_id|\n-----------|-------------|-----------|\n         12|   2019-01-24|          9|\n         32|   2019-01-25|          2|\n         37|   2019-01-10|          1|\n         46|   2019-01-06|         10|\n         60|   2019-01-24|          4|\n         75|   2019-01-06|          6|\n         83|   2019-01-29|          8|\n\n\nВ полученном результате отсутствует информация о товарах, которые были куплены в каждой покупке. Эта информация есть в таблице purchase_items – “купленные товары”.\n\nВ таблице purchase_items есть поле (столбец) purchase_id, который представляет собой ссылку на идентификатор покупки в таблице покупок purchases, т.е. purchase_items.purchase_id является внешним ключом.\n\nЧтобы увидеть список товаров для каждой покупки необходимо для каждой строки полученного выше результата, т.е. каждой покупки, найти и вывести соответствующую строку из таблицы purchase_items: нужно найти строки у которых purchase_items.purchase_id = purchases.purchase_id. Такое соединение двух таблиц выполняется при помощи оператора LEFT JOIN:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n    purchase_items.product_id\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\n\n\nВнешнее соединение LEFT JOIN: означает, что помимо строк, для которых выполняется условие предиката (ON УСЛОВИЕ), в результирующий набор попадут все остальные строки из первой таблицы (левой). При этом отсутствующие значения полей из правой таблицы будут заполнены NULL-значениями.\n\nВ рассматриваемом случае покупка не может не содержать списка товаров, поэтому для записи из левой таблицы purchases всегда найдётся хотя бы одно соответствие (товар) в правой таблице purchase_items.\n\nРезультат запроса\n\npurchase_id|purchase_date|customer_id|product_id|\n-----------|-------------|-----------|----------|\n         12|2019-01-24   |          9|         3|\n         32|2019-01-25   |          2|        11|\n         32|2019-01-25   |          2|        46|\n         37|2019-01-10   |          1|        35|\n         37|2019-01-10   |          1|        43|\n         46|2019-01-06   |         10|        19|\n         46|2019-01-06   |         10|        28|\n         46|2019-01-06   |         10|        30|\n         60|2019-01-24   |          4|        28|\n         60|2019-01-24   |          4|        47|\n         75|2019-01-06   |          6|        48|\n         83|2019-01-29   |          8|        21|\n\n\nВ полученном новом результате больше строк, чем первом запросе, поскольку некоторым покупкам соответствует несколько проданных товаров. Например, запись о покупке с номером 32  повторяется два раза, следовательно в таблице purchase_items нашлось две записи с таким номером и это означает, что в этой покупке было куплено 2 товара с номерами 11 и 46.\n\nНомер покупки 46 повторяется три раза, т.е. в рамках этой покупки было куплено 3 товара с номерами 19, 28 и 30.\n\nВ полученном результате больше информации, но она не наглядна, поскольку вместо имен покупателей, наименований товаров, указаны их номера. Для того чтобы увидеть вместо номера товара его наименование необходимо найти в таблице товаров имя, которой соответствует номеру товара в последнем запросе. Это делается также при помощи внешнего соединения LEFT JOIN  таблицы products с условием ON products.product_id = purchase_items.product_id:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n-- Вместо идентификатора продукта выведем его имя из присоединенной таблицы товаров --\n    products.product_name\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\t\n\n\nРезультат\n\npurchase_id|purchase_date|customer_id|product_name                                 |\n-----------|-------------|-----------|---------------------------------------------|\n         12|2019-01-24   |          9|Ноутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|\n         32|2019-01-25   |          2|Швейная машина, оверлок Pfaff Expression 150 |\n         32|2019-01-25   |          2|Электрочайник Winner WR-126                  |\n         37|2019-01-10   |          1|Мультиварка Marta MT-1981                    |\n         37|2019-01-10   |          1|Микроволновая печь Daewoo KOR-8A4R           |\n         46|2019-01-06   |         10|Пылесос Redmond RV-350                       |\n         46|2019-01-06   |         10|Электрочайник Vitesse VS-118                 |\n         46|2019-01-06   |         10|Весы Unit UBS-2156                           |\n         60|2019-01-24   |          4|Электрочайник Vitesse VS-118                 |\n         60|2019-01-24   |          4|Весы Energy EN-426                           |\n         75|2019-01-06   |          6|Монитор HP V214a                             |\n         83|2019-01-29   |          8|Ноутбук HP ProBook 470 G5 [470G5 2UB59EA]    |\n\n\nДобавим к результату столбец производителя, выполнив LEFT JOIN с таблицей manufacturers по условию manufacturers.manufacturer_id = products.manufacturer_id\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n    products.product_name,\n--  Добавим имя производителя и назо    вем его для краткости brand --    \n    manufacturers.manufacturer_name as brand     \nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\t\n\n\nРезультат запроса\n\npurchase_id|purchase_date|customer_id|product_name                                 |brand  |\n-----------|-------------|-----------|---------------------------------------------|-------|\n         12|2019-01-24   |          9|Ноутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|HP     |\n         32|2019-01-25   |          2|Швейная машина, оверлок Pfaff Expression 150 |Pfaff  |\n         32|2019-01-25   |          2|Электрочайник Winner WR-126                  |Winner |\n         37|2019-01-10   |          1|Мультиварка Marta MT-1981                    |Marta  |\n         37|2019-01-10   |          1|Микроволновая печь Daewoo KOR-8A4R           |Daewoo |\n         46|2019-01-06   |         10|Пылесос Redmond RV-350                       |Redmond|\n         46|2019-01-06   |         10|Электрочайник Vitesse VS-118                 |Vitesse|\n         46|2019-01-06   |         10|Весы Unit UBS-2156                           |Unit   |\n         60|2019-01-24   |          4|Электрочайник Vitesse VS-118                 |Vitesse|\n         60|2019-01-24   |          4|Весы Energy EN-426                           |Energy |\n         75|2019-01-06   |          6|Монитор HP V214a                             |HP     |\n         83|2019-01-29   |          8|Ноутбук HP ProBook 470 G5 [470G5 2UB59EA]    |HP     |\n\n\nВ соответствии с заданием необходимо получить суммарную стоимость проданных товаров каждого производителя до заданной даты. Учитывая это исключим из запроса лишние для решения поставленной задачи столбцы, кроме наименования товара (для ясности) и добавим столбцы с ценой товара и количества. Информация для двух новых столбцов есть в первой присоединенной таблице purchase_items:\n\nSELECT \n    products.product_name,    \n    manufacturers.manufacturer_name as brand,\n    purchase_items.product_price,\n    purchase_items.product_count \nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER);\t\n\n\nРезультат выполнения запроса\n\nproduct_name                                 |brand  |product_price|product_count|\n---------------------------------------------|-------|-------------|-------------|\nНоутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|HP     |        54890|            1|\nШвейная машина, оверлок Pfaff Expression 150 |Pfaff  |        91850|            1|\nЭлектрочайник Winner WR-126                  |Winner |        818.4|            1|\nМультиварка Marta MT-1981                    |Marta  |       2855.6|            1|\nМикроволновая печь Daewoo KOR-8A4R           |Daewoo |       5481.3|            2|\nПылесос Redmond RV-350                       |Redmond|       5377.9|            1|\nЭлектрочайник Vitesse VS-118                 |Vitesse|       5149.1|            2|\nВесы Unit UBS-2156                           |Unit   |        647.9|            2|\nЭлектрочайник Vitesse VS-118                 |Vitesse|       5149.1|            1|\nВесы Energy EN-426                           |Energy |        625.9|            1|\nМонитор HP V214a                             |HP     |      22544.5|            2|\nНоутбук HP ProBook 470 G5 [470G5 2UB59EA]    |HP     |        60159|            2|\n\n\nПолучен список товаров с наименованием производителя каждого товара, цены товара и его количества, проданных до 30 января 2019 года. Если теперь исключить из результата первый столбцец, то получим список производителей проданных товаров\n\nbrand  |product_price|product_count|\n-------|-------------|-------------|\nHP     |        54890|            1|\nPfaff  |        91850|            1|\nWinner |        818.4|            1|\nMarta  |       2855.6|            1|\nDaewoo |       5481.3|            2|\nRedmond|       5377.9|            1|\nVitesse|       5149.1|            2|\nUnit   |        647.9|            2|\nVitesse|       5149.1|            1|\nEnergy |        625.9|            1|\nHP     |      22544.5|            2|\nHP     |        60159|            2|\n\n\nЧтобы найти суммарную стоимость проданных товаров каждого производителя необходимо сложить стоимость всех товаров каждого производителя (с учетом количества в последнем столбце). Для этого необходимо сгруппировать значения первого столбца или, другими словами, объеденить одинаковые значения в первом столбце, используя оператор GROUP BY, а к объединямым произведениям цены на количество применить агрегатную функцию SUM:\n\nSELECT \n    manufacturers.manufacturer_name as brand,\n    SUM(purchase_items.product_price*purchase_items.product_count) as total\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\nGROUP BY\n\tbrand;\n\n\nРезультат\n\nbrand  |total             |\n-------|------------------|\nDaewoo |           10962.6|\nEnergy |             625.9|\nHP     |            220297|\nMarta  |            2855.6|\nPfaff  |             91850|\nRedmond|            5377.9|\nUnit   |            1295.8|\nVitesse|15447.300000000001|\nWinner |             818.4|\n\n\nНайдена суммарная стоимость проданных товаров каждого производителя до 30 января 2019 года.\n\nВопрос: Как нужно изменить запрос, чтобы выводилась информация для всех производителей, которые есть в базе данных с указанием нулевой суммы для тех производителей, товары которых не были проданы до 30 января 2020 года?\n",
      "categories": ["programming"],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/programming/2020-05-20-select-sql/"
    },{
      
      "title": "Создание множества баз данных и пользователей в MySQL",
      "date": "2021-02-22 00:00:00 +0400",
      
      "content": "В рамках курса “Базы данных” на кафедре ММЭ для выполнения лабораторных работ понадобилось запустить MySQL сервер и создать для каждого студента свою учетную запись и базу данных на сервере.\n\nДля формирования SQL-сценария для создания баз данных и пользователей использовался  bash-скрипт. В первой bash-скрипта части читается тектовый файл students.txt, в котором в одну колонку записаны номера зачетных книжек студентов в формате YYYY-NNNNN. Для каждого номера зачетной книжки генерируется пароль pwgen. Результат (номер пароль) записывается в текстовый файл userpass.txt.\n\n#!/bin/bash\n\nBTICK='`'\n\ncat /dev/null &gt; 'userpass.txt'\n\nwhile IFS=\" \" read -r USERNAME remainder\ndo      \n    PASSWORD=`pwgen 12 1`\n    echo $USERNAME $PASSWORD &gt;&gt; 'userpass.txt'\ndone &lt; \"students.txt\"\n\n\nВо второй части из файла userpass.txt читаются номера зачетных книжек и пароли, формируются имя пользователя uYYYY_NNNNN и база данных db_YYYY_NNNNN. SQL-скрипт создания базы данных и пользователя записывается в файл create_user_script.sql.\n\ncat /dev/null &gt; 'create_user_script.sql'\n\nwhile IFS=\" \" read -r UNAME UPASS remainder\ndo\n    UNAME=${UNAME//-/_}  \n    DBNAME=\"db_$UNAME\"\n    UNAME=\"u$UNAME\"\n    \n    Q1=\"CREATE DATABASE IF NOT EXISTS $DBNAME;\"\n    Q2=\"GRANT ALL ON ${BTICK}$DBNAME${BTICK}.* TO '$UNAME'@'%' IDENTIFIED BY '$UPASS';\"\n    echo $Q1 &gt;&gt; 'create_user_script.sql'\n    echo $Q2 &gt;&gt; 'create_user_script.sql'\ndone &lt; \"userpass.txt\"\n\necho 'FLUSH PRIVILEGES;' &gt;&gt; 'create_user_script.sql'\n\n",
      "categories": ["mechanics"],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2021-02-22-mysql-add-multiple-users/"
    },{
      
      "title": "Навык Алисы для CelesTrak",
      "date": "2021-03-14 00:00:00 +0400",
      
      "content": "Сделал на платформе Яндекс.Диалоги голосовой интерфейс к каталогу космических запусков CelesTrak. Пока поиск выполняется только по каталогу с пусками за последние 30 дней.\n\nВозможности:\n\n\n  Поиск по имени: “Найди объект по имени Прогресс”\n  Поиск по SATID: “Найди объект 47720”\n  Поиск по высоте орбиты: “Найди объект с минимальной высотой 300 километров”, “Найди объект на орбите 300 километров”, “Найди объект с максимальной высотой 700 км”\n  Найди последний объект в базе\n  Уточнение параметра после первого запроса: “Какое наклонение?”, “Какой аргумент перигея?”, “Какая долгота восходящего узла?”\n\n\nЧто предполагается сделать:\n\n\n  Контроль изменений элементов орбиты выбранного объекта.\n  Использование других каталогов с CelesTrak.\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-03-14-alice-celestrak/"
    },{
      
      "title": "Инженерное и математическое программное обеспечение",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/cae/"
    },{
      
      "title": "Example",
      "date": "2021-03-21 14:49:06 +0400",
      "description": "This is a featured category, which have their own page. Check out _featured_tags/example.md to learn how to create your own.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/example/"
    },{
      
      "title": "Hyde",
      "date": "2021-03-21 14:49:06 +0400",
      "description": "Hyde is a brazen two-column Jekyll theme that pairs a prominent sidebar with uncomplicated content. It’s based on Poole, the Jekyll butler. Open _featured_tags/hyde.md to edit this text.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/hyde/"
    },{
      
      "title": "Hydejack",
      "date": "2021-03-21 14:49:06 +0400",
      "description": "Hydejack is a pretentious two-column Jekyll theme, stolen by @qwtel from Hyde. You could say it was.. hydejacked. Open _featured_tags/hydejack.md to edit this text.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/hydejack/"
    },{
      
      "title": "Механика",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/mechanics/"
    },{
      
      "title": "Программирование",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/programming/"
    },{
      
      "title": "Базы данных",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-database/"
    },{
      
      "title": "Космический мусор",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-debris/"
    },{
      
      "title": "IT-сервис",
      "date": "2021-03-21 14:49:06 +0400",
      "description": "ИТ-сервис\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-it-service/"
    },{
      
      "title": "Linux",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-linux/"
    },{
      
      "title": "Mathematica",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-mathematica/"
    },{
      
      "title": "MATLAB",
      "date": "2021-03-21 14:49:06 +0400",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-matlab/"
    },{
      
      "title": "Python",
      "date": "2021-03-21 14:49:06 +0400",
      "description": "Использование языка Python в научных вычислениях\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-python/"
    }
  ]
}

